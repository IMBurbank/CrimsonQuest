'use strict';

/**
 * Consumable Items
 */

var itemConsumables = {
  //Potions
  potion: {
    name: 'Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { curHealth: 50 },
    spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
  },
  hiPotion: {
    name: 'Hi Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { curHealth: 150 },
    spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
  },
  xPotion: {
    name: 'X Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [96, 64, 32, 32],
    buy: 150,
    sell: 75,
    stats: { curHealth: 500 },
    spawnQuant: { '10': 1 }
  },
  //Tomes
  tomeOfVitality: {
    name: 'Tome of Vitality',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 160, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iVitality: 1 },
    spawnQuant: { '3': 1, '6': 1, '9': 1 }
  },
  tomeOfDurability: {
    name: 'Tome of Durability',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iDurability: 1 },
    spawnQuant: { '2': 1, '5': 1, '8': 1 }
  },
  tomeOfStrength: {
    name: 'Tome of Strength',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1, '4': 1, '8': 1 }
  },
  tomeOfAgility: {
    name: 'Tome of Agility',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [64, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iAgility: 1 },
    spawnQuant: { '2': 1, '5': 1, '9': 1 }
  },
  tomeOfWisdom: {
    name: 'Tome of Wisdom',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 160, 32, 32],
    buy: 200,
    sell: 100,
    stats: { statPoints: 1 },
    spawnQuant: { '4': 1, '6': 1, '8': 1, '10': 1 }
  },
  //Gold
  gold1: {
    name: 'a little Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(1, 3);
      } },
    spawnQuant: { '1': 10, '2': 10, '3': 7, '4': 5, '5': 3 }
  },
  gold2: {
    name: 'some Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(4, 7);
      } },
    spawnQuant: { '3': 2, '4': 4, '5': 7, '6': 9, '7': 6, '8': 3, '9': 1 }
  },
  gold3: {
    name: 'a small pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(8, 12);
      } },
    spawnQuant: { '7': 3, '8': 6, '9': 7, '10': 4 }
  },
  gold4: {
    name: 'a pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(13, 17);
      } },
    spawnQuant: { '9': 2, '10': 6 }
  }
};

var chestConsumables = {
  closedChest: {
    name: 'Treasure Chest',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 0, 32, 32]
  },
  openChest: {
    name: 'Treasure Chest',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 0, 32, 32]
  },
  closedBarrel: {
    name: 'Barrel',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 32, 32, 32]
  },
  openBarrel: {
    name: 'Barrel',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 32, 32, 32]
  }
};
'use strict';

var enemyAvian = {
  timidBat: {
    name: 'Timid Bat',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [128, 352],
    spawnQuant: { '1': 15 },
    boss: false,
    aggression: 2,
    levelRange: [1, 1],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  annoyedOwl: {
    name: 'Annoyed Owl',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [32, 320],
    spawnQuant: { '1': 10, '2': 10 },
    boss: false,
    aggression: 2,
    levelRange: [1, 2],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  bloodBat: {
    name: 'Blood Bat',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [64, 352],
    spawnQuant: { '3': 10, '4': 5 },
    boss: false,
    aggression: 3,
    levelRange: [4, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  deathHawk: {
    name: 'Death Hawk',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [32, 32],
    spawnQuant: { '5': 10, '6': 10 },
    boss: false,
    aggression: 4,
    levelRange: [6, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  bloodBeak: {
    name: 'Blood Beak',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [160, 96],
    spawnQuant: { '7': 10, '8': 10 },
    boss: false,
    aggression: 4,
    levelRange: [7, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyDemon = {
  deviousImp: {
    name: 'Devious Imp',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [64, 128],
    spawnQuant: { '4': 10, '5': 10 },
    boss: false,
    aggression: 3,
    levelRange: [5, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  chupacabra: {
    name: 'Chupacabra',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [0, 256],
    spawnQuant: { '6': 10, '7': 10 },
    boss: false,
    aggression: 3,
    levelRange: [5, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  vileSuccubus: {
    name: 'Vile Succubus',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [0, 224],
    spawnQuant: { '7': 10, '8': 10 },
    boss: false,
    aggression: 4,
    levelRange: [7, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssHound: {
    name: 'Vile Succubus',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [160, 0],
    spawnQuant: { '8': 10, '9': 10 },
    boss: false,
    aggression: 4,
    levelRange: [8, 9],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  demonGuard: {
    name: 'Demon Guard',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [32, 32],
    spawnQuant: { '9': 10, '10': 10 },
    boss: false,
    aggression: 5,
    levelRange: [9, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssCambion: {
    name: 'Abyss Cambion',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 64],
    spawnQuant: { '10': 10 },
    boss: false,
    aggression: 5,
    levelRange: [10, 11],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  agares: {
    name: 'Agares',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [224, 32],
    spawnQuant: { '6': 1 },
    boss: true,
    aggression: 3,
    levelRange: [8, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  asmodius: {
    name: 'Asmodius',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [128, 32],
    spawnQuant: { '7': 1 },
    boss: true,
    aggression: 4,
    levelRange: [9, 9],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  belphagor: {
    name: 'Belphagor',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 0],
    spawnQuant: { '8': 1 },
    boss: true,
    aggression: 5,
    levelRange: [10, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  astaroth: {
    name: 'Astaroth',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 32],
    spawnQuant: { '9': 1 },
    boss: true,
    aggression: 5,
    levelRange: [12, 12],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  azazel: {
    name: 'Azazel',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [96, 32],
    spawnQuant: { '10': 1 },
    boss: true,
    aggression: 5,
    levelRange: [13, 13],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyElemental = {
  sandElemental: {
    name: 'Sand Elemental',
    type: 'elemental',
    palette: ['elemental0Palette', 'elemental1Palette'],
    iconLoc: [0, 32],
    spawnQuant: { '3': 10, '4': 10 },
    boss: false,
    aggression: 3,
    levelRange: [3, 4],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  fireElemental: {
    name: 'Fire Elemental',
    type: 'elemental',
    palette: ['elemental0Palette', 'elemental1Palette'],
    iconLoc: [64, 160],
    spawnQuant: { '5': 10, '6': 10 },
    boss: false,
    aggression: 4,
    levelRange: [5, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyHumanoid = {
  eliTheTraitor: {
    name: 'Eli the Traitor',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [160, 192],
    spawnQuant: { '1': 1 },
    boss: true,
    aggression: 3,
    levelRange: [2, 2],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  borisTheButcher: {
    name: 'Boris the Butcher',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [0, 0],
    spawnQuant: { '2': 1 },
    boss: true,
    aggression: 3,
    levelRange: [3, 3],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  phanxTheRaider: {
    name: 'Phanx the Raider',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [32, 64],
    spawnQuant: { '3': 1 },
    boss: true,
    aggression: 3,
    levelRange: [5, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  quorakTheCannibal: {
    name: 'Quorak the Cannibal',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [64, 128],
    spawnQuant: { '4': 1 },
    boss: true,
    aggression: 4,
    levelRange: [6, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  theDarkDisciple: {
    name: 'The Dark Disciple',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [128, 192],
    spawnQuant: { '5': 1 },
    boss: true,
    aggression: 4,
    levelRange: [7, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  travelingMerchant: {
    name: 'Traveling Merchant',
    type: 'merchant',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [32, 160],
    spawnQuant: { '1': 1 },
    boss: false,
    aggression: 0,
    levelRange: [5, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 0,
      bDefense: 150,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 0,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    },
    inventory: {
      'Potion': {
        name: 'Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 200,
        palette: 'potionPalette',
        iconLoc: [0, 0, 32, 32],
        buy: 20,
        sell: 10,
        stats: { curHealth: 50 },
        spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
      },
      'Hi Potion': {
        name: 'Hi Potion',
        type: 'consumable',
        count: 3,
        equipped: false,
        itemArrVal: 201,
        palette: 'potionPalette',
        iconLoc: [64, 0, 32, 32],
        buy: 50,
        sell: 25,
        stats: { curHealth: 150 },
        spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
      }
    }
  }
};
'use strict';

var enemyReptile = {
  bloodSnake: {
    name: 'Blood Snake',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 128],
    spawnQuant: { '1': 5, '2': 10 },
    boss: false,
    aggression: 3,
    levelRange: [2, 3],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  wingedViper: {
    name: 'Winged Viper',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 0],
    spawnQuant: { '2': 10, '3': 10 },
    boss: false,
    aggression: 3,
    levelRange: [2, 3],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssDragon: {
    name: 'Abyss Dragon',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 128],
    spawnQuant: { '10': 10 },
    boss: false,
    aggression: 4,
    levelRange: [10, 11],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyUndead = {
  necromancer: {
    name: 'Necromancer',
    type: 'undead',
    palette: ['undead0Palette', 'undead1Palette'],
    iconLoc: [0, 160],
    spawnQuant: { '9': 10 },
    boss: false,
    aggression: 4,
    levelRange: [8, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

/**
 * Amulets
 */

var itemAmulets = {
  //Mage Amulets
  mageAmu1: {
    name: "Damaged Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '3': 1 }
  },
  mageAmu2: {
    name: "Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 12, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  mageAmu3: {
    name: "Enchanted Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 16, iStrength: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Rogue Amulets
  rogueAmu1: {
    name: "Damaged Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueAmu2: {
    name: "Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '5': 1 }
  },
  rogueAmu3: {
    name: "Enchanted Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 8, iStrength: 1, iAgility: 4 },
    spawnQuant: { '7': 1 }
  },
  //Warrior Amulets
  warriorAmu1: {
    name: "Damaged Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorAmu2: {
    name: "Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [196, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iDurability: 1 },
    spawnQuant: { '5': 1 }
  },
  warriorAmu3: {
    name: "Enchanted Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iStrength: 4, iDurability: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Paladin Amulets
  paladinAmu1: {
    name: "Damaged Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinAmu2: {
    name: "Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 3, iDurabilty: 1 },
    spawnQuant: { '5': 1 }
  },
  paladinAmu3: {
    name: "EnchantedAmulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iVitality: 4, iStrength: 1, iDurabilty: 2 },
    spawnQuant: { '7': 1 }
  }
};
'use strict';

/**
 * Armor
 */

var itemArmors = {
  //Mage armor
  clothArm1: {
    name: "Moldy Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iVitality: 1, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothArm2: {
    name: "Adept Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  clothArm3: {
    name: "Shining Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iVitality: 3, iStrength: 2, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  clothArm4: {
    name: "Ancient Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 12, iVitality: 4, iStrength: 3, iDurability: 1 },
    spawnQuant: { '8': 1 }
  },
  clothArm5: {
    name: "Brilliant Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 16, iVitality: 6, iStrength: 3, iDurability: 1 },
    spawnQuant: { '10': 1 }
  },
  //Rogue armor
  leatherArm1: {
    name: "Cracked Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 256, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 1, iAgility: 1 },
    spawnQuant: { '2': 1 }
  },
  leatherArm2: {
    name: "Supple Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 256, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 8, iStrength: 1, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  leatherArm3: {
    name: "Reinforced Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 256, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 2, iAgility: 2 },
    spawnQuant: { '6': 1 }
  },
  leatherArm4: {
    name: "Rune Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 256, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 20, iStrength: 2, iAgility: 4 },
    spawnQuant: { '8': 1 }
  },
  leatherArm5: {
    name: "Dark Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 256, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 20, iStrength: 3, iAgility: 6 },
    spawnQuant: { '10': 1 }
  },
  //Warrior armor
  chainArm1: {
    name: "Rusted Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  chainArm2: {
    name: "Bronze Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 12, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  chainArm3: {
    name: "Reinforced Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [234, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 3, iAgility: 1 },
    spawnQuant: { '6': 1 }
  },
  chainArm4: {
    name: "Rune Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 24, iStrength: 4, iAgility: 1 },
    spawnQuant: { '8': 1 }
  },
  chainArm5: {
    name: "Brilliant Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 28, iStrength: 5, iDurability: 1, iAgility: 1 },
    spawnQuant: { '10': 1 }
  },
  //Paladin armor
  plateArm1: {
    name: "Rusted Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 12 },
    spawnQuant: { '2': 1 }
  },
  plateArm2: {
    name: "Bronze Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 192, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 16, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  plateArm3: {
    name: "Reinforced Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 192, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 24, iDurability: 2 },
    spawnQuant: { '6': 1 }
  },
  plateArm4: {
    name: "Rune Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 32, iVitality: 1, iDurability: 2 },
    spawnQuant: { '8': 1 }
  },
  plateArm5: {
    name: "Brilliant Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [224, 192, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 36, iVitality: 2, iDurability: 3 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

/**
 * Feet
 */

var itemFeet = {
  //Mage Feet
  mageFt1: {
    name: "Tattered Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 1, iStrength: 1, iAgility: 1 },
    spawnQuant: { '4': 1 }
  },
  mageFt2: {
    name: "Fine Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  //Rogue Feet
  rogueFt1: {
    name: "Tattered Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  rogueFt2: {
    name: "Fine Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior Feet
  warriorFt1: {
    name: "Rusted Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  warriorFt2: {
    name: "Fine Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin Feet
  paladinFt1: {
    name: "Rusted Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  paladinFt2: {
    name: "Fine Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 16, iVitality: 1, iDurability: 2 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

/**
 * Gloves
 */

var itemGloves = {
  mageGlv1: {
    name: "Cloth Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [32, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 2, iStrength: 1, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueGlv1: {
    name: "Leather Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorGlv1: {
    name: "Battle Mitts",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [64, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinGlv1: {
    name: "Plate Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [96, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iDurabilty: 2 },
    spawnQuant: { '3': 1 }
  }
};
'use strict';

/**
 * Helmets
 */

var itemHelmets = {
  //Mage Cloth
  clothHead1: {
    name: 'Snazzy Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 3, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothHead2: {
    name: 'Wizard Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 6, iStrength: 4 },
    spawnQuant: { '5': 1 }
  },
  clothHead3: {
    name: 'Enchanted Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 8, iVitality: 12, iStrength: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Rogue Leather
  leatherHead1: {
    name: 'Soft Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  leatherHead2: {
    name: 'Hardened Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iDurability: 1, iAgility: 6 },
    spawnQuant: { '5': 1 }
  },
  leatherHead3: {
    name: 'Rune Leather Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 16, iStrength: 4, iDurability: 2, iAgility: 10 },
    spawnQuant: { '8': 1 }
  },
  //Warrior Mail
  mailHead1: {
    name: 'Chainmail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 2, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  mailHead2: {
    name: 'Platemail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 5, iDurability: 2, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  mailHead3: {
    name: 'Platemail Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 24, iStrength: 8, iDurability: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Paladin Crown
  crownHead1: {
    name: "Desciple's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2 },
    spawnQuant: { '2': 1 }
  },
  crownHead2: {
    name: "Golden Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iVitality: 4, iDurability: 4, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  crownHead3: {
    name: "King's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 96, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 12, iVitality: 10, iDurability: 5, iStrength: 2 },
    spawnQuant: { '8': 1 }
  }
};
'use strict';

/**
 * Rings
 */

var itemRings = {
  //Mage rings
  mageRng1: {
    name: "Damaged Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAttack: 4 },
    spawnQuant: { '1': 1 }
  },
  mageRng2: {
    name: "Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  mageRng3: {
    name: "Enchanted Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iAttack: 12, iVitality: 1, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Rogue rings
  rogueRng1: {
    name: "Damaged Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  rogueRng2: {
    name: "Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iStrength: 1, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  rogueRng3: {
    name: "Enchanted Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 32, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iVitalitY: 1, iStrength: 1, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior rings
  warriorRng1: {
    name: "Damaged Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  warriorRng2: {
    name: "Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDurability: 1, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorRng3: {
    name: "Enchanted Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [96, 96, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDurability: 1, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin rings
  paladinRng1: {
    name: "Damaged Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iVitality: 1 },
    spawnQuant: { '1': 1 }
  },
  paladinRng2: {
    name: "Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 1, iDurability: 1, iStrength: 1 },
    spawnQuant: { '3': 1 }
  },
  paladinRng3: {
    name: "Enchanted Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2, iStrength: 1 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Shields
 */

var itemShields = _defineProperty({
  mageShd1: {
    name: "Arcane Shield",
    type: 'shield',
    palette: 'armorPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 4, iVitality: 2, iStrength: 1, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  rogueShd1: {
    name: "Hardened Buckler",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 8, iDurability: 1, iAgility: 3 },
    spawnQuant: { '6': 1 }
  },
  warriorShd1: {
    name: "Kite Shield of Wrath",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 12, iStrength: 3 },
    spawnQuant: { '6': 1 }
  }
}, 'warriorShd1', {
  name: "Kite Shield of Rightousness",
  type: 'shield',
  palette: 'shieldPalette',
  iconLoc: [192, 0, 32, 32],
  buy: 40,
  sell: 20,
  stats: { iDefense: 12, iVitality: 2, iDurability: 1 },
  spawnQuant: { '6': 1 }
});
'use strict';

/**
 * Weapons
 */

var itemWeapons = {
  //Wands
  wand1: {
    name: 'Bent Stick',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 160, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '1': 1 }
  },
  wand2: {
    name: 'Summoning Fork',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 20 },
    spawnQuant: { '2': 1 }
  },
  wand3: {
    name: 'Scavenged Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 28, iVitality: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  wand4: {
    name: 'Oak Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 52, iVitality: 1, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  wand5: {
    name: 'Rune Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 72, iVitality: 2, iStrength: 2 },
    spawnQuant: { '6': 1 }
  },
  wand6: {
    name: 'Blazing Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 88, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  wand7: {
    name: 'Divining Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 112, iVitality: 4, iStrength: 2, iAgility: 2 },
    spawnQuant: { '10': 1 }
  },
  //Short Weapons
  knife1: {
    name: 'Arrow Head',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  knife2: {
    name: 'Bone Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  knife3: {
    name: 'Fishing Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iAgility: 4 },
    spawnQuant: { '4': 1 }
  },
  knife4: {
    name: 'Jagged Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 1, iAgility: 5 },
    spawnQuant: { '5': 1 }
  },
  knife5: {
    name: 'Rune Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 48, iStrength: 2, iAgility: 6 },
    spawnQuant: { '7': 1 }
  },
  knife6: {
    name: 'Coral Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 68, iStrength: 2, iAgility: 7 },
    spawnQuant: { '9': 1 }
  },
  knife7: {
    name: 'Divining Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 92, iStrength: 3, iAgility: 9 },
    spawnQuant: { '10': 1 }
  },
  //Swords
  sword1: {
    name: 'Rough Club',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  sword2: {
    name: 'Practice Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iStrength: 2 },
    spawnQuant: { '2': 1 }
  },
  sword3: {
    name: 'Short Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iStrength: 4 },
    spawnQuant: { '4': 1 }
  },
  sword4: {
    name: 'Bronze Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 5, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  sword5: {
    name: 'Rune Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 44, iStrength: 7, iAgility: 2 },
    spawnQuant: { '7': 1 }
  },
  sword6: {
    name: 'Coral Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 60, iStrength: 9, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  sword7: {
    name: 'Dark Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 80, iStrength: 11, iAgility: 3 },
    spawnQuant: { '10': 1 }
  },
  // Polearms
  pole1: {
    name: 'Long Pole',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iDurability: 1 },
    spawnQuant: { '1': 1 }
  },
  pole2: {
    name: 'Big Spade',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iVitality: 1, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  pole3: {
    name: 'Trident',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 16, iVitality: 2, iDurability: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  pole4: {
    name: 'Narrow Spear',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 24, iVitality: 3, iDurability: 2, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  pole5: {
    name: 'Rune Voulge',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 64, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 36, iVitality: 4, iDurability: 2, iStrength: 4 },
    spawnQuant: { '7': 1 }
  },
  pole6: {
    name: 'Coral Bardiche',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 48, iVitality: 4, iDurability: 4, iStrength: 5 },
    spawnQuant: { '9': 1 }
  },
  pole7: {
    name: 'Royal Poleaxe',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 72, iVitality: 5, iDurability: 5, iStrength: 5 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

/**
 * Global Settings
 */

var statConvertWordMap = {
  curHealth: 'HP',
  iAttack: 'Atk',
  iDefense: 'Def',
  iVitality: 'Vit',
  iDurability: 'Dur',
  iStrength: 'Str',
  iAgility: 'Agi'
};

var equipAbbrevMap = {
  Head: 'HED',
  Amulet: 'AMU',
  Weapon: 'WEP',
  Armor: 'AMR',
  Shield: 'SLD',
  Glove: 'GLV',
  Ring: 'RNG',
  Foot: 'FT',
  Consumable: 'CNS'
};

var consumableAbbrevMap = {
  potion: { name: 'Potion', key: 'potion', abbrev: 'LPOT', num: 1 },
  hiPotion: { name: 'Hi Potion', key: 'hiPotion', abbrev: 'HPOT', num: 2 },
  xPotion: { name: 'X Potion', key: 'xPotion', abbrev: 'XPOT', num: 3 },
  tomeOfVitality: { name: 'Tome of Vitality', key: 'tomeOfVitality', abbrev: 'VTOM', num: 4 },
  tomeOfDurability: { name: 'Tome of Durability', key: 'tomeOfDurability', abbrev: 'DTOM', num: 5 },
  tomeOfStrength: { name: 'Tome of Strength', key: 'tomeOfStrength', abbrev: 'STOM', num: 6 },
  tomeOfAgility: { name: 'Tome of Agility', key: 'tomeOfAgility', abbrev: 'ATOM', num: 7 },
  tomeOfWisdom: { name: 'Tome of Wisdom', key: 'tomeOfWisdom', abbrev: 'WTOM', num: 8 }
};

//Global state
var timeRef = null;
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
  * Helper Functions
  */

var randInt = function randomIntFromRange(min, max) {
  return ~~(min + Math.random() * (max - min + 1));
};

var devError = function createDevError() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Default Error';

  this.name = 'DevError';
  this.message = message;
  this.stack = new Error().stack;
};

var initZeroArray = function initZeroFilledArray(len) {
  var arr = [],
      i = 0,
      j = 0;

  arr.length = len;
  while (i < len) {
    arr[i] = [];
    arr[i].length = len;
    while (j < len) {
      arr[i][j] = 0, j++;
    }j = 0, i++;
  }
  return arr;
};

//get element by id
var getById = function getElById(id) {
  return document.getElementById(id);
};

//adds one or more classes seperated, by commas, by element id
var addClasses = function addClassesByElId(id) {
  if (getById(id)) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        _addClasses = [].concat(args) || [];

    _addClasses.forEach(function (el) {
      if (!classArr.includes(el)) classArr.push(el);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt add class: ' + id + '. Couldnt find node.');
  }
};

//removes one or more classes seperated, by commas, by element id
var removeClasses = function removeClassesByElId(id) {
  if (getById(id)) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        remClasses = [].concat(args) || [];

    remClasses.forEach(function (el) {
      if (classArr.includes(el)) classArr.splice(classArr.indexOf(el), 1);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt remove class: ' + id + '. Couldnt find node.');
  }
};

var initMemCanvas = function initCanvasToPointer(w, h, smoothing) {
  var tempCanv = document.createElement('canvas'),
      ctx = tempCanv.getContext('2d');

  tempCanv.width = w;
  tempCanv.height = h;
  ctx.imageSmoothingEnabled = smoothing;

  return tempCanv;
};

var linearDistance = function calcLinearDistance(a, b) {
  return Math.sqrt(Math.pow(a[1] - b[1], 2) + Math.pow(a[0] - b[0], 2));
};

var calcRenderPadding = function calcCanvasRenderPadding(playerArr, aLen, rLen) {
  var sr = 0,
      pr = 0,
      sc = 0,
      pc = 0;

  if (playerArr[0] - ~~(rLen / 2) < 0) {
    sr = 0;
    pr = -1 * (playerArr[0] - ~~(rLen / 2));
  } else if (playerArr[0] + ~~(rLen / 2) + 1 > aLen) {
    pr = playerArr[0] + ~~(rLen / 2) + 1 - aLen;
    sr = aLen - rLen + pr;
  } else {
    sr = playerArr[0] - ~~(rLen / 2);
    pr = 0;
  }
  if (playerArr[1] - ~~(rLen / 2) < 0) {
    sc = 0;
    pc = -1 * (playerArr[1] - ~~(rLen / 2));
  } else if (playerArr[1] + ~~(rLen / 2) + 1 > aLen) {
    pc = playerArr[1] + ~~(rLen / 2) + 1 - aLen;
    sc = aLen - rLen + pc;
  } else {
    sc = playerArr[1] - ~~(rLen / 2);
    pc = 0;
  }

  return { sr: sr, sc: sc, pr: pr, pc: pc };
};

var setRenderArr = function setCanvasRenderArr(arr, rLen, padding) {
  var renderArr = [],
      sr = padding.sr,
      sc = padding.sc,
      i = 0,
      j = 0,
      m = 0,
      n = 0;

  m = rLen - padding.pr;
  n = rLen - padding.pc;
  renderArr.length = m;

  for (; i < m; i++) {
    renderArr[i] = [];
    renderArr[i].length;

    for (j = 0, n; j < n; j++) {
      renderArr[i][j] = arr[sr + i][sc + j];
    }
  }

  return renderArr;
};

var backgroundArray = function createBackgroundArray(arrSize) {
  var air = 10,
      flr = 40;

  //Random rectangle
  var newRoomOne = function createNewRoomOne(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        xFloorMax = xMax - 4,
        yFloorMin = yMin - 4,
        yFloorMax = yMax - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [];

    var i = 0,
        j = 0;

    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];
      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out on each tile from min rectangle size
  var newRoomTwo = function createNewRoomTwo(rows, cols) {
    //Subtract two to leave room for permimeter walls
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        yFloorMin = yMin - 4;

    var xPadL = randInt(2, xMax - xFloorMin - 2),
        xPadR = xMax - xFloorMin - xPadL,
        yPadT = randInt(2, yMax - yFloorMin - 2),
        yPadB = yMax - yFloorMin - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor area
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = xFloorMin;else if (i === 1) ext = xPadR - 2, s = yFloorMin;else if (i === 2) ext = yPadB - 2, s = xFloorMin;else ext = xPadL - 2, s = yFloorMin;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor area flr val in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + xFloorMin && i + 1 > yPadT && i < yPadT + yFloorMin) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + xFloorMin + i] = flr;
      }
    });
    floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + yFloorMin + i][xPadL + index] = flr;
      }
    });
    floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0]));
    xPadR = xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1]));
    yPadB = yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2]));
    xPadL = xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3]));

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out from random sides of rectangle
  var newRoomThree = function createNewRoomThree(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMax = xMax - 4,
        xFloorMin = xMin - 4,
        yFloorMax = yMax - 4,
        yFloorMin = yMin - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        sidesToExtend = [randInt(0, 1), randInt(0, 1), randInt(0, 1), randInt(0, 1)];

    var xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor size
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = w;else if (i === 1) ext = xPadR - 2, s = h;else if (i === 2) ext = yPadB - 2, s = w;else ext = xPadL - 2, s = h;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor size to 1's in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    sidesToExtend[0] && floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    sidesToExtend[1] && floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + w + i] = flr;
      }
    });
    sidesToExtend[2] && floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + h + i][xPadL + index] = flr;
      }
    });
    sidesToExtend[3] && floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = sidesToExtend[0] ? yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0])) : yPadT;
    xPadR = sidesToExtend[1] ? xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1])) : xPadR;
    yPadB = sidesToExtend[2] ? yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2])) : yPadB;
    xPadL = sidesToExtend[3] ? xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3])) : xPadL;

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  var createRooms = function createNewRooms() {
    var rows = 0,
        colsArr = [],
        cols = 0,
        xPadL = 0,
        xPadR = 0,
        yPadT = 0,
        yPadB = 0,
        xMax = 0,
        yMax = 0,
        roomType = 0,
        rooms = [],
        rmsRow = [],
        roomFloorArr = [],
        i = 0,
        j = 0;

    rows = randInt(3, 4) * 2;
    colsArr.length = rows;
    for (; i < rows; i++) {
      colsArr[i] = randInt(2, 4) * 2;
    }

    rooms = colsArr.map(function (el, index) {
      rmsRow = [];

      for (j = 0; j < el; j++) {
        roomType = randInt(1, 10);
        cols = el;

        if (roomType === 1) {
          var _newRoomOne = newRoomOne(rows, cols);

          xPadL = _newRoomOne.xPadL;
          xPadR = _newRoomOne.xPadR;
          yPadT = _newRoomOne.yPadT;
          yPadB = _newRoomOne.yPadB;
          xMax = _newRoomOne.xMax;
          yMax = _newRoomOne.yMax;
          roomFloorArr = _newRoomOne.roomFloorArr;
        } else if (roomType > 1 && roomType < 8) {
          var _newRoomTwo = newRoomTwo(rows, cols);

          xPadL = _newRoomTwo.xPadL;
          xPadR = _newRoomTwo.xPadR;
          yPadT = _newRoomTwo.yPadT;
          yPadB = _newRoomTwo.yPadB;
          xMax = _newRoomTwo.xMax;
          yMax = _newRoomTwo.yMax;
          roomFloorArr = _newRoomTwo.roomFloorArr;
        } else {
          var _newRoomThree = newRoomThree(rows, cols);

          xPadL = _newRoomThree.xPadL;
          xPadR = _newRoomThree.xPadR;
          yPadT = _newRoomThree.yPadT;
          yPadB = _newRoomThree.yPadB;
          xMax = _newRoomThree.xMax;
          yMax = _newRoomThree.yMax;
          roomFloorArr = _newRoomThree.roomFloorArr;
        }

        rmsRow[j] = {
          rows: rows,
          cols: cols,
          xPadL: xPadL,
          xPadR: xPadR,
          yPadT: yPadT,
          yPadB: yPadB,
          xMax: xMax,
          yMax: yMax,
          roomFloorArr: roomFloorArr,
          cnxns: [0, 0, 0, 0],
          curRow: index
        };
      }

      return rmsRow;
    });
    return rooms;
  };

  var stitchRooms = function stitchRoomArray(rooms) {
    var stitchArr = [],
        len = arrSize;

    var c = 0,
        i = 0,
        j = 0,
        k = 0,
        r = 0;

    stitchArr.length = len;
    while (r < len) {
      while (c < len) {
        stitchArr[r] = c === 0 ? rooms[k][i].roomFloorArr[j] : [].concat(_toConsumableArray(stitchArr[r]), _toConsumableArray(rooms[k][i].roomFloorArr[j]));
        c += rooms[k][i].xMax;
        i++;
      }
      if (j === rooms[k][i - 1].yMax - 1) j = 0, k++;else j++;
      c = 0, i = 0;
      r++;
    }
    return stitchArr;
  };

  var choosePaths = function newPaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow) {
    var len = stitchArr.length,
        xMax = rm.xMax,
        yMax = rm.yMax;

    var pathOpts = [],
        paths = [],
        goUp = false,
        goRt = false,
        goDn = false,
        goLt = false,
        chk = false,
        val = 0,
        i = 0,
        j = 0,
        k = 0;

    if (tieRule === 1 || tieRule === 2 && rm.cnxns[3] || tieRule === 4 && rm.cnxns[0]) {
      val = randInt(1, 3);
      goRt = val === 1 || val === 3 ? true : false;
      goDn = val === 2 || val === 3 ? true : false;
    } else if (tieRule === 2) {
      goRt = randInt(0, 1) ? true : false;
      goDn = true;
    } else if (tieRule === 3) {
      goDn = !rm.cnxns[3] || !tiedRow || randInt(0, 1) ? true : false;
    } else if (tieRule === 4) {
      goRt = true;
      goDn = randInt(0, 1) ? true : false;
    } else if (tieRule === 5) {
      goRt = !rm.cnxns[0] || !rooms[rm.curRow - 1][~~(chkCol / rooms[rm.curRow - 1][0].xMax)].cnxns[1] || randInt(0, 1) ? true : false;
    } else {
      goUp = !rm.cnxns[0] ? true : false;
      goLt = !rm.cnxns[3] ? true : false;
    }
    tiedRow = goDn ? true : tiedRow;

    if (goUp) {
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow - j < 2 || stitchArr[chkRow - j][k] === flr || stitchArr[chkRow - j - 1][k] === flr || stitchArr[chkRow - j][k + 1] === flr || stitchArr[chkRow - j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow - j > 1) pathOpts.push([1, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        goRt = true;
        try {
          throw new devError('No pathOpts up. Set right. -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goDn) {
      pathOpts.length = 0;
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow + j > len - 3 || stitchArr[chkRow + j][k] === flr || stitchArr[chkRow + j][k + 1] === flr || stitchArr[chkRow + j + 1][k] === flr || stitchArr[chkRow + j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow + j < len - 3) pathOpts.push([3, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        goRt = true;
        try {
          throw new devError('No pathOpts down. Set right. -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goRt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(xMax / 2) && (j > 2 * xMax || chkCol + j > len - 3 || stitchArr[k][chkCol + j] === flr || stitchArr[k - 1][chkCol + j] === flr || stitchArr[k][chkCol + j + 1] === flr || stitchArr[k + 1][chkCol + j] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol + j < len - 3) pathOpts.push([2, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        try {
          throw new devError('no pathOpts right -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goLt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * xMax || chkCol - j < 2 || stitchArr[k][chkCol - j] === flr || stitchArr[k - 1][chkCol - j] === flr || stitchArr[k + 1][chkCol - j] === flr || stitchArr[k][chkCol - j - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol - j > 1) pathOpts.push([4, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        try {
          throw new devError('no pathOpts left -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }

    if (paths.length === 1) paths.push([0, 0, 0, 0]);else if (paths.length > 2) {
      try {
        throw new devError('paths.length > 2 -> BackgroundLayer.choosePaths');
      } catch (e) {
        console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
      }
    }

    return { paths: paths, tiedRow: tiedRow };
  };

  var applyPaths = function applyNewPaths(rm, rooms, stitchArr, paths) {
    var i = 0;

    paths.forEach(function (el) {
      if (el[0] === 1) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] - i][el[1]] = flr;
        }
        rm.cnxns[0] = 1;
        rooms[rm.curRow - 1][~~(el[1] / rooms[rm.curRow - 1][0].xMax)].cnxns[2] = 1;
      } else if (el[0] === 2) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] + i] = flr;
        }
        rm.cnxns[1] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) + 1].cnxns[3] = 1;
      } else if (el[0] === 3) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] + i][el[1]] = flr;
        }
        rm.cnxns[2] = 1;
        rooms[rm.curRow + 1][~~(el[1] / rooms[rm.curRow + 1][0].xMax)].cnxns[0] = 1;
      } else if (el[0] === 4) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] - i] = flr;
        }
        rm.cnxns[3] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) - 1].cnxns[1] = 1;
      }
    });

    return true;
  };

  var createPaths = function createNewPaths(rooms, stitchArr) {
    var len = stitchArr.length;

    var tiedRow = false,
        paths = [],
        rm = void 0,
        //{} pointer
    chkRow = 0,
        chkCol = 0,
        tieRule = 0,
        r = 0,
        c = 0,
        i = 0,
        j = 0;

    paths.length = ~~(len / 4);

    while (r < len) {
      while (c < len) {
        rm = rooms[j][i];
        chkRow = r + ~~(rm.yMax / 2);
        chkCol = c + ~~(rm.xMax / 2);
        tieRule = j === 0 && i === 0 ? 1 : j === 0 && i < rooms[j].length - 1 ? 2 : j < rooms.length - 1 && i === rooms[j].length - 1 ? 3 : j < rooms.length - 1 && i < rooms[j].length - 1 ? 4 : j === rooms.length - 1 && i < rooms[j].length - 1 ? 5 : 6;

        var _choosePaths = choosePaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow);

        paths = _choosePaths.paths;
        tiedRow = _choosePaths.tiedRow;

        applyPaths(rm, rooms, stitchArr, paths);

        c += rm.xMax;
        i++;
      }
      r += rooms[j][i - 1].yMax;
      j++;
      tiedRow = false;
      c = 0;
      i = 0;
    }

    return stitchArr;
  };

  var randomizeOrientation = function randomizeArrOrientation(connectedArr) {
    var len = connectedArr.length,
        orientation = randInt(1, 4);

    var orientedArr = [],
        i = 0,
        j = 0;

    var transposed = function transposeSquareArr(arr) {
      var tArr = [],
          len = arr.length;

      while (i < len) {
        tArr[i] = [];
        j = 0;

        while (j < len) {
          tArr[i][j] = arr[j][i], j++;
        }i++;
      }
      return tArr;
    };

    if (orientation === 1) {
      orientedArr = [].concat(_toConsumableArray(connectedArr));
    }
    if (orientation === 2) {
      //Rotate +90 deg
      orientedArr = transposed(connectedArr);
      orientedArr.forEach(function (el) {
        return el.reverse();
      });
    } else if (orientation === 3) {
      //Rotate 180 deg
      while (i < len) {
        orientedArr[i] = connectedArr[len - 1 - i].reverse();
        i++;
      }
    } else if (orientation === 4) {
      //Rotate -90 deg
      connectedArr.forEach(function (el) {
        return el.reverse();
      });
      orientedArr = transposed(connectedArr);
    }
    return { orientation: orientation, orientedArr: orientedArr };
  };

  var addWalls = function addArrWalls(orientedArr) {
    var walledArr = orientedArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = walledArr.length - 1;

    var i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (orientedArr[i][j] === air) {
          nArr[0] = walledArr[i - 1][j - 1];
          nArr[1] = walledArr[i - 1][j];
          nArr[2] = walledArr[i - 1][j + 1];
          nArr[3] = walledArr[i][j - 1];
          nArr[4] = walledArr[i][j + 1];
          nArr[5] = walledArr[i + 1][j - 1];
          nArr[6] = walledArr[i + 1][j];
          nArr[7] = walledArr[i + 1][j + 1];

          if (nArr.indexOf(flr) > -1) {
            if (nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && (nArr[1] === air || nArr[1] === flr) && (nArr[5] === flr && nArr[7] === flr || nArr[1] === flr && (nArr[5] === flr || nArr[7] === flr))) {
              el = 31;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && nArr[6] === air && (nArr[2] === flr && nArr[7] === flr || nArr[3] === flr && (nArr[2] === flr || nArr[7] === flr))) {
              el = 32;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && nArr[2] === flr && nArr[7] === flr) {
              el = 33;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[0] === flr && nArr[5] === flr || (nArr[0] === flr || nArr[5] === flr) && nArr[4] === flr)) {
              el = 34;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && (nArr[0] === flr && nArr[2] === flr || (nArr[0] === flr || nArr[2] === flr) && nArr[6] === flr)) {
              el = 35;
            } else if (nArr[4] === air && nArr[6] === air && (nArr[1] === flr && nArr[3] === flr || nArr[7] === flr)) {
              el = 21;
            } else if (nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[1] === flr && nArr[4] === flr || nArr[5] === flr)) {
              el = 23;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && (nArr[3] === flr && nArr[6] === flr || nArr[2] === flr)) {
              el = 25;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && (nArr[0] === flr || nArr[4] === flr && nArr[6] === flr)) {
              el = 27;
            } else if (nArr[3] > air && nArr[3] < flr && (nArr[1] === flr || nArr[6] === flr) || nArr[4] === air && (nArr[1] === flr && nArr[2] === flr || nArr[5] === flr && nArr[6] === flr)) {
              el = 22;
            } else if (nArr[1] > air && nArr[1] < flr || nArr[6] === air && (nArr[3] === flr || nArr[4] === flr)) {
              el = 24;
            } else if (nArr[1] === flr || nArr[3] === flr || nArr[4] === flr || nArr[6] === flr) {
              el = 26;
            }

            if (el) walledArr[i][j] = el;
          }
        }
        j++;
      }
      i++;
    }

    return walledArr;
  };

  var addFloors = function addArrFloors(walledArr) {
    var bgArr = walledArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = bgArr.length - 1,
        sFlr = flr - 1;

    var floorCoords = [],
        i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (walledArr[i][j] > sFlr) {
          nArr[0] = bgArr[i - 1][j - 1];
          nArr[1] = bgArr[i - 1][j];
          nArr[2] = bgArr[i - 1][j + 1];
          nArr[3] = bgArr[i][j - 1];
          nArr[4] = bgArr[i][j + 1];
          nArr[5] = bgArr[i + 1][j - 1];
          nArr[6] = bgArr[i + 1][j];
          nArr[7] = bgArr[i + 1][j + 1];
          floorCoords.push([i, j]);

          if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 41;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 42;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 43;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 44;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 45;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 46;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 47;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 48;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 49;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 51;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 52;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 53;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 54;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 55;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 56;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 57;
          }

          if (el) bgArr[i][j] = el;
        }
        j++;
      }
      i++;
    }
    return { bgArr: bgArr, floorCoords: floorCoords };
  };

  var rooms = createRooms();
  var stitchArr = stitchRooms(rooms);
  var connectedArr = createPaths(rooms, stitchArr);

  var _randomizeOrientation = randomizeOrientation(connectedArr),
      orientation = _randomizeOrientation.orientation,
      orientedArr = _randomizeOrientation.orientedArr;

  var walledArr = addWalls(orientedArr);

  var _addFloors = addFloors(walledArr),
      bgArr = _addFloors.bgArr,
      floorCoords = _addFloors.floorCoords;

  return { bgArr: bgArr, floorCoords: floorCoords };
};
'use strict';

var heroTypeStats = {
  Mage: {
    heroName: 'Forsyth',
    health: 53,
    attack: 12,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 12,
    durability: 10,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 0,
      attack: 5,
      defense: 0,
      vitality: 1,
      durability: 0,
      strength: 2,
      agility: 1
    }
  },
  Paladin: {
    heroName: 'Roland',
    health: 53,
    attack: 10,
    defense: 12,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 11,
    durability: 11,
    strength: 11,
    agility: 11,
    onLevelUp: {
      health: 6,
      attack: 1,
      defense: 2,
      vitality: 1,
      durability: 2,
      strength: 1,
      agility: 0
    }
  },
  Rogue: {
    heroName: 'Hanzo',
    health: 50,
    attack: 13,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 10,
    strength: 12,
    agility: 12,
    onLevelUp: {
      health: 6,
      attack: 3,
      defense: 0,
      vitality: 0,
      durability: 0,
      strength: 2,
      agility: 2
    }
  },
  Warrior: {
    heroName: 'Agis',
    health: 50,
    attack: 12,
    defense: 11,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 12,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 6,
      attack: 2,
      defense: 1,
      vitality: 0,
      durability: 1,
      strength: 2,
      agility: 1
    }
  }
};

var statConversion = {
  vitToHp: 9,
  durToHp: 3,
  durToDef: 2,
  durToDodge: 0.1,
  strToAtk: 2,
  strToDef: 1,
  strToHit: 0.25,
  agiToHit: 1,
  agiToDodge: 0.5,
  agiToCrit: 0.5,
  atkToHpRange: [3, 5],
  defToHpRange: [1, 3],
  lvlToExpRange: [50, 80], //default [9,11]
  lvlToGoldRange: [2, 3],
  expLevelMult: 1.75,
  lvlUpSkillPoints: 2,
  bossMultiplier: 2.5
};
'use strict';

var interactivePortals = {
  inactivePortal: {
    name: 'Inactive Portal',
    type: 'door',
    palette: ['door0Palette', 'door1Palette'],
    iconLoc: [64, 160, 32, 32]
  },
  activePortal: {
    name: 'Active Portal',
    type: 'door',
    palette: ['door0Palette', 'door1Palette'],
    iconLoc: [96, 160, 32, 32]
  }
};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//stageSize, boardSize, tileSize, gameLevel, playerArr, bgArr, accArr, updateAccArr, enemyDead, bgLevelProcessed
var AccentLayer = function (_React$Component) {
  _inherits(AccentLayer, _React$Component);

  function AccentLayer(props) {
    _classCallCheck(this, AccentLayer);

    var _this = _possibleConstructorReturn(this, (AccentLayer.__proto__ || Object.getPrototypeOf(AccentLayer)).call(this, props));

    _this.initAccArr = _this.initAccArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getAccImages = _this.getAccImages.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setAccArr = _this.setAccArr.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.drawAccents = _this.drawAccents.bind(_this);

    _this.enemyDeadCount = 0;

    _this.state = {
      srcTileSize: 16,
      wallAcc: 20,
      flrAcc: 40,
      decor0: null,
      decor1: null,
      ground0: null,
      ground1: null,
      ore0: null,
      ore1: null,
      dec0Canv: null,
      dec1Canv: null,
      grnd0Canv: null,
      grnd1Canv: null,
      ore0Canv: null,
      ore1Canv: null,
      decorMap: {},
      groundMap: {},
      oreMap: {},
      corpseMap: '',
      paletteArrMap: {},
      tempCanv: null
    };
    return _this;
  }

  _createClass(AccentLayer, [{
    key: 'initAccArr',
    value: function initAccArr() {
      var len = this.props.boardSize,
          accArr = initZeroArray(len);

      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'getAccImages',
    value: function getAccImages() {
      var decor0 = new Image(),
          decor1 = new Image(),
          ground0 = new Image(),
          ground1 = new Image(),
          ore0 = new Image(),
          ore1 = new Image(),
          that = this;

      var i = 0;

      var handleAccLoad = function handleAccImageLoad() {
        i++;
        if (i === 6) {
          that.setState({ decor0: decor0, decor1: decor1, ground0: ground0, ground1: ground1, ore0: ore0, ore1: ore1 });

          //Delete after start screen created
          that.setPalettes(decor0, decor1, ground0, ground1, ore0, ore1, 1);
        }
      };

      decor0.src = 'img/accents/Decor0.png';
      decor1.src = 'img/accents/Decor1.png';
      ground0.src = 'img/accents/Ground0.png';
      ground1.src = 'img/accents/Ground1.png';
      ore0.src = 'img/accents/Ore0.png';
      ore1.src = 'img/accents/Ore1.png';

      decor0.addEventListener('load', handleAccLoad);
      decor1.addEventListener('load', handleAccLoad);
      ground0.addEventListener('load', handleAccLoad);
      ground1.addEventListener('load', handleAccLoad);
      ore0.addEventListener('load', handleAccLoad);
      ore1.addEventListener('load', handleAccLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var size = this.props.stageSize,
          smoothRender = false,
          tempCanv = initMemCanvas(size, size, smoothRender);

      this.setState({ tempCanv: tempCanv });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var decorMap = {},
          groundMap = {},
          oreMap = {},
          corpseMap = '',
          w = 0,
          h = 0,
          i = 0,
          j = 0;

      //init decorMap
      w = 8;
      h = 19;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          decorMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init groundMap
      w = 8;
      h = 7;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          groundMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init oreMap
      w = 3;
      h = 2;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          oreMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init corpseMap
      corpseMap = '51';

      this.setPaletteArrMap(this.props.gameLevel, decorMap, groundMap, oreMap);
      this.setState({ decorMap: decorMap, groundMap: groundMap, oreMap: oreMap, corpseMap: corpseMap });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(decor0, decor1, ground0, ground1, ore0, ore1, gameLevel) {
      var lvl = gameLevel,
          gmTS = this.props.tileSize,
          srcTS = this.state.srcTileSize,
          scale = gmTS / srcTS,
          dH = 19 * gmTS,
          dW = 8 * gmTS,
          gH = 7 * gmTS,
          gW = 8 * gmTS,
          oH = 2 * gmTS,
          oW = 3 * gmTS;

      var dec0Canv = document.createElement('canvas'),
          dec0Ctx = dec0Canv.getContext('2d'),
          dec1Canv = document.createElement('canvas'),
          dec1Ctx = dec1Canv.getContext('2d'),
          grnd0Canv = document.createElement('canvas'),
          grnd0Ctx = grnd0Canv.getContext('2d'),
          grnd1Canv = document.createElement('canvas'),
          grnd1Ctx = grnd1Canv.getContext('2d'),
          ore0Canv = document.createElement('canvas'),
          ore0Ctx = ore0Canv.getContext('2d'),
          ore1Canv = document.createElement('canvas'),
          ore1Ctx = ore1Canv.getContext('2d'),
          srcX = 0,
          srcY = 0;

      //set decor
      srcY = 2 * srcTS;
      dec0Canv.width = dW;
      dec0Canv.height = dH;
      dec1Canv.width = dW;
      dec1Canv.height = dH;
      dec0Ctx.imageSmoothingEnabled = false;
      dec1Ctx.imageSmoothingEnabled = false;
      dec0Ctx.drawImage(decor0, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);
      dec1Ctx.drawImage(decor1, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);

      //set ground
      srcY = 0;
      grnd0Canv.width = gW;
      grnd0Canv.height = gH;
      grnd1Canv.width = gW;
      grnd1Canv.height = gH;
      grnd0Ctx.imageSmoothingEnabled = false;
      grnd1Ctx.imageSmoothingEnabled = false;
      grnd0Ctx.drawImage(ground0, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);
      grnd1Ctx.drawImage(ground1, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);

      //set ore
      srcX = lvl === 10 ? 5 * srcTS : 0;
      srcY = lvl === 1 ? 5 * srcTS : lvl === 2 ? 3 * srcTS : lvl === 3 ? 2 * srcTS : srcTS;
      ore0Canv.width = oW;
      ore0Canv.height = oH;
      ore1Canv.width = oW;
      ore1Canv.height = oH;
      ore0Ctx.imageSmoothingEnabled = false;
      ore1Ctx.imageSmoothingEnabled = false;
      ore0Ctx.drawImage(ore0, srcX, srcY, oW / scale, oH / scale, 0, 0, oW, oH);
      ore1Ctx.drawImage(ore1, srcX, srcY, oW / scale, oH / scale, 0, 0, oW, oH);

      this.setState({ dec0Canv: dec0Canv, dec1Canv: dec1Canv, grnd0Canv: grnd0Canv, grnd1Canv: grnd1Canv, ore0Canv: ore0Canv, ore1Canv: ore1Canv });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap(lvl, decorMap, groundMap, oreMap) {
      decorMap = decorMap || this.state.decorMap;
      groundMap = groundMap || this.state.groundMap;
      oreMap = oreMap || this.state.oreMap;

      var paletteArrMap = {};

      if (lvl && lvl < 5) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['4'], 'decor'],
          '22': [oreMap['0'], 'ore'],
          '23': [oreMap['3'], 'ore'],
          //rWall
          '24': [decorMap['7'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [oreMap['2'], 'ore'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['5'], 'decor'],
          '42': [decorMap['14'], 'decor'],
          '43': [decorMap['15'], 'decor'],
          '44': [groundMap['0'], 'ground'],
          '45': [decorMap['80'], 'decor'],
          '46': [decorMap['81'], 'decor'],
          '47': [decorMap['88'], 'decor'],
          '48': [decorMap['89'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl < 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['48'], 'decor'],
          '23': [decorMap['49'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [decorMap['2'], 'decor'],
          '26': [decorMap['7'], 'decor'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [decorMap['3'], 'decor'],
          '29': [decorMap['3'], 'decor'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['72'], 'decor'],
          '43': [decorMap['74'], 'decor'],
          '44': [decorMap['76'], 'decor'],
          '45': [decorMap['82'], 'decor'],
          '46': [decorMap['83'], 'decor'],
          '47': [decorMap['90'], 'decor'],
          '48': [decorMap['91'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl === 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['53'], 'decor'],
          '23': [decorMap['55'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['70'], 'decor'],
          '43': [decorMap['71'], 'decor'],
          '44': [decorMap['72'], 'decor'],
          '45': [decorMap['84'], 'decor'],
          '46': [decorMap['85'], 'decor'],
          '47': [decorMap['92'], 'decor'],
          '48': [decorMap['93'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      }
      this.setState({ paletteArrMap: paletteArrMap });
    }
  }, {
    key: 'setAccArr',
    value: function setAccArr(nextProps) {
      var bgArr = nextProps.bgArr,
          flr = this.state.flrAcc,
          wall = this.state.wallAcc,
          len = bgArr.length;

      var accArr = [].concat(_toConsumableArray(nextProps.accArr)),
          nArr = [0, 0, 0, 0, 0, 0, 0, 0],
          el = 0,
          n = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          n = bgArr[i][j];
          el = 0;

          if (n > wall) {
            nArr[0] = bgArr[i - 1][j - 1];
            nArr[1] = bgArr[i - 1][j];
            nArr[2] = bgArr[i - 1][j + 1];
            nArr[3] = bgArr[i][j - 1];
            nArr[4] = bgArr[i][j + 1];
            nArr[5] = bgArr[i + 1][j - 1];
            nArr[6] = bgArr[i + 1][j];
            nArr[7] = bgArr[i + 1][j + 1];

            if ([22, 25, 27, 35].includes(n) && nArr[6] > flr) {
              //tWall accents
              if (randInt(1, 12) === 5) el = randInt(21, 23);
            }
            if ([21, 24, 25, 32].includes(n) && nArr[3] > flr) {
              //rWall accents
              if (randInt(1, 15) === 5) el = randInt(24, 26);
            }
            if ([23, 24, 27, 34].includes(n) && nArr[4] > flr) {
              //lWall accents
              if (randInt(1, 15) === 5) el = randInt(27, 29);
            }
            if (n > flr) {
              //ground accents
              if (randInt(1, 50) === 7) el = randInt(41, 49);
            }
          }
          accArr[i][j] = el;
          j++;
        }
        j = 0;
        i++;
      }
      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead,
          corpseMap = this.state.corpseMap,
          coord = enemyDead.coord;


      var accArr = [].concat(_toConsumableArray(nextProps.accArr));

      accArr[coord[0]][coord[1]] = corpseMap;
      this.enemyDeadCount = enemyDead.count;

      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'drawAccents',
    value: function drawAccents(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var accArr = this.props.accArr,
          map = this.state.paletteArrMap,
          playerArr = this.props.playerArr,
          ts = this.props.tileSize,
          px = this.props.stageSize,
          decor0 = this.state.dec0Canv,
          decor1 = this.state.dec1Canv,
          ground0 = this.state.grnd0Canv,
          ground1 = this.state.grnd1Canv,
          ore0 = this.state.ore0Canv,
          ore1 = this.state.ore1Canv,
          dec0Data = decor0.getContext('2d').getImageData(0, 0, decor0.width, decor0.height).data,
          dec1Data = decor1.getContext('2d').getImageData(0, 0, decor1.width, decor1.height).data,
          grnd0Data = ground0.getContext('2d').getImageData(0, 0, ground0.width, ground0.height).data,
          grnd1Data = ground1.getContext('2d').getImageData(0, 0, ground1.width, ground1.height).data,
          ore0Data = ore0.getContext('2d').getImageData(0, 0, ore0.width, ore0.height).data,
          ore1Data = ore1.getContext('2d').getImageData(0, 0, ore1.width, ore1.height).data,
          rLen = px / ts,
          accLen = accArr.length,
          frame = (timestamp - timeRef) % 1000 * .06;

      var dCtx = document.getElementById('acc-layer').getContext('2d'),
          tempCanv = this.state.tempCanv,
          tempCtx = tempCanv.getContext('2d'),
          tImgData = tempCtx.createImageData(px, px),
          tImgPixData = tImgData.data,
          renderArr = [],
          iData = 0,
          pData = 0,
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          img = null,
          imgW = 0,
          m = [],
          el = 0,
          srcX = 0,
          srcY = 0,
          dX = 0,
          dY = 0,
          h = 0,
          w = 0,
          i = 0,
          j = 0;

      if (playerArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (playerArr[0] - ~~(rLen / 2));
      } else if (playerArr[0] + ~~(rLen / 2) + 1 > accLen) {
        pr = playerArr[0] + ~~(rLen / 2) + 1 - accLen;
        sr = accLen - rLen + pr;
      } else {
        sr = playerArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (playerArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (playerArr[1] - ~~(rLen / 2));
      } else if (playerArr[1] + ~~(rLen / 2) + 1 > accLen) {
        pc = playerArr[1] + ~~(rLen / 2) + 1 - accLen;
        sc = accLen - rLen + pc;
      } else {
        sc = playerArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = accArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el) {
            m = map['' + el];

            if (frame > 29) {
              if (m[1] === 'decor') img = dec0Data, imgW = decor0.width;else if (m[1] === 'ore') img = ore0Data, imgW = ore0.width;else img = grnd0Data, imgW = ground0.width;
            } else {
              if (m[1] === 'decor') img = dec1Data, imgW = decor1.width;else if (m[1] === 'ore') img = ore1Data, imgW = ore1.width;else img = grnd1Data, imgW = ground1.width;
            }

            srcX = m[0][0];
            srcY = m[0][1];
            dX = sx + j * ts;
            dY = sy + i * ts;
            h = 0;

            while (h < ts) {
              w = 0;
              while (w < ts) {
                pData = (dX + w + (dY + h) * px) * 4;
                iData = (srcX + w + (srcY + h) * imgW) * 4;

                tImgPixData[pData] = img[iData];
                tImgPixData[pData + 1] = img[iData + 1];
                tImgPixData[pData + 2] = img[iData + 2];
                tImgPixData[pData + 3] = img[iData + 3];
                w++;
              }
              h++;
            }
          }
        }
      }

      dCtx.putImageData(tImgData, 0, 0);
      window.requestAnimationFrame(this.drawAccents);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getAccImages();
      this.initAccArr();
      this.initTempCanvas();
      this.initPaletteMaps();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.setPaletteArrMap(nextProps.gameLevel);
        if (this.state.decor0) {
          this.setPalettes(this.state.decor0, this.state.decor1, this.state.ground0, this.state.ground1, this.state.ore0, this.state.ore1, nextProps.gameLevel);
        }
      }
      if (this.props.bgLevelProcessed !== nextProps.bgLevelProcessed) {
        console.log('New Accent Array');
        this.setAccArr(nextProps);
      }

      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.dec0Canv !== this.state.dec0Canv) {
        window.requestAnimationFrame(this.drawAccents);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize,
          enemyDead = this.props.enemyDead;
      return React.createElement('canvas', {
        id: 'acc-layer',
        className: 'acc-layer',
        width: size,
        height: size });
    }
  }]);

  return AccentLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: gameLevel, levelUpCount, interactItem, increasedStat, exchangeAttacks, enemyDead

var ActivityLog = function (_React$Component) {
  _inherits(ActivityLog, _React$Component);

  function ActivityLog(props) {
    _classCallCheck(this, ActivityLog);

    var _this = _possibleConstructorReturn(this, (ActivityLog.__proto__ || Object.getPrototypeOf(ActivityLog)).call(this, props));

    _this.initActivityLog = _this.initActivityLog.bind(_this);
    _this.recycleLog = _this.recycleLog.bind(_this);
    _this.resetLog = _this.resetLog.bind(_this);
    _this.logAdd = _this.logAdd.bind(_this);
    _this.logLevelUp = _this.logLevelUp.bind(_this);
    _this.logItem = _this.logItem.bind(_this);
    _this.logStatPoint = _this.logStatPoint.bind(_this);
    _this.logAttacks = _this.logAttacks.bind(_this);
    _this.logEnemyDead = _this.logEnemyDead.bind(_this);

    _this.logLen = 300;
    _this.renderLen = 30;
    _this.logArrayPadding = 10;
    _this.enemyDeadCount = 0;

    _this.state = {
      log: [],
      //{type:'', message:''}
      index: -1
    };
    return _this;
  }

  _createClass(ActivityLog, [{
    key: 'initActivityLog',
    value: function initActivityLog() {
      var log = this.state.log;


      log.length = this.logLen;
      this.setState({ log: log });
    }
  }, {
    key: 'resetLog',
    value: function resetLog() {
      this.setState({ index: -1 });
    }
  }, {
    key: 'recycleLog',
    value: function recycleLog(log, index) {
      var len = this.renderLen;

      var i = 0;

      for (; i < len; i++) {
        log[i] = log[index - len + i + 1];
      }index = len - 1;

      this.setState({ log: log, index: index });
    }
  }, {
    key: 'logAdd',
    value: function logAdd(logArr) {
      var _state = this.state,
          index = _state.index,
          log = _state.log;


      logArr.forEach(function (el) {
        index++, log[index] = el;
      });

      if (index > this.logLen - this.logArrayPadding) this.recycleLog(log, index);else this.setState({ log: log, index: index });
    }
  }, {
    key: 'logLevelUp',
    value: function logLevelUp() {
      this.logAdd([{ type: 'log-level', message: 'Level Up!' }]);
    }
  }, {
    key: 'logItem',
    value: function logItem(nextProps) {
      var interactItem = nextProps.interactItem,
          action = interactItem.type,
          itemType = 'log-item',
          statType = 'log-stat';


      var verb = action.charAt(0).toUpperCase() + action.slice(1),
          itemLog = [],
          stat = '',
          statDisplay = void 0;

      if (action.slice(0, 3) === 'buy') {
        if (action === 'buySuccess') {
          itemLog.push({ type: itemType, message: verb.slice(0, 3) + ' ' + interactItem.item.name });
        } else if (action === 'buyFail') {
          itemLog.push({ type: itemType, message: 'Not enough to buy.' });
        }
      } else {
        itemLog.push({ type: itemType, message: verb + ' ' + interactItem.item.name });
      }

      if (action === 'use') {
        for (stat in interactItem.item.stats) {
          statDisplay = stat === 'curHealth' ? stat.slice(3) : stat.slice(1);
          itemLog.push({ type: statType, message: 'Increased ' + statDisplay });
        }
      }

      this.logAdd(itemLog);
    }
  }, {
    key: 'logStatPoint',
    value: function logStatPoint(nextProps) {
      var increasedStat = nextProps.increasedStat;


      this.logAdd([{ type: 'log-stat', message: increasedStat.type + ' ' + increasedStat.stat + '.' }]);
    }
  }, {
    key: 'logAttacks',
    value: function logAttacks(nextProps) {
      var attacks = nextProps.exchangeAttacks.attacks,
          type = 'log-attack';


      var message = '',
          attackLog = [];

      attacks.forEach(function (el) {
        message = el.from === 'hero' ? 'You attack ' + el.to + '.' : el.from + ' attacks you.';
        attackLog.push({ type: type, message: message });

        message = el.type.charAt(0).toUpperCase() + el.type.slice(1) + ': ' + el.damage + ' damage.';
        attackLog.push({ type: type, message: message });
      });

      this.logAdd(attackLog);
    }
  }, {
    key: 'logEnemyDead',
    value: function logEnemyDead(nextProps) {
      var _nextProps$enemyDead = nextProps.enemyDead,
          experience = _nextProps$enemyDead.experience,
          gold = _nextProps$enemyDead.gold,
          source = _nextProps$enemyDead.source,
          count = _nextProps$enemyDead.count,
          name = source.name,
          enemyDeadType = 'log-attack',
          experienceType = 'log-stat';


      var enemyDeadLog = [];

      enemyDeadLog.push({ type: enemyDeadType, message: name + ' died.' });
      enemyDeadLog.push({ type: experienceType, message: 'Gained ' + experience + ' experience.' });
      enemyDeadLog.push({ type: experienceType, message: 'Looted ' + gold + ' gold.' });

      this.enemyDeadCount = count;
      this.logAdd(enemyDeadLog);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initActivityLog();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.levelUpCount !== nextProps.levelUpCount) {
        this.logLevelUp();
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count) {
        this.logItem(nextProps);
      }
      if (this.props.increasedStat.count !== nextProps.increasedStat.count) {
        this.logStatPoint(nextProps);
      }
      if (this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count) {
        this.logAttacks(nextProps);
      }
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.logEnemyDead(nextProps);
      }
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.resetLog();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _state2 = this.state,
          log = _state2.log,
          index = _state2.index,
          len = index < this.renderLen - 1 ? index : this.renderLen - 1;


      var renderLog = [],
          i = 0;

      for (i = len; i > -1; i--) {
        renderLog.push(React.createElement(ActivityLogRow, {
          key: i + log[index - i].message,
          type: log[index - i].type,
          message: log[index - i].message }));
      }

      return React.createElement(
        'div',
        { className: 'activity-log' },
        React.createElement(
          'div',
          { className: 'log-content' },
          renderLog
        )
      );
    }
  }]);

  return ActivityLog;
}(React.Component);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: type, message

var ActivityLogRow = function (_React$Component) {
  _inherits(ActivityLogRow, _React$Component);

  function ActivityLogRow() {
    _classCallCheck(this, ActivityLogRow);

    return _possibleConstructorReturn(this, (ActivityLogRow.__proto__ || Object.getPrototypeOf(ActivityLogRow)).apply(this, arguments));
  }

  _createClass(ActivityLogRow, [{
    key: "render",
    value: function render() {

      return React.createElement(
        "p",
        { className: "log " + this.props.type },
        this.props.message
      );
    }
  }]);

  return ActivityLogRow;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, boardSize, tileSize, gameLevel, bgArr, updateBgArr, playerArr, bgLevelProcessed
var BackgroundLayer = function (_React$Component) {
  _inherits(BackgroundLayer, _React$Component);

  function BackgroundLayer(props) {
    _classCallCheck(this, BackgroundLayer);

    var _this = _possibleConstructorReturn(this, (BackgroundLayer.__proto__ || Object.getPrototypeOf(BackgroundLayer)).call(this, props));

    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getBgImages = _this.getBgImages.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.drawBackground = _this.drawBackground.bind(_this);

    _this.state = {
      srcTileSize: 16,
      floorImg: null,
      wallImg: null,
      floorPalette: {},
      wallPalette: {},
      floorPaletteMap: {},
      wallPaletteMap: {},
      tempCanv: {},
      playerLoc: []
    };
    return _this;
  }

  _createClass(BackgroundLayer, [{
    key: 'getBgImages',
    value: function getBgImages() {
      var floorImg = new Image(),
          wallImg = new Image(),
          that = this;

      var i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 2) {
          that.setState({ floorImg: floorImg, wallImg: wallImg });

          //Delete after start screen created
          that.setPalettes(floorImg, wallImg, that.props.gameLevel);
        }
      };

      floorImg.src = 'img/terrain/Floor.png';
      wallImg.src = 'img/terrain/Wall.png';
      floorImg.addEventListener('load', handleLoad);
      wallImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var canvas = document.createElement('canvas'),
          ctx = canvas.getContext('2d'),
          size = this.props.stageSize;

      canvas.width = size;
      canvas.height = size;
      ctx.imageSmoothingEnabled = false;

      this.setState({ tempCanv: { canvas: canvas, ctx: ctx } });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var floorPaletteMap = {
        '41': [0, 0],
        '42': [ts, 0],
        '43': [2 * ts, 0],
        '44': [0, ts],
        '45': [ts, ts],
        '46': [2 * ts, ts],
        '47': [0, 2 * ts],
        '48': [ts, 2 * ts],
        '49': [2 * ts, 2 * ts],
        '51': [3 * ts, 0],
        '52': [3 * ts, ts],
        '53': [3 * ts, 2 * ts],
        '54': [4 * ts, ts],
        '55': [5 * ts, ts],
        '56': [6 * ts, ts],
        '57': [5 * ts, 0]
      };

      var wallPaletteMap = {
        '21': [0, 0],
        '22': [ts, 0],
        '23': [2 * ts, 0],
        '24': [0, ts],
        '25': [0, 2 * ts],
        '26': [ts, ts],
        '27': [2 * ts, 2 * ts],
        '31': [4 * ts, 0],
        '32': [3 * ts, ts],
        '33': [4 * ts, ts],
        '34': [5 * ts, ts],
        '35': [4 * ts, 2 * ts],
        '36': [3 * ts, 0]
      };

      this.setState({ floorPaletteMap: floorPaletteMap, wallPaletteMap: wallPaletteMap });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(floorImg, wallImg, gameLevel) {
      var lvl = gameLevel,
          gmTileSize = this.props.tileSize,
          srcTileSize = this.state.srcTileSize,
          scale = gmTileSize / srcTileSize,
          h = 3 * gmTileSize,
          fw = 7 * gmTileSize,
          ww = 6 * gmTileSize;

      var fCanvas = document.createElement('canvas'),
          fCtx = fCanvas.getContext('2d'),
          wCanvas = document.createElement('canvas'),
          wCtx = wCanvas.getContext('2d'),
          srcY = 3 * srcTileSize;

      srcY *= lvl === 1 ? 5 : lvl === 2 ? 6 : lvl === 3 ? 7 : lvl === 4 ? 8 : lvl === 5 ? 1 : lvl < 8 ? 2 : lvl < 10 ? 3 : lvl === 10 ? 4 : 1;

      fCanvas.width = fw;
      fCanvas.height = h;
      fCtx.imageSmoothingEnabled = false;
      fCtx.drawImage(floorImg, 0, srcY, fw / scale, h / scale, 0, 0, fw, h);

      wCanvas.width = ww;
      wCanvas.height = h;
      wCtx.imageSmoothingEnabled = false;
      wCtx.drawImage(wallImg, 0, srcY, ww / scale, h / scale, 0, 0, ww, h);

      this.setState({
        floorPalette: { canvas: fCanvas, ctx: fCtx },
        wallPalette: { canvas: wCanvas, ctx: wCtx }
      });

      //Delete after start screen created
      this.props.playerArr !== [0, 0] && this.drawBackground(this.props, this.state);
    }
  }, {
    key: 'drawBackground',
    value: function drawBackground(nextProps, nextState) {
      var flrImg = nextState.floorPalette.canvas,
          wallImg = nextState.wallPalette.canvas,
          flrImgMap = nextState.floorPaletteMap,
          wallImgMap = nextState.wallPaletteMap,
          bgArr = nextProps.bgArr,
          playerArr = nextProps.playerArr,
          ts = nextProps.tileSize,
          px = nextProps.stageSize,
          bgLen = bgArr.length,
          rLen = px / ts,
          air = 10,
          flr = 40;

      var dCtx = document.getElementById('bg-layer').getContext('2d'),
          tempCanv = nextState.tempCanv.canvas,
          tempCtx = nextState.tempCanv.ctx,
          renderArr = [],
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          img = null,
          map = {},
          el = 0,
          srcX = 0,
          srcY = 0,
          i = 0,
          j = 0;

      if (playerArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (playerArr[0] - ~~(rLen / 2));
      } else if (playerArr[0] + ~~(rLen / 2) + 1 > bgLen) {
        pr = playerArr[0] + ~~(rLen / 2) + 1 - bgLen;
        sr = bgLen - rLen + pr;
      } else {
        sr = playerArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (playerArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (playerArr[1] - ~~(rLen / 2));
      } else if (playerArr[1] + ~~(rLen / 2) + 1 > bgLen) {
        pc = playerArr[1] + ~~(rLen / 2) + 1 - bgLen;
        sc = bgLen - rLen + pc;
      } else {
        sc = playerArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = bgArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      tempCtx.fillRect(0, 0, px, px);
      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el > air) {
            img = el < flr ? wallImg : flrImg;
            map = el < flr ? wallImgMap : flrImgMap;
            srcX = map['' + el][0];
            srcY = map['' + el][1];
            tempCtx.drawImage(img, srcX, srcY, ts, ts, sx + j * ts, sy + i * ts, ts, ts);
          }
        }
      }

      dCtx.drawImage(tempCanv, 0, 0);
      this.setState({ playerLoc: [].concat(_toConsumableArray(playerArr)) });
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getBgImages();
      this.initTempCanvas();
      this.initPaletteMaps();

      var _backgroundArray = backgroundArray(this.props.boardSize),
          bgArr = _backgroundArray.bgArr,
          floorCoords = _backgroundArray.floorCoords,
          hWallCoords = _backgroundArray.hWallCoords,
          vWallCoords = _backgroundArray.vWallCoords;

      var bgLevelProcessed = this.props.gameLevel;

      this.props.updateBgArr(bgArr, bgLevelProcessed, floorCoords);
      console.log('BG Mounted');
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel && nextProps.gameLevel !== 0) {
        var _backgroundArray2 = backgroundArray(this.props.boardSize),
            bgArr = _backgroundArray2.bgArr,
            floorCoords = _backgroundArray2.floorCoords,
            hWallCoords = _backgroundArray2.hWallCoords,
            vWallCoords = _backgroundArray2.vWallCoords;

        var bgLevelProcessed = nextProps.gameLevel;

        this.props.updateBgArr(bgArr, bgLevelProcessed, floorCoords);

        console.log('New Background Array');

        if (this.state.floorImg) {
          this.setPalettes(this.state.floorImg, this.state.wallImg, nextProps.gameLevel);
        }
      }

      if (nextProps.playerArr !== this.state.playerLoc && nextProps.playerArr !== [0, 0] && this.state.floorPalette.canvas) {
        this.drawBackground(nextProps, this.state);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'bg-layer',
        className: 'bg-layer',
        width: size,
        height: size });
    }
  }]);

  return BackgroundLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, inventory, itemPalettes, interactItem, quickConsume, updateGameClassState
var ConsumableItems = function (_React$Component) {
  _inherits(ConsumableItems, _React$Component);

  function ConsumableItems(props) {
    _classCallCheck(this, ConsumableItems);

    var _this = _possibleConstructorReturn(this, (ConsumableItems.__proto__ || Object.getPrototypeOf(ConsumableItems)).call(this, props));

    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.updateConsumeCanvas = _this.updateConsumeCanvas.bind(_this);

    _this.state = {
      cItems: ['potion', 'hiPotion', 'xPotion', 'tomeOfVitality', 'tomeOfDurability', 'tomeOfStrength', 'tomeOfAgility', 'tomeOfWisdom']
    };
    return _this;
  }

  _createClass(ConsumableItems, [{
    key: 'handleInteractItem',
    value: function handleInteractItem(nextProps) {
      var num = nextProps.quickConsume.num,
          inv = nextProps.inventory,
          interactItem = Object.assign({}, nextProps.interactItem),
          m = consumableAbbrevMap;

      var name = '',
          item = null,
          props = null;

      for (props in m) {
        if (num == m[props].num) name = m[props].name;
      }

      item = inv[name];

      if (item && item.count > 0) {
        interactItem.count += 1;
        interactItem.type = 'use';
        interactItem.item = item;

        nextProps.updateGameClassState({ interactItem: interactItem });
      }
    }
  }, {
    key: 'updateConsumeCanvas',
    value: function updateConsumeCanvas(nextProps) {
      var interactItem = nextProps.interactItem,
          inventory = nextProps.inventory,
          item = interactItem.item,
          type = interactItem.type,
          m = consumableAbbrevMap;


      var update = false,
          props = null,
          dCtx = null,
          palette = null,
          loc = [];

      if (inventory[item.name].count === 1 && ['pickup', 'buySuccess'].includes(type) || inventory[item.name].count === 0 && ['use', 'sell'].includes(type)) {

        update = true;
      }

      console.log('update, item.count, type: ', update, item.count, type);
      if (update) {
        for (props in m) {
          if (item.name === m[props].name) dCtx = getById(props + '-canvas').getContext('2d');
        }

        palette = nextProps.itemPalettes[item.palette];
        loc = item.iconLoc;

        if (['use', 'sell'].includes(type)) dCtx.clearRect(0, 0, loc[2], loc[3]);else dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.quickConsume.count !== nextProps.quickConsume.count && nextProps.quickConsume.count) {

        this.handleInteractItem(nextProps);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count && ['pickup', 'use', 'buySuccess', 'sell'].includes(nextProps.interactItem.type) && nextProps.interactItem.item.type === 'consumable') {

        console.log('ConsumableItems begin updateConsumeCanvas');
        this.updateConsumeCanvas(nextProps);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var m = consumableAbbrevMap,
          itm = this.state.cItems,
          inv = this.props.inventory,
          ts = this.props.tileSize;

      var output = [],
          count = 0;

      output = itm.map(function (el) {
        count = 0;
        if (inv[m[el].name]) count = inv[m[el].name].count;
        return React.createElement(
          'div',
          { className: 'consumable-col', key: 'consumable-col' + m[el].num },
          React.createElement(
            'p',
            { className: 'consumable-col-num', key: 'consumable-col-num' + m[el].num },
            m[el].num
          ),
          React.createElement('canvas', {
            id: el + '-canvas',
            className: 'consumable-canvas',
            key: el + '-canvas',
            width: ts,
            height: ts }),
          React.createElement(
            'p',
            { className: 'consumable-col-abbrev', key: 'consumable-col-abbrev' + m[el].num },
            m[el].abbrev
          ),
          React.createElement(
            'p',
            { className: 'consumable-col-count', key: 'consumable-col-count' + m[el].num },
            'x' + count
          )
        );
      });

      return React.createElement(
        'div',
        { className: 'consumable-items' },
        output
      );
    }
  }]);

  return ConsumableItems;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: enemyDead, gameLevel

var CurrentObjective = function (_React$Component) {
  _inherits(CurrentObjective, _React$Component);

  function CurrentObjective(props) {
    _classCallCheck(this, CurrentObjective);

    var _this = _possibleConstructorReturn(this, (CurrentObjective.__proto__ || Object.getPrototypeOf(CurrentObjective)).call(this, props));

    _this.resetBossDead = _this.resetBossDead.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);

    _this.enemyDeadCount = 0;
    _this.objectives = {
      'false': 'Find and slay boss.',
      'true': 'Travel through portal.'
    };

    _this.state = {
      bossDead: false
    };
    return _this;
  }

  _createClass(CurrentObjective, [{
    key: 'resetBossDead',
    value: function resetBossDead() {
      this.setState({ bossDead: false });
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead;


      this.enemyDeadCount = enemyDead.count;

      if (enemyDead.source.boss) this.setState({ bossDead: true });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.resetBossDead();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'current-objective' },
        React.createElement(
          'p',
          null,
          'Current Objective'
        ),
        React.createElement(
          'p',
          null,
          this.objectives[this.state.bossDead]
        )
      );
    }
  }]);

  return CurrentObjective;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//tileSize, floor, source, spawnIndex, spawnCoord, bgArr, playerArr, moveCount, enemyArr, enemyDisplayArr, updateEnemyDisplayArr, updateEnemyManager, displayCount,
//updateGameClassState, pollCount, incrementPollCount, enemyTurn, updateEnemyTurn, enemyDead, enemyPalettes, roundCount, roundEnemyArr, exchangeAttacks
var Enemy = function (_React$Component) {
  _inherits(Enemy, _React$Component);

  function Enemy(props) {
    _classCallCheck(this, Enemy);

    var _this = _possibleConstructorReturn(this, (Enemy.__proto__ || Object.getPrototypeOf(Enemy)).call(this, props));

    _this.initEnemy = _this.initEnemy.bind(_this);
    _this.chooseMove = _this.chooseMove.bind(_this);
    _this.attemptMove = _this.attemptMove.bind(_this);
    _this.completeMove = _this.completeMove.bind(_this);
    _this.stay = _this.stay.bind(_this);
    _this.attack = _this.attack.bind(_this);
    _this.die = _this.die.bind(_this);
    _this.takeDamage = _this.takeDamage.bind(_this);
    _this.startTurn = _this.startTurn.bind(_this);
    _this.updateEnemyDisplay = _this.updateEnemyDisplay.bind(_this);

    _this.state = {
      level: 0,
      maxHealth: 0,
      curHealth: 0,
      baseStats: {},
      position: [],
      icon: null
    };
    return _this;
  }

  _createClass(Enemy, [{
    key: 'initEnemy',
    value: function initEnemy() {
      var _props = this.props,
          source = _props.source,
          tileSize = _props.tileSize,
          enemyPalettes = _props.enemyPalettes,
          level = randInt(source.levelRange[0], source.levelRange[1]),
          bStats = source.baseStats,
          onLvl = source.onLevelUp,
          position = this.props.spawnCoord,
          convert = statConversion,
          smoothingEnabled = false;


      var icon = document.createElement('canvas'),
          baseStats = {},
          maxHealth = 0,
          curHealth = 0,
          stat = 0,
          el = null,
          ctx = null;

      icon.width = tileSize;
      icon.height = tileSize;
      ctx = icon.getContext('2d');
      ctx.imageSmoothingEnabled = smoothingEnabled;

      ctx.drawImage(enemyPalettes[source.palette[0]], source.iconLoc[0], source.iconLoc[1], tileSize, tileSize, 0, 0, tileSize, tileSize);

      for (el in bStats) {
        stat = bStats[el];
        if (onLvl[el]) stat += level * onLvl[el];
        baseStats[el] = stat;
      }

      maxHealth = baseStats.bHealth + convert.vitToHp * baseStats.bVitality + convert.durToHp * baseStats.bDurability;
      curHealth = maxHealth;

      this.updateEnemyDisplay(position, curHealth, maxHealth, level, icon);
      this.setState({ level: level, maxHealth: maxHealth, curHealth: curHealth, baseStats: baseStats, position: position, icon: icon });
    }
  }, {
    key: 'updateEnemyDisplay',
    value: function updateEnemyDisplay() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.position;
      var curHealth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.curHealth;
      var maxHealth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.maxHealth;
      var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.state.level;
      var icon = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.state.icon;
      var _props2 = this.props,
          source = _props2.source,
          spawnIndex = _props2.spawnIndex;


      var enemyDisplay = {
        position: position,
        curHealth: curHealth,
        maxHealth: maxHealth,
        level: level,
        icon: icon,
        name: source.name,
        type: source.type
      };

      this.props.updateEnemyDisplayArr(enemyDisplay, spawnIndex);
    }
  }, {
    key: 'chooseMove',
    value: function chooseMove(fromCoord, playerArr, roundEnemyArr, bgArr) {
      var floor = this.props.floor,
          h = 1.001,
          blocked = 1000;


      var openStack = [],
          coord = [],
          path = [],
          openSet = {},
          closedSet = {},
          explored = {},
          parent = {},
          current = {},
          costToSpace = 0,
          costToGoal = 0,
          nextStep = 0,
          fCost = 0,
          index = 0,
          row = 0,
          col = 0;

      //set structure: {'12,43': {coord: [], parent: {}, costToSpace, costToGoal, fCost}}

      costToGoal = h * (Math.abs(fromCoord[0] - playerArr[0]) + Math.abs(fromCoord[1] - playerArr[1]));
      fCost = costToGoal;
      explored['' + fromCoord] = { costToSpace: costToSpace, costToGoal: costToGoal, fCost: fCost, coord: fromCoord, parent: {} };
      openSet['' + fromCoord] = explored['' + fromCoord];
      openStack.push(openSet['' + fromCoord]);

      while (!(openStack[0].coord[0] === playerArr[0] && openStack[0].coord[1] === playerArr[1])) {
        current = openStack.shift();
        row = current.coord[0];
        col = current.coord[1];

        delete openSet['' + current.coord];

        [[row - 1, col], [row + 1, col], [row, col + 1], [row, col - 1]].forEach(function (neighbor) {
          if (bgArr[neighbor[0]][neighbor[1]] > floor && !roundEnemyArr[neighbor[0]][neighbor[1]]) {
            nextStep = 1;
          } else {
            nextStep = blocked;
          }
          costToSpace = current.costToSpace + nextStep;

          if (openSet['' + neighbor] && costToSpace < openSet['' + neighbor].costToSpace) {
            index = openStack.findIndex(function (el) {
              return el[0] === neighbor[0] && el[1] === neighbor[1];
            });
            openStack.splice(index, 1);
            delete openSet['' + neighbor];
          }
          if (closedSet['' + neighbor] && costToSpace < closedSet['' + neighbor].costToSpace) {
            delete closedSet['' + neighbor];
          }
          if (!openSet['' + neighbor] && !closedSet['' + neighbor]) {
            costToGoal = h * (Math.abs(neighbor[0] - playerArr[0]) + Math.abs(neighbor[1] - playerArr[1]));
            fCost = costToSpace + costToGoal;
            parent = explored['' + current.coord];
            explored['' + neighbor] = { costToSpace: costToSpace, costToGoal: costToGoal, fCost: fCost, parent: parent, coord: neighbor };
            openSet['' + neighbor] = explored['' + neighbor];
            index = openStack.findIndex(function (el) {
              return fCost < el.fCost;
            });
            if (index > -1) openStack.splice(index, 0, openSet['' + neighbor]);else openStack.push(openSet['' + neighbor]);
          }
        });
      }

      current = openStack[0];
      coord = current.coord;
      while (coord.length && !(coord[0] === fromCoord[0] && coord[1] === fromCoord[1])) {
        path.unshift(coord);
        current = current.parent;
        coord = current.coord;
      }

      return path[0];
    }
  }, {
    key: 'attemptMove',
    value: function attemptMove(nextProps) {
      var bgArr = nextProps.bgArr,
          roundEnemyArr = nextProps.roundEnemyArr,
          playerArr = nextProps.playerArr,
          source = nextProps.source,
          stats = this.state.baseStats,
          fromCoord = this.state.position,
          toCoord = [],
          turn = {};


      toCoord = this.chooseMove(fromCoord, playerArr, roundEnemyArr, bgArr);
      //console.log('chooseMove: ', JSON.stringify(toCoord), 'from: ', JSON.stringify(fromCoord));
      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        source: source,
        fromCoord: fromCoord,
        toCoord: toCoord,
        type: 'move',
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'completeMove',
    value: function completeMove(position) {
      this.updateEnemyDisplay(position);
      this.setState({ position: [].concat(_toConsumableArray(position)) });
    }
  }, {
    key: 'stay',
    value: function stay(nextProps) {
      var stats = this.state.baseStats,
          coord = this.state.position,
          turn = {};

      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        type: 'stay',
        source: nextProps.source,
        fromCoord: coord,
        toCoord: coord,
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'attack',
    value: function attack(nextProps) {
      var playerArr = nextProps.playerArr,
          source = nextProps.source,
          stats = this.state.baseStats,
          fromCoord = this.state.position,
          turn = {};


      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        source: source,
        fromCoord: fromCoord,
        type: 'attack',
        toCoord: playerArr,
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'die',
    value: function die() {
      var _state = this.state,
          position = _state.position,
          level = _state.level,
          _props3 = this.props,
          spawnIndex = _props3.spawnIndex,
          source = _props3.source,
          enemyDead = Object.assign(this.props.enemyDead),
          conv = statConversion;


      var experience = 0,
          gold = 0,
          i = 0;

      console.log('enemyDead');

      for (; i < level; i++) {
        experience += randInt(conv.lvlToExpRange[0], conv.lvlToExpRange[1]);
        gold += randInt(conv.lvlToGoldRange[0], conv.lvlToGoldRange[1]);
      }

      if (this.props.source.boss) experience *= conv.bossMultiplier, gold *= conv.bossMultiplier;

      enemyDead.count++;
      enemyDead.spawnIndex = spawnIndex;
      enemyDead.coord = position;
      enemyDead.source = source, enemyDead.level = level;
      enemyDead.experience = ~~experience;
      enemyDead.gold = ~~gold;

      this.props.updateGameClassState({ enemyDead: enemyDead });
    }
  }, {
    key: 'takeDamage',
    value: function takeDamage(attacks) {
      var curHealth = this.state.curHealth,
          damage = 0;


      attacks.forEach(function (el) {
        if (el.from === 'hero') damage = el.damage;
      });

      curHealth = curHealth - damage > 0 ? curHealth - damage : 0;

      console.log('Damage to enemy: ', damage);

      if (!curHealth) this.die();

      this.updateEnemyDisplay(this.state.position, curHealth);
      this.props.updateEnemyManager({ displayCount: this.props.displayCount + 1 });
      this.setState({ curHealth: curHealth });
    }
  }, {
    key: 'startTurn',
    value: function startTurn(nextProps) {
      var _state2 = this.state,
          position = _state2.position,
          curHealth = _state2.curHealth,
          playerArr = nextProps.playerArr,
          aggression = nextProps.source.aggression;

      //console.log('Enemy startTurn: ', curHealth, JSON.stringify(position), JSON.stringify(playerArr), aggression);

      if (linearDistance(position, playerArr) > aggression || curHealth < 1) {
        this.stay(nextProps);
      } else if (playerArr[0] === position[0] && Math.pow(playerArr[1] - position[1], 2) === 1 || playerArr[1] === position[1] && Math.pow(playerArr[0] - position[0], 2) === 1) {
        this.attack(nextProps);
      } else {
        this.attemptMove(nextProps);
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initEnemy();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.pollCount === 0 && this.props.moveCount !== nextProps.moveCount) {
        //console.log('Enemy receiveProps startTurn');
        this.startTurn(nextProps);
      }
      if (this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count && nextProps.exchangeAttacks.spawnIndex === nextProps.spawnIndex) {

        this.takeDamage(nextProps.exchangeAttacks.attacks);
      } /*
        if (this.props.roundCount !== nextProps.roundCount &&
         this.props.enemyTurn[this.props.spawnIndex].type === 'move' &&
         this.props.enemyTurn[this.props.spawnIndex].status) {
           console.log('completeMove!: ', nextProps.enemyTurn[nextProps.spawnIndex].toCoord);
         this.completeMove(nextProps.enemyTurn[nextProps.spawnIndex].toCoord);
        }*/
      if (this.props.roundCount !== nextProps.roundCount && nextProps.enemyTurn[this.props.spawnIndex].type === 'move' && nextProps.enemyTurn[this.props.spawnIndex].status) {

        this.completeMove(nextProps.enemyTurn[nextProps.spawnIndex].toCoord);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props4 = this.props,
          playerArr = _props4.playerArr,
          roundEnemyArr = _props4.roundEnemyArr,
          source = _props4.source,
          _state3 = this.state,
          position = _state3.position,
          level = _state3.level,
          curHealth = _state3.curHealth,
          icon = _state3.icon;


      var positionQue = 0,
          positionsTaken = [0, 0, 0, 0],
          rIcon = null,
          rName = null,
          rLevel = null,
          rCurHealth = null;

      if (roundEnemyArr.length) {
        [[playerArr[0] - 1, playerArr[1]], [playerArr[0], playerArr[1] + 1], [playerArr[0] + 1, playerArr[1]], [playerArr[0], playerArr[1] - 1]].forEach(function (el, i) {
          if (roundEnemyArr[el[0]][el[1]]) positionsTaken[i] = 1;
          if (el === position) positionQue = i;
        });

        if (positionQue === position.findIndex(function (el) {
          return el === 1;
        })) {
          rIcon = icon;
          rName = source.name;
          rLevel = 'Level: ' + level;
          rCurHealth = 'Current Health: ' + curHealth;
        }
      }

      return React.createElement(
        'div',
        null,
        React.createElement(
          'span',
          null,
          rIcon
        ),
        React.createElement(
          'span',
          null,
          rName
        ),
        React.createElement(
          'div',
          null,
          rLevel
        ),
        React.createElement(
          'div',
          null,
          rCurHealth
        )
      );
    }
  }]);

  return Enemy;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//stageSize, boardSize, tileSize, playerArr, enemyArr, enemyPalettes, updateGameClassState
//
var EnemyLayer = function (_React$Component) {
  _inherits(EnemyLayer, _React$Component);

  function EnemyLayer(props) {
    _classCallCheck(this, EnemyLayer);

    var _this = _possibleConstructorReturn(this, (EnemyLayer.__proto__ || Object.getPrototypeOf(EnemyLayer)).call(this, props));

    _this.initEnemyArr = _this.initEnemyArr.bind(_this);
    _this.getEnemyImages = _this.getEnemyImages.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.drawEnemies = _this.drawEnemies.bind(_this);

    _this.state = {
      srcTileSize: 16,
      images: {},
      tempCanv: null,
      renderPadArr: [3, 2, 1, 0, 0, 0, 1, 2, 3]
    };
    return _this;
  }

  _createClass(EnemyLayer, [{
    key: 'initEnemyArr',
    value: function initEnemyArr() {
      var len = this.props.boardSize,
          enemyArr = initZeroArray(len);

      this.props.updateGameClassState({ enemyArr: enemyArr });
    }
  }, {
    key: 'getEnemyImages',
    value: function getEnemyImages() {
      var path = 'img/characters/',
          type = '.png',
          that = this;

      var avian0Img = void 0,
          avian1Img = void 0,
          demon0Img = void 0,
          demon1Img = void 0,
          elemental0Img = void 0,
          elemental1Img = void 0,
          humanoid0Img = void 0,
          humanoid1Img = void 0,
          reptile0Img = void 0,
          reptile1Img = void 0,
          undead0Img = void 0,
          undead1Img = void 0,
          images = {
        avian0Img: avian0Img,
        avian1Img: avian1Img,
        demon0Img: demon0Img,
        demon1Img: demon1Img,
        elemental0Img: elemental0Img,
        elemental1Img: elemental1Img,
        humanoid0Img: humanoid0Img,
        humanoid1Img: humanoid1Img,
        reptile0Img: reptile0Img,
        reptile1Img: reptile1Img,
        undead0Img: undead0Img,
        undead1Img: undead1Img
      },
          el = void 0,
          eLen = 0,
          i = 0;

      var handleItemLoad = function handleEnemyImageLoad() {
        i++;
        if (i === eLen) {
          that.setState({ images: images });
          that.setPalettes(images);
        }
      };

      for (el in images) {
        images[el] = new Image();
        images[el].src = path + el[0].toUpperCase() + el.slice(1, -3) + type;
        images[el].addEventListener('load', handleItemLoad);
        eLen++;
      }
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var size = this.props.stageSize,
          smoothRender = false,
          tempCanv = initMemCanvas(size, size, smoothRender);

      this.setState({ tempCanv: tempCanv });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var ts = this.props.tileSize,
          srcTs = this.state.srcTileSize,
          scale = ts / srcTs,
          renderSmoothing = false,
          imgPixDataName = 'imgPixData';

      var enemyPalettes = {},
          p = null,
          el = null,
          ctx = null,
          img = null,
          name = '',
          w = 0,
          h = 0;

      for (el in images) {
        img = images[el];
        name = el.slice(0, -3) + 'Palette';
        w = img.width;
        h = img.height;
        p = enemyPalettes;
        p[name] = document.createElement('canvas');
        p[name].width = scale * w;
        p[name].height = scale * h;
        ctx = p[name].getContext('2d');
        ctx.imageSmoothingEnabled = renderSmoothing;
        ctx.drawImage(img, 0, 0, w, h, 0, 0, p[name].width, p[name].height);
        p[name][imgPixDataName] = ctx.getImageData(0, 0, p[name].width, p[name].height).data;
      }

      this.props.updateGameClassState({ enemyPalettes: enemyPalettes });
    }
  }, {
    key: 'drawEnemies',
    value: function drawEnemies(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var pIndex = (timestamp - timeRef) % 1000 * .06 > 29 ? 1 : 0,
          _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          playerArr = _props.playerArr,
          enemyArr = _props.enemyArr,
          enemyPalettes = _props.enemyPalettes,
          renderPadArr = this.state.renderPadArr,
          renderInset = 3,
          renderLenBase = stageSize / tileSize - 2 * renderInset,
          enemyArrLen = enemyArr.length;


      var dCtx = getById('enemy-layer').getContext('2d'),
          tempCanv = this.state.tempCanv,
          tempCtx = tempCanv.getContext('2d'),
          tImgData = tempCtx.createImageData(stageSize, stageSize),
          tImgPixData = tImgData.data,
          canvas = null,
          renderArr = [],
          iData = 0,
          pData = 0,
          startRow = 0,
          startCol = 0,
          padRow = 0,
          padCol = 0,
          renderPadX = 0,
          renderPadY = 0,
          img = null,
          imgW = 0,
          imgH = 0,
          el = 0,
          srcX = 0,
          srcY = 0,
          dX = 0,
          dY = 0,
          pxRow = 0,
          pxCol = 0,
          i = 0,
          j = 0;

      if (playerArr[0] < ~~(renderLenBase / 2)) {
        startRow = 0;
        padRow = ~~(renderLenBase / 2) - playerArr[0];
      } else if (playerArr[0] + ~~(renderLenBase / 2) + 1 > enemyArrLen) {
        padRow = playerArr[0] + ~~(renderLenBase / 2) + 1 - enemyArrLen;
        startRow = enemyArrLen - renderLenBase + padRow;
      } else {
        startRow = playerArr[0] - ~~(renderLenBase / 2);
        padRow = 0;
      }

      if (playerArr[1] < ~~(renderLenBase / 2)) {
        startCol = 0;
        padCol = ~~(renderLenBase / 2) - playerArr[1];
      } else if (playerArr[1] + ~~(renderLenBase / 2) + 1 > enemyArrLen) {
        padCol = playerArr[1] + ~~(renderLenBase / 2) + 1 - enemyArrLen;
        startCol = enemyArrLen - renderLenBase + padCol;
      } else {
        startCol = playerArr[1] - ~~(renderLenBase / 2);
        padCol = 0;
      }

      renderArr.length = renderLenBase - padRow;

      while (i < renderLenBase - padRow) {
        renderArr[i] = [];
        renderArr[i].length = renderLenBase - padCol;

        while (j < renderLenBase - padCol) {
          if (j >= renderPadArr[startRow ? i : i + padRow] && j < renderLenBase - padRow - renderPadArr[startCol ? i : i + padCol]) {

            renderArr[i][j] = enemyArr[startRow + i][startCol + j];
          } else {
            renderArr[i][j] = 0;
          }

          j++;
        }

        j = 0, i++;
      }

      renderPadX = !startCol && padCol ? (padCol + renderInset) * tileSize : renderInset * tileSize;

      renderPadY = !startRow && padRow ? (padRow + renderInset) * tileSize : renderInset * tileSize;

      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];

          if (el) {
            canvas = enemyPalettes[el.palette[pIndex]];
            imgW = canvas.width;
            imgH = canvas.height;
            img = canvas.getContext('2d').getImageData(0, 0, imgW, imgH).data;

            srcX = el.iconLoc[0];
            srcY = el.iconLoc[1];
            dX = renderPadX + j * tileSize;
            dY = renderPadY + i * tileSize;
            pxRow = 0;

            while (pxRow < tileSize) {
              pxCol = 0;

              while (pxCol < tileSize) {
                pData = (dX + pxCol + (dY + pxRow) * stageSize) * 4;
                iData = (srcX + pxCol + (srcY + pxRow) * imgW) * 4;

                tImgPixData[pData] = img[iData];
                tImgPixData[pData + 1] = img[iData + 1];
                tImgPixData[pData + 2] = img[iData + 2];
                tImgPixData[pData + 3] = img[iData + 3];
                pxCol++;
              }

              pxRow++;
            }
          }
        }
      }

      dCtx.putImageData(tImgData, 0, 0);

      window.requestAnimationFrame(this.drawEnemies);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getEnemyImages();
      this.initEnemyArr();
      this.initTempCanvas();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (Object.keys(prevProps.enemyPalettes).length !== Object.keys(this.props.enemyPalettes).length && Object.keys(this.props.enemyPalettes).length) {

        window.requestAnimationFrame(this.drawEnemies);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'enemy-layer',
        className: 'enemy-layer',
        width: size,
        height: size });
    }
  }]);

  return EnemyLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//gameLevel, bgArr, floorCoords, playerArr, enemyArr, enemyAttack, exchangeAttacks,
//moveCount, updateGameClassState, tileSize, floor, enemyPalettes, enemyDead, bgLevelProcessed
var EnemyManager = function (_React$Component) {
  _inherits(EnemyManager, _React$Component);

  function EnemyManager(props) {
    _classCallCheck(this, EnemyManager);

    var _this = _possibleConstructorReturn(this, (EnemyManager.__proto__ || Object.getPrototypeOf(EnemyManager)).call(this, props));

    _this.setLevelEnemies = _this.setLevelEnemies.bind(_this);
    _this.runEnemyRound = _this.runEnemyRound.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.updateEnemyManager = _this.updateEnemyManager.bind(_this);
    _this.incrementPollCount = _this.incrementPollCount.bind(_this);
    _this.updateEnemyTurn = _this.updateEnemyTurn.bind(_this);
    _this.updateEnemyDisplayArr = _this.updateEnemyDisplayArr.bind(_this);
    _this.setEnemyDisplay = _this.setEnemyDisplay.bind(_this);
    _this.drawEnemyIcon = _this.drawEnemyIcon.bind(_this);

    _this.pollCount = -1;
    _this.enemyDeadCount = 0;
    _this.enemyTurn = [];
    //enemyTurn: [{ type: '', source: {}, stats: {}, fromCoord: [], toCoord: [], status: bool },]
    //type: 'move', 'stay', 'attack', 'die'

    _this.enemyDisplayArr = [];
    //{name: '', type: '', icon: <memCanvas>, level: 0, curHealth: 0, maxHealth: 0, position: []}
    _this.enemyDisplay = {};

    _this.state = {
      roundCount: 0,
      displayCount: 0,
      levelProcessed: 0,
      enemiesRemaining: 0,
      currentIndex: 0,
      levelEnemies: [],
      roundEnemyArr: [],
      nextKey: 0

    };
    return _this;
  }

  _createClass(EnemyManager, [{
    key: 'incrementPollCount',
    value: function incrementPollCount() {
      this.pollCount++;

      if (this.pollCount === this.state.levelEnemies.length) {
        this.runEnemyRound(this.props);
      }
    }
  }, {
    key: 'updateEnemyTurn',
    value: function updateEnemyTurn(turn, index) {
      this.enemyTurn[index] = turn;
    }
  }, {
    key: 'updateEnemyDisplayArr',
    value: function updateEnemyDisplayArr(enemy, index) {
      this.enemyDisplayArr[index] = enemy;
    }
  }, {
    key: 'setLevelEnemies',
    value: function setLevelEnemies() {
      var _props = this.props,
          gameLevel = _props.gameLevel,
          bgLevelProcessed = _props.bgLevelProcessed,
          bgArr = _props.bgArr,
          len = bgArr.length,
          enemyList = [enemyAvian, enemyDemon, enemyElemental, enemyHumanoid, enemyReptile, enemyUndead],
          centerFloorSpace = 45;
      var floorCoords = [].concat(_toConsumableArray(this.props.floorCoords)),
          enemyArr = initZeroArray(len),
          nextKey = this.state.nextKey,
          levelEnemies = [],
          spawnCoord = [],
          curCoord = [0, 0],
          curIndex = 0,
          source = {},
          el = null,
          enemiesRemaining = 0,
          count = 0,
          i = 0;


      enemyList.forEach(function (obj) {
        for (el in obj) {
          source = obj[el];
          count = source.spawnQuant['' + gameLevel] ? source.spawnQuant['' + gameLevel] : 0;
          enemiesRemaining += count;
          i = 0;

          while (i < count) {
            if (source.type === 'merchant') {
              while (!(bgArr[curCoord[0]][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0] - 1][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0]][curCoord[1] + 1] === centerFloorSpace && bgArr[curCoord[0] + 1][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0]][curCoord[1] - 1] === centerFloorSpace)) {
                curIndex = randInt(0, floorCoords.length - 1);
                curCoord = floorCoords[curIndex];
              }
              spawnCoord = floorCoords.splice(curIndex, 1)[0];
              console.log('Merchant at: ', spawnCoord);
            } else {
              spawnCoord = floorCoords.splice(randInt(0, floorCoords.length - 1), 1)[0];
            }

            enemyArr[spawnCoord[0]][spawnCoord[1]] = source;
            nextKey++;

            levelEnemies.push({ source: source, spawnCoord: spawnCoord, key: nextKey });
            i++;

            if (source.boss) console.log('Boss at: ', spawnCoord);
          }
        }
      });

      this.enemyTurn.length = enemiesRemaining;
      this.enemyDisplayArr.length = enemiesRemaining;

      this.props.updateGameClassState({ floorCoords: floorCoords, enemyArr: enemyArr });

      this.setState({
        levelEnemies: levelEnemies,
        enemiesRemaining: enemiesRemaining,
        nextKey: nextKey,
        levelProcessed: bgLevelProcessed,
        roundEnemyArr: enemyArr
      });
    }
  }, {
    key: 'runEnemyRound',
    value: function runEnemyRound(props) {
      var enemyAttack = props.enemyAttack;
      var enemyTurn = [].concat(_toConsumableArray(this.enemyTurn)),
          roundEnemyArr = [].concat(_toConsumableArray(this.state.roundEnemyArr)),
          _state = this.state,
          roundCount = _state.roundCount,
          currentIndex = _state.currentIndex,
          levelEnemies = _state.levelEnemies,
          count = enemyAttack.count,
          type = '',
          source = {},
          stats = {},
          toCoord = [],
          fromCoord = [],
          status = false,
          spawnIndex = 0;

      //console.log('EnemyRound enemyTurn: ', enemyTurn, 'roundCount: ', roundCount, 'currentIndex: ', currentIndex, 'this.pollCount: ', this.pollCount);

      while (currentIndex < this.pollCount) {
        var _enemyTurn$currentInd = enemyTurn[currentIndex];
        type = _enemyTurn$currentInd.type;
        source = _enemyTurn$currentInd.source;
        stats = _enemyTurn$currentInd.stats;
        fromCoord = _enemyTurn$currentInd.fromCoord;
        toCoord = _enemyTurn$currentInd.toCoord;
        status = _enemyTurn$currentInd.status;


        if (type === 'stay') {
          enemyTurn[currentIndex].status = true;
        } else if (type === 'move') {
          status = roundEnemyArr[toCoord[0]][toCoord[1]] === 0 ? true : false;
          //console.log('start Move - currentIndex, fromCoord, toCoord, status: ', currentIndex, fromCoord, toCoord, status);

          if (status) {
            roundEnemyArr[fromCoord[0]][fromCoord[1]] = 0;
            roundEnemyArr[toCoord[0]][toCoord[1]] = source;
          }
          enemyTurn[currentIndex].status = status;
        } else if (type === 'attack') {
          count++;
          spawnIndex = currentIndex;
          enemyTurn[currentIndex].status = true;

          props.updateGameClassState({ enemyAttack: { count: count, roundCount: roundCount, spawnIndex: spawnIndex, stats: stats, source: source } });
        }
        currentIndex++;
      }

      if (currentIndex === levelEnemies.length) {
        currentIndex = 0;
        this.pollCount = 0;
        roundCount++;

        props.updateGameClassState({ enemyArr: roundEnemyArr });
      }

      this.enemyTurn = [].concat(enemyTurn);
      this.setState({ roundEnemyArr: roundEnemyArr, currentIndex: currentIndex, roundCount: roundCount });
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead,
          coord = enemyDead.coord,
          count = enemyDead.count;
      var enemyArr = nextProps.enemyArr,
          roundEnemyArr = this.state.roundEnemyArr;


      roundEnemyArr[coord[0]][coord[1]] = 0;
      enemyArr = [].concat(_toConsumableArray(roundEnemyArr));
      this.enemyDeadCount = count;

      nextProps.updateGameClassState({ enemyArr: enemyArr });
      this.setState({ roundEnemyArr: roundEnemyArr });
    }
  }, {
    key: 'updateEnemyManager',
    value: function updateEnemyManager() {
      var updatedEls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setState(updatedEls);
    }
  }, {
    key: 'drawEnemyIcon',
    value: function drawEnemyIcon(icon) {
      var ts = this.props.tileSize;

      var ctx = getById('enemy-icon').getContext('2d');

      if (icon) ctx.drawImage(icon, 0, 0);else ctx.clearRect(0, 0, ts, ts);
    }
  }, {
    key: 'setEnemyDisplay',
    value: function setEnemyDisplay(nextProps, nextState) {
      var playerArr = nextProps.playerArr,
          enemyDisplayArr = this.enemyDisplayArr,
          displayRange = 3;


      var displayChoice = {},
          position = [],
          icon = null,
          updateDisplayChoice = false,
          distance = 0,
          healthLost = 0,
          maxHealth = 0,
          curHealth = 0,
          index = 0;

      enemyDisplayArr.forEach(function (el, i) {
        if (el && el.curHealth) {
          updateDisplayChoice = false;
          position = enemyDisplayArr[i].position;
          distance = Math.abs(playerArr[0] - position[0]) + Math.abs(playerArr[1] - position[1]);

          if (distance <= displayRange) {
            index = i;
            maxHealth = el.maxHealth;
            curHealth = el.curHealth;
            healthLost = maxHealth - curHealth;

            if (!displayChoice.maxHealth || distance < displayChoice.distance) {
              updateDisplayChoice = true;
            } else if (distance === displayChoice.distance) {
              if (healthLost > displayChoice.healthLost) {
                updateDisplayChoice = true;
              } else if (healthLost === displayChoice.healthLost) {
                if (maxHealth > displayChoice.maxHealth) updateDisplayChoice = true;
              }
            }

            if (updateDisplayChoice) {
              displayChoice = { position: position, distance: distance, index: index, maxHealth: maxHealth, curHealth: curHealth, healthLost: healthLost };
            }
          }
        }
      });

      if (!(displayChoice.index && enemyDisplayArr[displayChoice.index].curHealth === this.enemyDisplay.curHealth && enemyDisplayArr[displayChoice.index].name === this.enemyDisplay.name && enemyDisplayArr[displayChoice.index].level === this.enemyDisplay.level)) {

        this.enemyDisplay = displayChoice.curHealth ? enemyDisplayArr[displayChoice.index] : {};
        icon = this.enemyDisplay.icon ? this.enemyDisplay.icon : false;

        this.drawEnemyIcon(icon);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.pollCount === -1 && this.state.levelEnemies.length && this.props.moveCount !== nextProps.moveCount) {
        this.pollCount = 0;
      }
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.props.moveCount !== nextProps.moveCount || this.state.displayCount !== nextState.displayCount) {
        this.setEnemyDisplay(nextProps, nextState);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.levelProcessed !== this.props.bgLevelProcessed && Object.keys(this.props.enemyPalettes).length) {

        this.setLevelEnemies();
        console.log('New Level Enemies');
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var levelEnemies = this.state.levelEnemies,
          ts = this.props.tileSize,
          enemyDisplay = this.enemyDisplay;


      var enemies = [],
          spawnCoord = [],
          source = {},
          key = 0,
          displayName = null,
          displayType = null,
          displayLevel = null,
          displayHealth = null;

      levelEnemies.forEach(function (obj) {
        source = obj.source;
        spawnCoord = obj.spawnCoord;
        key = obj.key;


        enemies.push(React.createElement(Enemy, {
          key: source.name + key,
          source: source,
          spawnIndex: enemies.length,
          spawnCoord: spawnCoord,
          floor: _this2.props.floor,
          tileSize: _this2.props.tileSize,
          bgArr: _this2.props.bgArr,
          playerArr: _this2.props.playerArr,
          moveCount: _this2.props.moveCount,
          displayCount: _this2.state.displayCount,
          enemyArr: _this2.props.enemyArr,
          roundEnemyArr: _this2.state.roundEnemyArr,
          enemyPalettes: _this2.props.enemyPalettes,
          enemyDead: _this2.props.enemyDead,
          pollCount: _this2.pollCount,
          incrementPollCount: _this2.incrementPollCount,
          roundCount: _this2.state.roundCount,
          enemyTurn: _this2.enemyTurn,
          enemyDisplayArr: _this2.enemyDisplayArr,
          updateEnemyTurn: _this2.updateEnemyTurn,
          updateEnemyDisplayArr: _this2.updateEnemyDisplayArr,
          exchangeAttacks: _this2.props.exchangeAttacks,
          updateEnemyManager: _this2.updateEnemyManager,
          updateGameClassState: _this2.props.updateGameClassState }));
      });

      if (enemyDisplay.name) {
        displayName = 'Name: ' + enemyDisplay.name;
        displayType = 'Type: ' + enemyDisplay.type;
        displayLevel = 'Level: ' + enemyDisplay.level;
        displayHealth = 'Health: ' + enemyDisplay.curHealth + '/' + enemyDisplay.maxHealth;
      }

      return React.createElement(
        'div',
        { className: 'enemy-manager' },
        React.createElement(
          'p',
          { className: 'enemy-manager-title' },
          enemyDisplay.type === 'merchant' ? 'Merchant' : 'Enemy'
        ),
        React.createElement('canvas', { id: 'enemy-icon', className: 'enemy-icon', width: ts, height: ts }),
        React.createElement(
          'div',
          { className: 'stat-col' },
          React.createElement(
            'p',
            null,
            displayName
          ),
          React.createElement(
            'p',
            null,
            displayType
          ),
          React.createElement(
            'p',
            null,
            displayLevel
          ),
          React.createElement(
            'p',
            null,
            displayHealth
          )
        ),
        enemies
      );
    }
  }]);

  return EnemyManager;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: gameLevel, levels

var GameLevel = function (_React$Component) {
  _inherits(GameLevel, _React$Component);

  function GameLevel(props) {
    _classCallCheck(this, GameLevel);

    var _this = _possibleConstructorReturn(this, (GameLevel.__proto__ || Object.getPrototypeOf(GameLevel)).call(this, props));

    _this.levelNames = {
      '1': 'The Threshold',
      '2': 'Forboding Cave',
      '3': 'Cave of Hopelessness',
      '4': 'Cave of Despair',
      '5': 'Abyss Cave',
      '6': 'Dungeon Entry',
      '7': 'Demon Palisades',
      '8': 'Feeding Dungeon',
      '9': "Death's Doorstep",
      '10': 'The Abyss'
    };
    return _this;
  }

  _createClass(GameLevel, [{
    key: 'render',
    value: function render() {
      var gameLevel = this.props.gameLevel,
          levelName = this.levelNames[gameLevel];


      return React.createElement(
        'div',
        { className: 'level' },
        React.createElement(
          'p',
          null,
          'Level ' + gameLevel
        ),
        React.createElement(
          'p',
          null,
          levelName
        )
      );
    }
  }]);

  return GameLevel;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, tileSize, floor, gameLevel, levels, hero, playerArr, bgArr, updateBgArr, floorCoords,
//updateFloorCoords, updatePlayerArr, itemArr, itemPalettes, updateGameClassState, itemPaletteArrMap
//inventory, interactItem, heroFacing, enemyArr, enemyPalettes, enemyDead, bgLevelProcessed
var GameStage = function (_React$Component) {
  _inherits(GameStage, _React$Component);

  function GameStage(props) {
    _classCallCheck(this, GameStage);

    var _this = _possibleConstructorReturn(this, (GameStage.__proto__ || Object.getPrototypeOf(GameStage)).call(this, props));

    _this.updateAccArr = _this.updateAccArr.bind(_this);

    _this.state = {
      stageSize: 480,
      accArr: []
    };
    return _this;
  }

  _createClass(GameStage, [{
    key: 'updateAccArr',
    value: function updateAccArr(accArr) {
      this.setState({ accArr: accArr });
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'stage' },
        React.createElement(BackgroundLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          bgArr: this.props.bgArr,
          updateBgArr: this.props.updateBgArr,
          playerArr: this.props.playerArr }),
        React.createElement(AccentLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          accArr: this.state.accArr,
          enemyDead: this.props.enemyDead,
          updateAccArr: this.updateAccArr }),
        React.createElement(ItemLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          levels: this.props.levels,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          floorCoords: this.props.floorCoords,
          itemArr: this.props.itemArr,
          itemPalettes: this.props.itemPalettes,
          itemPaletteArrMap: this.props.itemPaletteArrMap,
          enemyDead: this.props.enemyDead,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(EnemyLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          enemyPalettes: this.props.enemyPalettes,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(PlayerLayer, {
          stageSize: this.state.stageSize,
          tileSize: this.props.tileSize,
          hero: this.props.hero,
          heroFacing: this.props.heroFacing,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          bgArr: this.props.bgArr,
          playerArr: this.props.playerArr,
          floorCoords: this.props.floorCoords,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(OptionOverlay, {
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          overlayMode: this.props.overlayMode,
          updateGameClassState: this.props.updateGameClassState })
      );
    }
  }]);

  return GameStage;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameTips = function (_React$Component) {
  _inherits(GameTips, _React$Component);

  function GameTips() {
    _classCallCheck(this, GameTips);

    return _possibleConstructorReturn(this, (GameTips.__proto__ || Object.getPrototypeOf(GameTips)).apply(this, arguments));
  }

  _createClass(GameTips, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'tips' },
        'Press \'H\' for help.'
      );
    }
  }]);

  return GameTips;
}(React.Component);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, hero, heroIcon, inventory, itemPalettes, interactItem, updateGameClassState
//useStatPoint, increasedStat, enemyAttack, exchangeAttacks, enemyDead, gameOver
var Hero = function (_React$Component) {
  _inherits(Hero, _React$Component);

  function Hero(props) {
    _classCallCheck(this, Hero);

    var _this = _possibleConstructorReturn(this, (Hero.__proto__ || Object.getPrototypeOf(Hero)).call(this, props));

    _this.initHero = _this.initHero.bind(_this);
    _this.changeStats = _this.changeStats.bind(_this);
    _this.gainExperience = _this.gainExperience.bind(_this);
    _this.handleLevelUp = _this.handleLevelUp.bind(_this);
    _this.paintHeroIcon = _this.paintHeroIcon.bind(_this);
    _this.attemptPurchase = _this.attemptPurchase.bind(_this);
    _this.sellItem = _this.sellItem.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.handleUseStatPoint = _this.handleUseStatPoint.bind(_this);
    _this.updateEquipCanvas = _this.updateEquipCanvas.bind(_this);
    _this.handleBattleRound = _this.handleBattleRound.bind(_this);

    _this.enemyDeadCount = 0;

    _this.state = {
      heroName: "",
      experience: 0,
      expToLevel: 0,
      charLevel: 0,
      gold: 500,
      curHealth: 0,
      bHealth: 0,
      bAttack: 0,
      bDefense: 0,
      bHit: 0,
      bCrit: 0,
      bDodge: 0,
      bVitality: 0,
      bDurability: 0,
      bStrength: 0,
      bAgility: 0,
      statPoints: 3,
      onLevelUp: {},
      head: null,
      weapon: null,
      amulet: null,
      armor: null,
      shield: null,
      glove: null,
      ring: null,
      foot: null,
      iHealth: 0,
      iAttack: 0,
      iDefense: 0,
      iHit: 0,
      iCrit: 0,
      iDodge: 0,
      iVitality: 0,
      iDurability: 0,
      iStrength: 0,
      iAgility: 0,
      bExpToLevel: 100,
      interactItemCount: 0,
      battleRound: 0,
      statIncMessages: []
    };
    return _this;
  }

  _createClass(Hero, [{
    key: "initHero",
    value: function initHero(hero) {
      var char = Object.assign({}, heroTypeStats[hero]),
          bHp = char.health,
          bVit = char.vitality,
          bDur = char.durability,
          conv = statConversion,
          statIncMessages = ["'V'", "'B'", "'N'", "'M'"];

      this.setState({
        statIncMessages: statIncMessages,
        heroName: char.heroName,
        charLevel: 1,
        expToLevel: this.state.bExpToLevel,
        curHealth: bHp + conv.vitToHp * bVit + conv.durToHp * bDur,
        bHealth: bHp,
        bAttack: char.attack,
        bDefense: char.defense,
        bHit: char.hit,
        bCrit: char.crit,
        bDodge: char.dodge,
        bVitality: bVit,
        bDurability: bDur,
        bStrength: char.strength,
        bAgility: char.agility,
        onLevelUp: char.onLevelUp
      });
    }
  }, {
    key: "paintHeroIcon",
    value: function paintHeroIcon(icon) {
      var ctx = document.getElementById('hero-icon').getContext('2d');

      ctx.drawImage(icon, 0, 0);
    }
  }, {
    key: "changeStats",
    value: function changeStats(stats) {
      var decStats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var attr = Object.assign({}, stats),
          decAttr = Object.assign({}, decStats);

      var newState = Object.assign({}, this.state),
          prop = null;

      for (prop in attr) {
        newState[prop] += attr[prop];
      }for (prop in decAttr) {
        newState[prop] -= decAttr[prop];
      }return newState;
    }
  }, {
    key: "gainExperience",
    value: function gainExperience(enemyDead) {
      var _state = this.state,
          charLevel = _state.charLevel,
          experience = _state.experience,
          expToLevel = _state.expToLevel;


      experience += enemyDead.experience;
      this.enemyDeadCount = enemyDead.count;

      if (experience >= expToLevel) {
        experience -= expToLevel;
        charLevel++;
        this.handleLevelUp(charLevel, experience);
      } else {
        this.setState({ experience: experience });
      }
    }
  }, {
    key: "handleLevelUp",
    value: function handleLevelUp(charLevel, experience) {
      var onLvl = this.state.onLevelUp,
          bHealth = this.state.bHealth + onLvl.health,
          bVitality = this.state.bVitality + onLvl.vitality,
          bDurability = this.state.bDurability + onLvl.durability,
          bStrength = this.state.bStrength + onLvl.strength,
          bAgility = this.state.bAgility + onLvl.agility,
          bAttack = this.state.bAttack + onLvl.attack,
          bDefense = this.state.bDefense + onLvl.defense,
          iHealth = this.state.iHealth,
          iVitality = this.state.iVitality,
          iDurability = this.state.iDurability,
          conv = statConversion,
          maxHealth = bHealth + iHealth + conv.vitToHp * (bVitality + iVitality) + conv.durToHp * (bDurability + iDurability),
          expToLevel = ~~(this.state.expToLevel * conv.expLevelMult),
          statPoints = this.state.statPoints + conv.lvlUpSkillPoints;

      this.props.updateGameClassState({ levelUpCount: charLevel });

      this.setState({
        charLevel: charLevel,
        experience: experience,
        expToLevel: expToLevel,
        bHealth: bHealth,
        bAttack: bAttack,
        bDefense: bDefense,
        bVitality: bVitality,
        bDurability: bDurability,
        bStrength: bStrength,
        bAgility: bAgility,
        statPoints: statPoints,
        curHealth: maxHealth
      });
      console.log('Hero Level Up!!: ', charLevel);
    }
  }, {
    key: "attemptPurchase",
    value: function attemptPurchase(item, inventory, merchantInventory, interactItem) {
      var buySuccessType = 'buySuccess',
          buyFailType = 'buyFail';

      var gold = this.state.gold,
          nInteractItem = Object.assign({}, interactItem),
          nState = {};


      if (gold >= item.buy) {
        console.log('Hero Attempt Buy Success');
        nInteractItem.type = buySuccessType;
        gold -= item.buy;
        console.log('merchantInventory[item.name]: ', merchantInventory[item.name]);
        merchantInventory[item.name].count -= 1;
        console.log('inventory[item.name] : ', inventory[item.name]);

        if (inventory[item.name]) {
          inventory[item.name].count += 1;
        } else {
          inventory[item.name] = Object.assign({}, item);
          inventory[item.name].count = 1;
        }
        console.log('inventory[item.name] : ', inventory[item.name]);
        nState = { inventory: inventory };
        this.setState({ gold: gold });
      } else {
        console.log('Hero Attempt Buy Fail');
        nInteractItem.type = buyFailType;
      }

      nInteractItem.count += 1;
      nState['interactItem'] = nInteractItem;

      this.props.updateGameClassState(nState);
    }
  }, {
    key: "sellItem",
    value: function sellItem(item, inventory, merchantInventory, interactItem) {
      var gold = this.state.gold,
          nState = { gold: gold + item.sell };


      if (item.equipped) {
        inventory[item.name].equipped = false;
        nState[item.type] = null;
      }

      inventory[item.name].count -= 1;

      if (merchantInventory[item.name]) {
        merchantInventory[item.name].count += 1;
      } else {
        merchantInventory[item.name] = Object.assign({}, item);
        merchantInventory[item.name].count = 1;
      }

      if (inventory[item.name].count === 0 && inventory[item.name].type !== 'consumable') {
        this.updateEquipCanvas(inventory[item.name]);
      }

      this.setState(nState);
      this.props.updateGameClassState({ inventory: inventory });
      console.log('Hero item sold (inventoryItem, inventory): ', inventory[item.name], inventory);
    }
  }, {
    key: "handleEnemyDead",
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead,
          gold = enemyDead.gold;


      var nState = this.changeStats({ gold: gold });

      this.gainExperience(enemyDead);

      this.setState(nState);
    }
  }, {
    key: "handleInteractItem",
    value: function handleInteractItem(nextProps) {
      var interactItem = nextProps.interactItem,
          action = interactItem.type,
          itemName = interactItem.item.name,
          conv = statConversion;


      var inventory = Object.assign({}, nextProps.inventory),
          merchantInventory = interactItem.source.inventory,
          item = action === 'buy' ? merchantInventory[itemName] : inventory[itemName],
          stats = item.stats,
          iType = item.type,
          updateInventory = false,
          updateCanvas = false,
          curItem = null,
          nState = {},
          maxHp = 0,
          hp = 0,
          vit = 0,
          dur = 0;

      if (action === 'pickup' && item.type === 'gold') nState = this.changeStats(stats);else if (action === 'use') {
        updateInventory = true;
        item.count -= 1;

        nState = this.changeStats(stats);
      } else if (action === 'unequip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];
        inventory[curItem.name].equipped = false;

        nState = this.changeStats({}, curItem.stats);
        nState[iType] = null;
      } else if (action === 'equip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];

        if (curItem) {
          inventory[curItem.name].equipped = false;
          nState = this.changeStats(stats, curItem.stats);
        } else nState = this.changeStats(stats);

        item.equipped = true;
        nState[iType] = item;
      } else if (action === 'buy') {
        console.log('Hero handleInteractItem buy start');
        this.attemptPurchase(item, inventory, merchantInventory, interactItem);
      } else if (action === 'sell') {
        console.log('Hero handleInteractItem sell start');
        this.sellItem(item, inventory, merchantInventory, interactItem);
      }

      if (Object.keys(nState).length) {
        hp = nState.bHealth + nState.iHealth;
        vit = nState.iVitality + nState.bVitality;
        dur = nState.iDurability + nState.bDurability;
        maxHp = hp + conv.vitToHp * vit + conv.durToHp * dur;

        if (nState.curHealth > maxHp) nState.curHealth = maxHp;
        if (updateCanvas) this.updateEquipCanvas(item);
        if (updateInventory) this.props.updateGameClassState({ inventory: inventory });

        this.setState(nState);
      }
    }
  }, {
    key: "handleUseStatPoint",
    value: function handleUseStatPoint(nextProps) {
      var decStats = { statPoints: 1 };

      var increasedStat = Object.assign({}, nextProps.increasedStat),
          stats = {},
          nState = {};

      if (this.state.statPoints > 0) {
        stats[nextProps.useStatPoint.stat] = 1;
        nState = this.changeStats(stats, decStats);

        increasedStat.count++;
        increasedStat.type = 'Increased';
        increasedStat.stat = nextProps.useStatPoint.stat.slice(1);
        increasedStat.quant = 1;

        this.props.updateGameClassState({ increasedStat: increasedStat });
        this.setState(nState);
      }
    }
  }, {
    key: "updateEquipCanvas",
    value: function updateEquipCanvas(item) {
      var palette = this.props.itemPalettes[item.palette],
          loc = item.iconLoc;

      var dCtx = getById(item.type + '-canvas').getContext('2d');

      dCtx.clearRect(0, 0, loc[2], loc[3]);

      if (item.equipped) {
        dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: "handleBattleRound",
    value: function handleBattleRound(nextProps) {
      var enemyAttack = nextProps.enemyAttack,
          eStats = enemyAttack.stats,
          roundCount = enemyAttack.roundCount,
          conv = statConversion,
          hDur = this.state.bDurability + this.state.iDurability,
          hStr = this.state.bStrength + this.state.iStrength,
          hAgi = this.state.bAgility + this.state.iAgility,
          hAtk = this.state.bAttack + this.state.iAttack + conv.strToAtk * hStr,
          hDef = this.state.bDefense + this.state.iDefense + conv.durToDef * hDur + conv.strToDef * hStr,
          hHit = this.state.bHit + this.state.iHit + conv.strToHit * hStr + conv.agiToHit * hAgi,
          hCrit = this.state.bCrit + this.state.iCrit + conv.agiToCrit * hAgi,
          hDodge = this.state.bDodge + this.state.iDodge + conv.durToDodge * hDur + conv.agiToDodge * hAgi,
          eDur = eStats.bDurability,
          eStr = eStats.bStrength,
          eAgi = eStats.bAgility,
          eAtk = eStats.bAttack + conv.strToAtk * eStr,
          eDef = eStats.bDefense + conv.durToDef * eDur + conv.strToDef * eStr,
          eHit = eStats.bHit + conv.strToHit * eStr + conv.agiToHit * eAgi,
          eCrit = eStats.bCrit + conv.agiToCrit * eAgi,
          eDodge = eStats.bDodge + conv.durToDodge * eDur + conv.agiToDodge * eAgi;
      var exchangeAttacks = Object.assign({}, nextProps.exchangeAttacks),
          _state2 = this.state,
          curHealth = _state2.curHealth,
          battleRound = _state2.battleRound,
          spawnIndex = enemyAttack.spawnIndex,
          enemyHealth = eStats.curHealth,
          attacks = [],
          turn = {},
          enemyFirst = false,
          type = '',
          attack = 0,
          defense = 0,
          damage = 0,
          i = 0;


      if (roundCount !== battleRound) {
        if (randInt(0, 100) < hHit - eDodge) {
          for (i = 0; i < hAtk; i++) {
            attack += randInt(conv.atkToHpRange[0], conv.atkToHpRange[1]);
          }for (i = 0; i < eDef; i++) {
            defense += randInt(conv.defToHpRange[0], conv.defToHpRange[1]);
          }damage = attack - defense > 0 ? attack - defense : 0;

          if (randInt(0, 100) < hCrit) type = 'cricital hit', damage *= 2;else type = 'hit';

          turn = { type: type, damage: damage, from: 'hero', to: enemyAttack.source.name };
        } else {
          spawnIndex = -1;
          turn = { from: 'hero', to: enemyAttack.source.name, type: 'miss', damage: 0 };
        }
        attacks.push(turn);
      }

      if (!(attacks.length && eAgi <= hAgi && attacks[0].damage >= enemyHealth)) {
        if (randInt(0, 100) < eHit - hDodge) {
          attack = 0, defense = 0;

          for (i = 0; i < eAtk; i++) {
            attack += randInt(conv.atkToHpRange[0], conv.atkToHpRange[1]);
          }for (i = 0; i < hDef; i++) {
            defense += randInt(conv.defToHpRange[0], conv.defToHpRange[1]);
          }damage = attack - defense > 0 ? attack - defense : 0;

          if (randInt(0, 100) < eCrit) type = 'cricital hit', damage *= 2;else type = 'hit';

          turn = { type: type, damage: damage, from: enemyAttack.source.name, to: 'hero' };
        } else {
          damage = 0;
          turn = { damage: damage, from: enemyAttack.source.name, to: 'hero', type: 'miss' };
        }
        curHealth -= turn.damage;

        if (eAgi <= hAgi) attacks.push(turn);else enemyFirst = true, attacks.unshift(turn);
      }

      if (enemyFirst && curHealth <= 0 && attacks.length === 2) {
        attacks.length = 1;
        spawnIndex = -1;
      }

      if (battleRound < roundCount) battleRound = roundCount;
      exchangeAttacks.count++;
      exchangeAttacks.spawnIndex = spawnIndex;
      exchangeAttacks.attacks = attacks;

      this.setState({ curHealth: curHealth, battleRound: battleRound });
      nextProps.updateGameClassState({ exchangeAttacks: exchangeAttacks });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.state.heroName === "" && nextProps.hero) {
        this.initHero(nextProps.hero);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count) {

        console.log('interactItem', nextProps.interactItem);
        console.log(nextProps.interactItem.type, nextProps.interactItem.item.name);

        this.handleInteractItem(nextProps);
      }
      if (this.props.enemyAttack.count !== nextProps.enemyAttack.count) {
        this.handleBattleRound(nextProps);
      }
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
        //DELETE: this.gainExperience(nextProps);
      }
      if (this.props.useStatPoint.count !== nextProps.useStatPoint.count) {
        this.handleUseStatPoint(nextProps);
      }
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.props.heroIcon !== nextProps.heroIcon && nextProps.heroIcon) {
        this.paintHeroIcon(nextProps.heroIcon);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.curHealth <= 0) {
        this.props.updateGameClassState({ gameOver: true });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var ts = this.props.tileSize,
          none = 'None',
          statIncMessages = this.state.statIncMessages,
          conv = statConversion,
          lvl = this.state.charLevel,
          curHp = this.state.curHealth,
          gold = this.state.gold,
          stat = this.state.statPoints,
          exp = this.state.experience,
          expToLvl = this.state.expToLevel,
          vit = this.state.bVitality + this.state.iVitality,
          dur = this.state.bDurability + this.state.iDurability,
          str = this.state.bStrength + this.state.iStrength,
          agi = this.state.bAgility + this.state.iAgility,
          atk = this.state.bAttack + this.state.iAttack + conv.strToAtk * str,
          def = this.state.bDefense + this.state.iDefense + conv.durToDef * dur + conv.strToDef * str,
          maxHp = this.state.bHealth + this.state.iHealth + conv.vitToHp * vit + conv.durToHp * dur,
          statIcon = stat ? 'stat-icon icon-plus-squared' : '',
          hed = this.state.head ? this.state.head.name : none,
          wep = this.state.weapon ? this.state.weapon.name : none,
          amu = this.state.amulet ? this.state.amulet.name : none,
          bod = this.state.armor ? this.state.armor.name : none,
          shd = this.state.shield ? this.state.shield.name : none,
          glv = this.state.glove ? this.state.glove.name : none,
          rng = this.state.ring ? this.state.ring.name : none,
          ft = this.state.foot ? this.state.foot.name : none;

      return React.createElement(
        "div",
        { className: "hero" },
        React.createElement(
          "p",
          { className: "hero-heading" },
          "Character Info"
        ),
        React.createElement(
          "div",
          { className: "hero-type" },
          React.createElement("canvas", { id: "hero-icon", className: "hero-icon", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Name: ",
              this.state.heroName
            ),
            React.createElement(
              "p",
              null,
              "Type: ",
              this.props.hero
            )
          )
        ),
        React.createElement(
          "div",
          { className: "stat-container" },
          React.createElement(
            "p",
            { className: "stat-row" },
            "Level: ",
            lvl
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Health: ",
            curHp,
            "/",
            maxHp
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Gold: ",
            gold
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Stat: ",
            stat
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Exp: ",
            exp,
            "/",
            expToLvl
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Atk: ",
            atk
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Def: ",
            def
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Vit: ",
            vit,
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[0] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Dur: ",
            dur,
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[1] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Str: ",
            str,
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[2] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Agi: ",
            agi,
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[3] : null
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "head-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Head"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              hed
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "weapon-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Weapon"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              wep
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "amulet-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Amulet"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              amu
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "armor-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Armor"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              bod
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "shield-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Shield"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              shd
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "glove-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Glove"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              glv
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "ring-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Ring"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              rng
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "foot-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Foot"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              ft
            )
          )
        )
      );
    }
  }]);

  return Hero;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: inventory, interactItem, updateGameClassState
var InventoryOverlay = function (_React$Component) {
  _inherits(InventoryOverlay, _React$Component);

  function InventoryOverlay(props) {
    _classCallCheck(this, InventoryOverlay);

    var _this = _possibleConstructorReturn(this, (InventoryOverlay.__proto__ || Object.getPrototypeOf(InventoryOverlay)).call(this, props));

    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.updateOptFocus = _this.updateOptFocus.bind(_this);
    _this.setList = _this.setList.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);

    _this.state = {
      invCategories: ['Head', 'Amulet', 'Weapon', 'Armor', 'Shield', 'Glove', 'Ring', 'Foot', 'Consumable'],
      bRowId: 'item-row',
      bColId: 'item-col',
      focusClass: 'optFocus',
      row: 0,
      col: 0
    };
    return _this;
  }

  _createClass(InventoryOverlay, [{
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code,
          cats = this.state.invCategories,
          len = cats.length;

      var _state = this.state,
          row = _state.row,
          col = _state.col,
          delta = [];


      if ((el === 'ArrowUp' || el === 'KeyW') && row > 0) delta = [-1, 0];else if ((el === 'ArrowRight' || el === 'KeyD') && col < len - 1) delta = [0, 1];else if (el === 'ArrowDown' || el === 'KeyS') delta = [1, 0];else if ((el === 'ArrowLeft' || el === 'KeyA') && col > 0) delta = [0, -1];else if (el === 'KeyI' || el === 'KeyE' || el === 'Escape') this.props.updateGameClassState({ overlayMode: 'off' });else if ((el === 'Space' || el === 'Enter') && getById(this.state.bRowId + this.state.row)) {
        var name = getById(this.state.bRowId + row).querySelectorAll('span')[1].innerText,
            type = this.state.invCategories[this.state.col].toLowerCase();

        this.handleInteractItem(name);
      }

      if (delta.length > 0) this.updateOptFocus([row, col], delta);
    }
  }, {
    key: 'updateOptFocus',
    value: function updateOptFocus(coordsArr) {
      var deltaArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var bIds = [this.state.bRowId, this.state.bColId];

      var update = false,
          nextVal = '',
          nState = {};

      if (deltaArr[1] !== 0) {
        nState['row'] = 0;
        nextVal = coordsArr[1] + deltaArr[1];

        if (getById(bIds[1] + nextVal)) nState['col'] = nextVal;
      } else {
        nextVal = coordsArr[0] + deltaArr[0];

        if (getById(bIds[0] + nextVal)) nState['row'] = nextVal;
      }

      if (nState.hasOwnProperty('row')) {
        update = true;
        this.setState(nState);
      }

      return update;
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'setList',
    value: function setList(inv, header) {
      var conv = statConvertWordMap;

      var list = [],
          props = null,
          p = null,
          el = null,
          equipped = '',
          stats = '';

      for (props in inv) {
        if (inv[props].type === header && inv[props].count > 0) {
          el = inv[props];
          stats = '';

          for (p in el.stats) {
            stats += '' + conv[p] + el.stats[p] + ' ';
          }if (el.type === 'consumable') list.push([el.count, el.name, stats]);else equipped = el.equipped ? 'E' : ' ', list.push([equipped, el.name, stats]);
        }
      }
      return list;
    }
  }, {
    key: 'setItems',
    value: function setItems(list, colNames, bRowId) {
      var _this2 = this;

      var row = this.state.row;

      var classes = '';

      return [].concat(_toConsumableArray(Array(list.length))).map(function (x, i) {
        classes = i === row ? bRowId + ' ' + _this2.state.focusClass : bRowId;
        return React.createElement(
          'div',
          { id: bRowId + i, className: classes, key: list[i][1] },
          React.createElement(
            'span',
            { className: colNames[0].toLowerCase() + '-col', key: list[i][0] },
            list[i][0]
          ),
          React.createElement(
            'span',
            { className: colNames[1].toLowerCase() + '-col', key: list[i][1] + '-col' },
            list[i][1]
          ),
          React.createElement(
            'span',
            { className: colNames[2].toLowerCase() + '-col', key: list[i][2] },
            list[i][2]
          )
        );
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(name) {
      var item = this.props.inventory[name],
          cats = this.state.invCategories;

      var interactItem = Object.assign({}, this.props.interactItem),
          action = '';

      action = item.type === cats[cats.length - 1].toLowerCase() ? 'use' : item.equipped ? 'unequip' : 'equip';

      interactItem.count += 1;
      interactItem.type = action;
      interactItem.item = item;

      this.props.updateGameClassState({ interactItem: interactItem });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this3.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var cats = [].concat(_toConsumableArray(this.state.invCategories)),
          _state2 = this.state,
          row = _state2.row,
          col = _state2.col,
          bRowId = _state2.bRowId,
          bColId = _state2.bColId,
          focusClass = _state2.focusClass,
          header = cats[col].toLowerCase(),
          inv = this.props.inventory,
          abbrev = equipAbbrevMap;


      var colHeaders = null,
          iHeaders = null,
          items = null,
          classes = '';

      var colNames = header === 'consumable' ? ['Quantity', 'Name', 'Stats'] : ['Equipped', 'Name', 'Stats'];

      var list = this.setList(inv, header);

      colHeaders = cats.map(function (x, i) {
        classes = i === col ? bColId + ' ' + focusClass : bColId;
        return React.createElement(
          'span',
          { id: bColId + i, className: classes, key: x },
          abbrev[x]
        );
      });

      iHeaders = [].concat(_toConsumableArray(Array(colNames.length))).map(function (x, i) {
        return React.createElement(
          'span',
          { className: 'item-header item-header-' + i, key: colNames[i] },
          colNames[i]
        );
      });

      items = this.setItems(list, colNames, bRowId);

      return React.createElement(
        'div',
        { id: 'inv-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'inv-header' },
          'Inventory'
        ),
        React.createElement(
          'div',
          { className: 'inv-categories' },
          colHeaders
        ),
        React.createElement(
          'div',
          { className: 'item-list' },
          React.createElement(
            'div',
            { className: 'iheader-row' },
            iHeaders
          ),
          items
        )
      );
    }
  }]);

  return InventoryOverlay;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, stageSize, tileSize, gameLevel, levels, bgArr, itemArr, updateGameClassState
//playerArr, itemPalettes, floorCoords, itemPaletteArrMap, enemyDead, bgLevelProcessed
var ItemLayer = function (_React$Component) {
  _inherits(ItemLayer, _React$Component);

  function ItemLayer(props) {
    _classCallCheck(this, ItemLayer);

    var _this = _possibleConstructorReturn(this, (ItemLayer.__proto__ || Object.getPrototypeOf(ItemLayer)).call(this, props));

    _this.initItemArr = _this.initItemArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getItemImages = _this.getItemImages.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setSpawnQuants = _this.setSpawnQuants.bind(_this);
    _this.setItemArr = _this.setItemArr.bind(_this);
    _this.activatePortal = _this.activatePortal.bind(_this);
    _this.drawItems = _this.drawItems.bind(_this);

    _this.enemyDeadCount = 0;
    _this.levelProcessed = 0;

    _this.state = {
      srcTileSize: 16,
      itemTypes: [],
      images: {},
      spawnQuants: [],
      tempCanv: null,
      portalCoord: []
    };
    return _this;
  }

  _createClass(ItemLayer, [{
    key: 'initItemArr',
    value: function initItemArr() {
      var len = this.props.boardSize,
          itemArr = initZeroArray(len);

      this.props.updateGameClassState({ itemArr: itemArr });
    }
  }, {
    key: 'getItemImages',
    value: function getItemImages() {
      var path = 'img/items/',
          type = '.png',
          that = this;

      var amuletImg = void 0,
          armorImg = void 0,
          bookImg = void 0,
          bootImg = void 0,
          chest0Img = void 0,
          chest1Img = void 0,
          door0Img = void 0,
          door1Img = void 0,
          gloveImg = void 0,
          hatImg = void 0,
          longWepImg = void 0,
          medWepImg = void 0,
          moneyImg = void 0,
          potionImg = void 0,
          ringImg = void 0,
          shieldImg = void 0,
          shortWepImg = void 0,
          wandImg = void 0,
          images = {
        amuletImg: amuletImg,
        armorImg: armorImg,
        bookImg: bookImg,
        bootImg: bootImg,
        chest0Img: chest0Img,
        chest1Img: chest1Img,
        door0Img: door0Img,
        door1Img: door1Img,
        gloveImg: gloveImg,
        hatImg: hatImg,
        longWepImg: longWepImg,
        medWepImg: medWepImg,
        moneyImg: moneyImg,
        potionImg: potionImg,
        ringImg: ringImg,
        shieldImg: shieldImg,
        shortWepImg: shortWepImg,
        wandImg: wandImg
      },
          el = void 0,
          iLen = 0,
          i = 0;

      var handleItemLoad = function handleItemImageLoad() {
        i++;
        if (i === iLen) {
          that.setState({ images: images });
          that.setPalettes(images);
        }
      };

      for (el in images) {
        images[el] = new Image();
        images[el].src = path + el[0].toUpperCase() + el.slice(1, -3) + type;
        images[el].addEventListener('load', handleItemLoad);
        iLen++;
      }
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var size = this.props.stageSize,
          smoothRender = false,
          tempCanv = initMemCanvas(size, size, smoothRender);

      this.setState({ tempCanv: tempCanv });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var ts = this.props.tileSize,
          srcTs = this.state.srcTileSize,
          scale = ts / srcTs,
          renderSmoothing = false,
          imgPixDataName = 'imgPixData';

      var itemPalettes = {},
          p = null,
          el = null,
          ctx = null,
          img = null,
          name = '',
          w = 0,
          h = 0;

      for (el in images) {
        img = images[el];
        name = el.slice(0, -3) + 'Palette';
        w = img.width;
        h = img.height;
        p = itemPalettes;
        p[name] = document.createElement('canvas');
        p[name].width = scale * w;
        p[name].height = scale * h;
        ctx = p[name].getContext('2d');
        ctx.imageSmoothingEnabled = renderSmoothing;
        ctx.drawImage(img, 0, 0, w, h, 0, 0, p[name].width, p[name].height);
        p[name][imgPixDataName] = ctx.getImageData(0, 0, p[name].width, p[name].height).data;
      }

      this.props.updateGameClassState({ itemPalettes: itemPalettes });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap() {
      var itemTypes = [itemAmulets, itemArmors, itemFeet, itemGloves, itemHelmets, itemRings, itemShields, itemWeapons, itemConsumables, chestConsumables, interactivePortals];

      var itemPaletteArrMap = {},
          i = 101,
          props = null;

      itemTypes.forEach(function (el) {
        for (props in el) {
          el[props]['itemArrVal'] = i;
          itemPaletteArrMap['' + i] = el[props];
          i++;
        }
      });

      this.setSpawnQuants(itemTypes);
      this.setState({ itemTypes: itemTypes });
      this.props.updateGameClassState({ itemPaletteArrMap: itemPaletteArrMap });
    }
  }, {
    key: 'setSpawnQuants',
    value: function setSpawnQuants(itemTypes) {
      var levels = this.props.levels,
          valKey = 'itemArrVal';

      var spawnQuants = [],
          item = [],
          spawnObj = {},
          props = null,
          lvl = 0,
          val = 0,
          i = 0;

      spawnQuants.length = levels;
      while (i < levels) {
        spawnQuants[i] = [], i++;
      }itemTypes.forEach(function (el) {
        for (props in el) {
          spawnObj = el[props];
          val = spawnObj[valKey];
          for (lvl in spawnObj.spawnQuant) {
            item = [val, spawnObj.spawnQuant[lvl]];
            spawnQuants[lvl * 1 - 1].push(item);
          }
        }
      });

      this.setState({ spawnQuants: spawnQuants });
    }
  }, {
    key: 'setItemArr',
    value: function setItemArr(nextProps, nextState) {
      var spawnQuants = nextState.spawnQuants,
          gameLevel = nextProps.gameLevel,
          bgArr = nextProps.bgArr,
          topCenterFloorVal = 42;


      var itemArr = [].concat(_toConsumableArray(nextProps.itemArr)),
          floorCoords = [].concat(_toConsumableArray(nextProps.floorCoords)),
          len = itemArr.length,
          fLen = floorCoords.length,
          coord = [],
          index = 0,
          cur = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          itemArr[i][j] = 0, j++;
        }j = 0, i++;
      }

      spawnQuants[gameLevel - 1].forEach(function (el) {
        for (i = 0; i < el[1]; i++) {
          index = randInt(0, fLen);
          coord = floorCoords[index];
          itemArr[coord[0]][coord[1]] = el[0];
          floorCoords.splice(index, 1);
          fLen--;
        }
      });

      while (cur !== topCenterFloorVal) {
        index = randInt(0, fLen);
        coord = floorCoords[index];
        cur = bgArr[coord[0]][coord[1]];
      }

      coord[0]--;
      itemArr[coord[0]][coord[1]] = interactivePortals['inactivePortal'].itemArrVal;

      this.setState({ portalCoord: coord });
      this.props.updateGameClassState({ floorCoords: floorCoords, itemArr: itemArr });
    }
  }, {
    key: 'activatePortal',
    value: function activatePortal() {
      var portalCoord = this.state.portalCoord,
          activePortal = interactivePortals['activePortal'];


      var itemArr = [].concat(_toConsumableArray(this.props.itemArr));

      itemArr[portalCoord[0]][portalCoord[1]] = activePortal.itemArrVal;

      this.props.updateGameClassState({ itemArr: itemArr });

      console.log('Potal Activated');
    }
  }, {
    key: 'drawItems',
    value: function drawItems(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var pIndex = (timestamp - timeRef) % 1000 * .06 > 29 ? 1 : 0,
          _props = this.props,
          itemArr = _props.itemArr,
          playerArr = _props.playerArr,
          itemPaletteArrMap = _props.itemPaletteArrMap,
          itemPalettes = _props.itemPalettes,
          ts = this.props.tileSize,
          px = this.props.stageSize,
          iLen = itemArr.length,
          rLen = px / ts,
          displayedItems = ['consumable', 'gold', 'openChest', 'door'];


      var dCtx = document.getElementById('item-layer').getContext('2d'),
          tempCanv = this.state.tempCanv,
          tempCtx = tempCanv.getContext('2d'),
          tImgData = tempCtx.createImageData(px, px),
          tImgPixData = tImgData.data,
          renderArr = [],
          iData = 0,
          pData = 0,
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          palette = null,
          img = null,
          imgW = 0,
          m = [],
          el = 0,
          srcX = 0,
          srcY = 0,
          dX = 0,
          dY = 0,
          h = 0,
          w = 0,
          i = 0,
          j = 0;

      //Use helper functions if performance is acceptable
      //const padding = calcRenderPadding(playerArr, iLen, rLen);
      //const renderArr = setRenderArr(itemArr, rLen, padding);

      if (playerArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (playerArr[0] - ~~(rLen / 2));
      } else if (playerArr[0] + ~~(rLen / 2) + 1 > iLen) {
        pr = playerArr[0] + ~~(rLen / 2) + 1 - iLen;
        sr = iLen - rLen + pr;
      } else {
        sr = playerArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (playerArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (playerArr[1] - ~~(rLen / 2));
      } else if (playerArr[1] + ~~(rLen / 2) + 1 > iLen) {
        pc = playerArr[1] + ~~(rLen / 2) + 1 - iLen;
        sc = iLen - rLen + pc;
      } else {
        sc = playerArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = itemArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el) {
            m = displayedItems.includes(itemPaletteArrMap['' + el].type) ? itemPaletteArrMap['' + el] : chestConsumables.closedChest;
            palette = m.type === 'door' ? m.palette[pIndex] : m.palette;
            img = itemPalettes[palette].imgPixData;
            imgW = itemPalettes[palette].width;
            srcX = m.iconLoc[0];
            srcY = m.iconLoc[1];
            dX = sx + j * ts;
            dY = sy + i * ts;
            h = 0;

            while (h < ts) {
              w = 0;
              while (w < ts) {
                pData = (dX + w + (dY + h) * px) * 4;
                iData = (srcX + w + (srcY + h) * imgW) * 4;

                tImgPixData[pData] = img[iData];
                tImgPixData[pData + 1] = img[iData + 1];
                tImgPixData[pData + 2] = img[iData + 2];
                tImgPixData[pData + 3] = img[iData + 3];
                w++;
              }
              h++;
            }
          }
        }
      }

      dCtx.putImageData(tImgData, 0, 0);

      window.requestAnimationFrame(this.drawItems);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getItemImages();
      this.initItemArr();
      this.initTempCanvas();
      this.setPaletteArrMap();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.levelProcessed !== nextProps.bgLevelProcessed) {
        console.log('New Item Array');

        this.levelProcessed = nextProps.bgLevelProcessed;
        this.setItemArr(nextProps, nextState);
      }

      if (nextProps.enemyDead.count !== this.enemyDeadCount) {
        this.enemyDeadCount = nextProps.enemyDead.count;
        if (nextProps.enemyDead.source.boss) this.activatePortal();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (Object.keys(prevProps.itemPalettes).length !== Object.keys(this.props.itemPalettes).length && Object.keys(this.props.itemPalettes).length) {

        window.requestAnimationFrame(this.drawItems);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'item-layer',
        className: 'item-layer',
        width: size,
        height: size });
    }
  }]);

  return ItemLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: playerArr, enemyArr, inventory, interactItem, overlayMode, updateGameClassState
var OptionOverlay = function (_React$Component) {
  _inherits(OptionOverlay, _React$Component);

  function OptionOverlay() {
    _classCallCheck(this, OptionOverlay);

    return _possibleConstructorReturn(this, (OptionOverlay.__proto__ || Object.getPrototypeOf(OptionOverlay)).apply(this, arguments));
  }

  _createClass(OptionOverlay, [{
    key: 'render',
    value: function render() {
      var mode = this.props.overlayMode;

      var content = null;

      if (mode === 'inv-overlay') {
        content = React.createElement(InventoryOverlay, {
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'merchant-overlay') {
        content = React.createElement(OverlayMerchant, {
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          updateGameClassState: this.props.updateGameClassState });
      }

      return React.createElement(
        'div',
        null,
        content
      );
    }
  }]);

  return OptionOverlay;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: playerArr, enemyArr, inventory, interactItem, updateGameClassState


var OverlayMerchant = function (_React$Component) {
  _inherits(OverlayMerchant, _React$Component);

  function OverlayMerchant(props) {
    _classCallCheck(this, OverlayMerchant);

    var _this = _possibleConstructorReturn(this, (OverlayMerchant.__proto__ || Object.getPrototypeOf(OverlayMerchant)).call(this, props));

    _this.setSource = _this.setSource.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.updateOptFocus = _this.updateOptFocus.bind(_this);
    _this.setList = _this.setList.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);

    _this.state = {
      source: {},
      interactCategories: ['Buy', 'Sell'],
      invCategories: ['Head', 'Amulet', 'Weapon', 'Armor', 'Shield', 'Glove', 'Ring', 'Foot', 'Consumable'],
      colNames: ['Quant/Buy/Sell', 'Name', 'Stats'],
      bInteractId: 'interact-type',
      bRowId: 'item-row',
      bColId: 'item-col',
      focusClass: 'optFocus',
      interactCategory: 'Buy',
      row: 0,
      col: 0
    };
    return _this;
  }

  _createClass(OverlayMerchant, [{
    key: 'setSource',
    value: function setSource() {
      var _props = this.props,
          playerArr = _props.playerArr,
          enemyArr = _props.enemyArr;


      var curEnemy = {},
          source = {};

      [[playerArr[0] - 1, playerArr[1]], [playerArr[0], playerArr[1] + 1], [playerArr[0] + 1, playerArr[1]], [playerArr[0], playerArr[1] - 1]].forEach(function (coord) {
        curEnemy = enemyArr[coord[0]][coord[1]];
        if (curEnemy && curEnemy.type === 'merchant') {
          source = curEnemy;
          console.log('Found Merchant ', source);
        }
      });
      this.setState({ source: source });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code,
          cats = this.state.invCategories,
          len = cats.length;

      var _state = this.state,
          row = _state.row,
          col = _state.col,
          interactCategories = _state.interactCategories,
          interactCategory = _state.interactCategory,
          delta = [];


      if ((el === 'ArrowUp' || el === 'KeyW') && row > 0) delta = [-1, 0];else if ((el === 'ArrowRight' || el === 'KeyD') && col < len - 1) delta = [0, 1];else if (el === 'ArrowDown' || el === 'KeyS') delta = [1, 0];else if ((el === 'ArrowLeft' || el === 'KeyA') && col > 0) delta = [0, -1];else if (el === 'KeyY' && interactCategory !== interactCategories[0]) {
        this.setState({ row: 0, interactCategory: interactCategories[0] });
      } else if (el === 'KeyU' && interactCategory !== interactCategories[1]) {
        this.setState({ row: 0, interactCategory: interactCategories[1] });
      } else if (el === 'KeyI' || el === 'KeyE' || el === 'Escape') this.props.updateGameClassState({ overlayMode: 'off' });else if ((el === 'Space' || el === 'Enter') && getById(this.state.bRowId + this.state.row)) {
        var name = getById(this.state.bRowId + row).querySelectorAll('span')[1].id,
            type = this.state.invCategories[this.state.col].toLowerCase();

        this.handleInteractItem(name);
      }

      if (delta.length > 0) this.updateOptFocus([row, col], delta);
    }
  }, {
    key: 'updateOptFocus',
    value: function updateOptFocus(coordsArr) {
      var deltaArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var bIds = [this.state.bRowId, this.state.bColId];

      var update = false,
          nextVal = '',
          nState = {};

      if (deltaArr[1] !== 0) {
        nState['row'] = 0;
        nextVal = coordsArr[1] + deltaArr[1];

        if (getById(bIds[1] + nextVal)) nState['col'] = nextVal;
      } else {
        nextVal = coordsArr[0] + deltaArr[0];

        if (getById(bIds[0] + nextVal)) nState['row'] = nextVal;
      }

      if (nState.hasOwnProperty('row')) {
        update = true;
        this.setState(nState);
      }

      return update;
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'setList',
    value: function setList(inv, header) {
      var conv = statConvertWordMap;

      var list = [],
          props = null,
          p = null,
          el = null,
          stats = '',
          quantBuySell = '';

      for (props in inv) {
        if (inv[props].type === header && inv[props].count > 0) {
          el = inv[props];
          quantBuySell = el.count + '/' + el.buy + '/' + el.sell;
          stats = '';

          for (p in el.stats) {
            stats += '' + conv[p] + el.stats[p] + ' ';
          }list.push([quantBuySell, el.name, stats, props]);
        }
      }
      return list;
    }
  }, {
    key: 'setItems',
    value: function setItems(list, colNames, bRowId) {
      var _this2 = this;

      var row = this.state.row;

      var classes = '';

      return [].concat(_toConsumableArray(Array(list.length))).map(function (x, i) {
        classes = i === row ? bRowId + ' ' + _this2.state.focusClass : bRowId;
        return React.createElement(
          'div',
          { id: bRowId + i, className: classes, key: list[i][1] },
          React.createElement(
            'span',
            {
              className: colNames[0].toLowerCase().replace(/\//g, '-') + '-col',
              key: list[i][0] + i },
            list[i][0]
          ),
          React.createElement(
            'span',
            {
              id: list[i][3],
              className: colNames[1].toLowerCase() + '-col',
              key: list[i][1] + '-col' },
            list[i][1]
          ),
          React.createElement(
            'span',
            { className: colNames[2].toLowerCase() + '-col', key: list[i][2] + i },
            list[i][2]
          )
        );
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(name) {
      var _state2 = this.state,
          interactCategories = _state2.interactCategories,
          interactCategory = _state2.interactCategory,
          source = _state2.source;


      var interactItem = Object.assign({}, this.props.interactItem),
          item = {},
          action = '';

      if (interactCategory === interactCategories[0]) {
        action = interactCategories[0].toLowerCase();
        item = source.inventory[name];
      } else {
        action = interactCategories[1].toLowerCase();
        item = this.props.inventory[name];
      }

      console.log('OverlayMerchant handleInteractItem name, item: ', name, item);

      interactItem.count += 1;
      interactItem.type = action;
      interactItem.item = item;
      interactItem.source = source;

      this.props.updateGameClassState({ interactItem: interactItem });
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.setSource();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this3.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var cats = [].concat(_toConsumableArray(this.state.invCategories)),
          _state3 = this.state,
          row = _state3.row,
          col = _state3.col,
          bInteractId = _state3.bInteractId,
          bRowId = _state3.bRowId,
          bColId = _state3.bColId,
          focusClass = _state3.focusClass,
          interactCategories = _state3.interactCategories,
          interactCategory = _state3.interactCategory,
          colNames = _state3.colNames,
          source = _state3.source,
          header = cats[col].toLowerCase(),
          inv = interactCategory === interactCategories[0] ? source.inventory : this.props.inventory,
          abbrev = equipAbbrevMap;


      var interactHeaders = null,
          colHeaders = null,
          iHeaders = null,
          items = null,
          classes = '';

      var list = this.setList(inv, header);

      interactHeaders = interactCategories.map(function (x, i) {
        classes = x === interactCategory ? bInteractId + ' ' + focusClass : bInteractId;
        return React.createElement(
          'span',
          { className: classes, key: x + i },
          x
        );
      });

      colHeaders = cats.map(function (x, i) {
        classes = i === col ? bColId + ' ' + focusClass : bColId;
        return React.createElement(
          'span',
          { id: bColId + i, className: classes, key: x },
          abbrev[x]
        );
      });

      iHeaders = [].concat(_toConsumableArray(Array(colNames.length))).map(function (x, i) {
        return React.createElement(
          'span',
          { className: 'item-header item-header-' + i, key: colNames[i] },
          colNames[i]
        );
      });

      items = this.setItems(list, colNames, bRowId);

      return React.createElement(
        'div',
        { id: 'merchant-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'merchant-header' },
          interactHeaders
        ),
        React.createElement(
          'div',
          { className: 'inv-categories' },
          colHeaders
        ),
        React.createElement(
          'div',
          { className: 'item-list' },
          React.createElement(
            'div',
            { className: 'iheader-row' },
            iHeaders
          ),
          items
        )
      );
    }
  }]);

  return OverlayMerchant;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, tileSize, hero, heroFacing, gameLevel, bgArr, playerArr, updateGameClassState,
//floorCoords, bgLevelProcessed
var PlayerLayer = function (_React$Component) {
  _inherits(PlayerLayer, _React$Component);

  function PlayerLayer(props) {
    _classCallCheck(this, PlayerLayer);

    var _this = _possibleConstructorReturn(this, (PlayerLayer.__proto__ || Object.getPrototypeOf(PlayerLayer)).call(this, props));

    _this.getPlayerImages = _this.getPlayerImages.bind(_this);
    _this.initPaletteMap = _this.initPaletteMap.bind(_this);
    _this.setPalette = _this.setPalette.bind(_this);
    _this.setHeroIcon = _this.setHeroIcon.bind(_this);
    _this.pickPlayerStart = _this.pickPlayerStart.bind(_this);
    _this.drawPlayer = _this.drawPlayer.bind(_this);

    _this.state = {
      srcTileSize: 16,
      mageImg: null,
      rogueImg: null,
      paladinImg: null,
      warriorImg: null,
      playerPalette: null,
      playerPaletteMap: {}
    };
    return _this;
  }

  _createClass(PlayerLayer, [{
    key: 'getPlayerImages',
    value: function getPlayerImages() {
      var mageImg = new Image(),
          rogueImg = new Image(),
          paladinImg = new Image(),
          warriorImg = new Image(),
          that = this;

      var i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 4) {
          that.setState({ mageImg: mageImg, rogueImg: rogueImg, paladinImg: paladinImg, warriorImg: warriorImg });

          //temporary palette assignment until start screen is created
          that.setPalette(that.props);
        }
      };

      mageImg.src = 'img/heroes/Mage.png';
      rogueImg.src = 'img/heroes/Rogue.png';
      paladinImg.src = 'img/heroes/Paladin.png';
      warriorImg.src = 'img/heroes/Warrior.png';
      mageImg.addEventListener('load', handleLoad);
      rogueImg.addEventListener('load', handleLoad);
      paladinImg.addEventListener('load', handleLoad);
      warriorImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'initPaletteMap',
    value: function initPaletteMap() {
      var ts = this.props.tileSize,
          w = 4;

      var playerPaletteMap = {},
          j = 0;

      ['down', 'left', 'right', 'up'].forEach(function (el, i) {
        for (j = 0; j < w; j++) {
          playerPaletteMap[el + (j + 1)] = [i * ts, j * ts];
        }
      });

      this.setState({ playerPaletteMap: playerPaletteMap });
    }
  }, {
    key: 'setPalette',
    value: function setPalette(nextProps) {
      var hero = nextProps.hero.toLowerCase(),
          srcImg = this.state[hero + 'Img'],
          srcTS = this.state.srcTileSize,
          gmTS = nextProps.tileSize,
          scale = gmTS / srcTS,
          w = 4 * gmTS,
          h = 4 * gmTS;

      var canvas = document.createElement('canvas'),
          ctx = null;

      canvas.width = w;
      canvas.height = h;
      ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(srcImg, 0, 0, w / scale, h / scale, 0, 0, w, h);

      this.setState({ playerPalette: { canvas: canvas, ctx: ctx } }, this.setHeroIcon(canvas));
    }
  }, {
    key: 'setHeroIcon',
    value: function setHeroIcon(canvas) {
      var w = this.props.tileSize,
          h = w;

      var heroIcon = document.createElement('canvas'),
          hCtx = null;

      heroIcon.width = w;
      heroIcon.height = h;
      hCtx = heroIcon.getContext('2d');
      hCtx.imageSmoothingEnabled = false;
      hCtx.drawImage(canvas, 0, 0, w, h, 0, 0, w, h);
      this.props.updateGameClassState({ heroIcon: heroIcon });
    }
  }, {
    key: 'pickPlayerStart',
    value: function pickPlayerStart(nextProps) {
      var playerArr = nextProps.floorCoords[randInt(0, nextProps.floorCoords.length - 1)];
      nextProps.updateGameClassState({ playerArr: playerArr });
    }
  }, {
    key: 'drawPlayer',
    value: function drawPlayer(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var img = this.state.playerPalette.canvas,
          imgD = this.props.tileSize,
          dir = this.props.heroFacing,
          dx = (this.props.stageSize - imgD) / 2,
          dy = dx,
          srcY = dir === 'down' ? 0 : dir === 'left' ? 1 : dir === 'right' ? 2 : 3,
          frameStep = Math.floor((timestamp - timeRef) % 1000 * .06 / 15);

      var canvas = document.getElementById('player-layer'),
          ctx = canvas.getContext('2d');

      ctx.clearRect(dx, dy, imgD, imgD);
      ctx.drawImage(img, frameStep * imgD, srcY * imgD, imgD, imgD, dx, dy, imgD, imgD);
      window.requestAnimationFrame(this.drawPlayer);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getPlayerImages();
      this.initPaletteMap();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.bgLevelProcessed !== nextProps.bgLevelProcessed) {
        console.log('New Player Start');
        this.pickPlayerStart(nextProps);
      }
      /*
      if (!this.state.playerPalette && nextProps.hero && this.state.mageImg) {
        this.setPalette(nextProps);
      }
      */
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.playerPalette !== this.state.playerPalette) {
        window.requestAnimationFrame(this.drawPlayer);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'player-layer',
        className: 'player-layer',
        width: size,
        height: size });
    }
  }]);

  return PlayerLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var roomSize = {
  '4': { min: 16, max: 30 },
  '6': { min: 14, max: 20 },
  '8': { min: 11, max: 15 }
};

/**
  * React Components
  */

var Game = function (_React$Component) {
  _inherits(Game, _React$Component);

  function Game(props) {
    _classCallCheck(this, Game);

    var _this = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this, props));

    _this.updateBgArr = _this.updateBgArr.bind(_this);
    _this.handleKeyDown = _this.handleKeyDown.bind(_this);
    _this.updatePlayerArr = _this.updatePlayerArr.bind(_this);
    _this.updateGameClassState = _this.updateGameClassState.bind(_this);
    _this.pickupItem = _this.pickupItem.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.maintainFocus = _this.maintainFocus.bind(_this);
    _this.endFocus = _this.endFocus.bind(_this);
    _this.handleGameOver = _this.handleGameOver.bind(_this);

    _this.state = {
      boardSize: 120,
      tileSize: 32,
      wall: 20,
      floor: 40,
      gameLevel: 1,
      bgLevelProcessed: 0,
      levels: 10,
      hero: 'Warrior',
      heroIcon: null,
      heroFacing: '',
      moveCount: 0,
      levelUpCount: 1,
      gameOver: false,
      inventory: {},
      playerArr: [],
      bgArr: [],
      itemArr: [],
      floorCoords: [],
      itemPalettes: {},
      itemPaletteArrMap: {},
      interactItem: { count: 0, type: '', item: {}, source: {} },
      //type: pickup, use, equip, unequip, buy, sell
      useStatPoint: { count: 0, stat: '' },
      increasedStat: { count: 0, type: '', stat: '', quant: 0 },
      quickConsume: { count: 0, num: 0 },
      enemyArr: [],
      enemyPalettes: {},
      enemyAttack: { count: 0, roundCount: 0, spawnIndex: 0, stats: {}, source: {} },
      exchangeAttacks: { count: 0, spawnIndex: 0, attacks: [] },
      enemyDead: {
        count: 0,
        spawnIndex: 0,
        coord: [],
        source: {},
        level: 0,
        experience: 0,
        gold: 0
      },
      overlayMode: 'off'
      //inv-overlay, inGameOptions, startOptions
    };
    return _this;
  }

  _createClass(Game, [{
    key: 'updateBgArr',
    value: function updateBgArr(bgArr, bgLevelProcessed, floorCoords) {
      this.setState({ bgArr: bgArr, bgLevelProcessed: bgLevelProcessed, floorCoords: floorCoords });
    }
  }, {
    key: 'updatePlayerArr',
    value: function updatePlayerArr(playerArr) {
      this.setState({ playerArr: [].concat(_toConsumableArray(playerArr)) });
    }
  }, {
    key: 'updateGameClassState',
    value: function updateGameClassState() {
      var updatedEls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setState(updatedEls);
    }
  }, {
    key: 'pickupItem',
    value: function pickupItem(coord, val, moveCount) {
      var item = Object.assign({}, this.state.itemPaletteArrMap['' + val]),
          inventory = Object.assign({}, this.state.inventory),
          itemArr = [].concat(_toConsumableArray(this.state.itemArr)),
          pArr = this.state.playerArr;

      var nState = {},
          interactItem = Object.assign({}, this.state.interactItem),
          dir = '';

      if (item.type !== 'openChest') {
        if (inventory[item.name]) inventory[item.name].count += 1;else item.count = 1, item.equipped = false, inventory[item.name] = item;

        if (['consumable', 'gold'].includes(item.type)) itemArr[coord[0]][coord[1]] = 0;else itemArr[coord[0]][coord[1]] = chestConsumables.openChest.itemArrVal;

        interactItem.count += 1;
        interactItem.type = 'pickup';
        interactItem.item = item;
        nState = { itemArr: itemArr, inventory: inventory, interactItem: interactItem, moveCount: moveCount };

        console.log('Picked up', item.name);
      }

      dir = coord[0] < pArr[0] ? 'up' : coord[0] > pArr[0] ? 'down' : coord[1] < pArr[1] ? 'left' : 'right';

      if (this.state.heroFacing !== dir) nState.heroFacing = dir;

      nState.playerArr = coord;
      this.setState(nState);
    }
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(e) {
      if (this.state.overlayMode === 'off') {
        var el = e.nativeEvent.code,
            _state = this.state,
            boardSize = _state.boardSize,
            floor = _state.floor,
            playerArr = _state.playerArr,
            bgArr = _state.bgArr,
            itemArr = _state.itemArr,
            itemPaletteArrMap = _state.itemPaletteArrMap,
            enemyArr = _state.enemyArr,
            heroFacing = _state.heroFacing,
            directionKeys = {
          ArrowUp: 'up',
          KeyW: 'up',
          ArrowRight: 'right',
          KeyD: 'right',
          ArrowDown: 'down',
          KeyS: 'down',
          ArrowLeft: 'left',
          KeyA: 'left'
        },
            statIncreaseKeys = {
          KeyV: 'bVitality',
          KeyB: 'bDurability',
          KeyN: 'bStrength',
          KeyM: 'bAgility'
        },
            consumeDigits = ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8'];
        var moveCount = this.state.moveCount,
            nState = {},
            direction = '',
            row = 0,
            col = 0;


        if (directionKeys[el]) {
          moveCount++;
          direction = directionKeys[el];

          row = direction === 'up' ? playerArr[0] - 1 : direction === 'down' ? playerArr[0] + 1 : playerArr[0];

          col = direction === 'right' ? playerArr[1] + 1 : direction === 'left' ? playerArr[1] - 1 : playerArr[1];

          if (row >= 0 && row < boardSize && col >= 0 && col < boardSize && bgArr[row][col] > floor && !enemyArr[row][col]) {

            if (itemArr[row][col]) {
              this.pickupItem([row, col], itemArr[row][col], moveCount);
            } else {
              nState.playerArr = [row, col];
              nState.moveCount = moveCount;
              if (heroFacing !== direction) nState.heroFacing = direction;
              this.setState(nState);
            }
          } else if (itemArr[row][col] && itemPaletteArrMap['' + itemArr[row][col]].name === 'Active Portal') {

            console.log('NEXT LEVEL!');
            this.setState({ gameLevel: this.state.gameLevel + 1 });
          } else if (enemyArr[row][col] && enemyArr[row][col].type === 'merchant') {

            console.log('Merchant Interaction');
            this.setState({ overlayMode: 'merchant-overlay' });
          } else {
            nState.moveCount = moveCount;
            if (heroFacing !== direction) nState.heroFacing = direction;
            this.setState(nState);
          }
        } else if (el === 'KeyI' || el === 'KeyE') {
          this.setState({ overlayMode: 'inv-overlay' });
        } else if (consumeDigits.includes(el)) {
          this.setState({ quickConsume: { count: this.state.quickConsume.count + 1, num: el.slice(-1) } });
        } else if (statIncreaseKeys[el]) {
          this.setState({ useStatPoint: { count: this.state.useStatPoint.count + 1, stat: statIncreaseKeys[el] } });
        }
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'maintainFocus',
    value: function maintainFocus() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'endFocus',
    value: function endFocus() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'handleGameOver',
    value: function handleGameOver() {
      console.log('GAME OVER');
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.maintainFocus();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.state.overlayMode !== nextState.overlayMode) {
        if (nextState.overlayMode === 'off') this.maintainFocus();else this.endFocus();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.gameOver) this.handleGameOver();
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'game', tabIndex: '0', onKeyDown: this.handleKeyDown },
        React.createElement(
          'div',
          { className: 'col-lft' },
          React.createElement(GameLevel, {
            gameLevel: this.state.gameLevel }),
          React.createElement(Hero, {
            tileSize: this.state.tileSize,
            hero: this.state.hero,
            heroIcon: this.state.heroIcon,
            inventory: this.state.inventory,
            itemPalettes: this.state.itemPalettes,
            interactItem: this.state.interactItem,
            useStatPoint: this.state.useStatPoint,
            increasedStat: this.state.increasedStat,
            enemyAttack: this.state.enemyAttack,
            exchangeAttacks: this.state.exchangeAttacks,
            enemyDead: this.state.enemyDead,
            gameOver: this.state.gameOver,
            updateGameClassState: this.updateGameClassState })
        ),
        React.createElement(
          'div',
          { className: 'col-mid' },
          React.createElement(
            'div',
            { className: 'title' },
            'CrimsonQuest'
          ),
          React.createElement(GameStage, {
            boardSize: this.state.boardSize,
            tileSize: this.state.tileSize,
            floor: this.state.floor,
            gameLevel: this.state.gameLevel,
            bgLevelProcessed: this.state.bgLevelProcessed,
            levels: this.state.levels,
            hero: this.state.hero,
            playerArr: this.state.playerArr,
            heroFacing: this.state.heroFacing,
            updatePlayerArr: this.updatePlayerArr,
            bgArr: this.state.bgArr,
            updateBgArr: this.updateBgArr,
            floorCoords: this.state.floorCoords,
            itemArr: this.state.itemArr,
            itemPalettes: this.state.itemPalettes,
            itemPaletteArrMap: this.state.itemPaletteArrMap,
            inventory: this.state.inventory,
            interactItem: this.state.interactItem,
            overlayMode: this.state.overlayMode,
            enemyArr: this.state.enemyArr,
            enemyPalettes: this.state.enemyPalettes,
            enemyDead: this.state.enemyDead,
            updateGameClassState: this.updateGameClassState }),
          React.createElement(ConsumableItems, {
            tileSize: this.state.tileSize,
            inventory: this.state.inventory,
            itemPalettes: this.state.itemPalettes,
            interactItem: this.state.interactItem,
            quickConsume: this.state.quickConsume,
            updateGameClassState: this.updateGameClassState })
        ),
        React.createElement(
          'div',
          { className: 'col-rgt' },
          React.createElement(CurrentObjective, {
            gameLevel: this.state.gameLevel,
            enemyDead: this.state.enemyDead }),
          React.createElement(EnemyManager, {
            tileSize: this.state.tileSize,
            floor: this.state.floor,
            gameLevel: this.state.gameLevel,
            bgLevelProcessed: this.state.bgLevelProcessed,
            playerArr: this.state.playerArr,
            moveCount: this.state.moveCount,
            bgArr: this.state.bgArr,
            floorCoords: this.state.floorCoords,
            enemyArr: this.state.enemyArr,
            enemyPalettes: this.state.enemyPalettes,
            enemyAttack: this.state.enemyAttack,
            exchangeAttacks: this.state.exchangeAttacks,
            enemyDead: this.state.enemyDead,
            updateGameClassState: this.updateGameClassState }),
          React.createElement(ActivityLog, {
            gameLevel: this.state.gameLevel,
            levelUpCount: this.state.levelUpCount,
            interactItem: this.state.interactItem,
            useStatPoint: this.state.useStatPoint,
            increasedStat: this.state.increasedStat,
            exchangeAttacks: this.state.exchangeAttacks,
            enemyDead: this.state.enemyDead }),
          React.createElement(GameTips, null)
        )
      );
    }
  }]);

  return Game;
}(React.Component);

/**
	*		Static Page Components
	*/

/**
	*		@desc React Class renders page header
	*		@returns {HTML} page header
	*/


var PageHeader = function (_React$Component2) {
  _inherits(PageHeader, _React$Component2);

  function PageHeader() {
    _classCallCheck(this, PageHeader);

    return _possibleConstructorReturn(this, (PageHeader.__proto__ || Object.getPrototypeOf(PageHeader)).apply(this, arguments));
  }

  _createClass(PageHeader, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-header' },
        React.createElement(
          'h1',
          null,
          'CrimsonQuest'
        )
      );
    }
  }]);

  return PageHeader;
}(React.Component);

/**
	*		@desc React Class renders page footer
	*		@returns {HTML} page header
	*/


var PageFooter = function (_React$Component3) {
  _inherits(PageFooter, _React$Component3);

  function PageFooter() {
    _classCallCheck(this, PageFooter);

    return _possibleConstructorReturn(this, (PageFooter.__proto__ || Object.getPrototypeOf(PageFooter)).apply(this, arguments));
  }

  _createClass(PageFooter, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-footer' },
        React.createElement(
          'span',
          null,
          '\xA9 2017 Isaac Burbank.'
        ),
        React.createElement(
          'span',
          null,
          'Tiles By\xA0',
          React.createElement(
            'a',
            { href: 'http://opengameart.org/content/dawnlike-16x16-universal-rogue-like-tileset-v181', target: '_blank' },
            'DragonDePlatino'
          )
        )
      );
    }
  }]);

  return PageFooter;
}(React.Component);

/**
	*		Full App Class
	*/

/**
	*		@desc React Class renders full page
	*		@returns {HTML} full app
	*/


var App = function (_React$Component4) {
  _inherits(App, _React$Component4);

  function App() {
    _classCallCheck(this, App);

    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  _createClass(App, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg' },
        React.createElement(PageHeader, null),
        React.createElement(
          'div',
          { className: 'pg-content' },
          React.createElement(Game, null)
        ),
        React.createElement(PageFooter, null)
      );
    }
  }]);

  return App;
}(React.Component);

/**
	*		Render App to DOM
	*/

/**
	*		@desc ReactDOM renders app to HTML root node
	*		@returns {DOM} full page
	*/


ReactDOM.render(React.createElement(App, null), document.getElementById('root'));