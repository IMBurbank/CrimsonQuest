'use strict';

/**
 * Global Settings
 */

var statConvertWordMap = {
  curHealth: 'HP',
  iAttack: 'Atk',
  iDefense: 'Def',
  iVitality: 'Vit',
  iDurability: 'Dur',
  iStrength: 'Str',
  iAgility: 'Agi'
};

var equipAbbrevMap = {
  Head: 'HED',
  Amulet: 'AMU',
  Weapon: 'WEP',
  Armor: 'AMR',
  Shield: 'SLD',
  Glove: 'GLV',
  Ring: 'RNG',
  Foot: 'FT',
  Consumable: 'CNS'
};

var consumableAbbrevMap = {
  potion: { name: 'Potion', key: 'potion', abbrev: 'LPOT', num: 1 },
  hiPotion: { name: 'Hi Potion', key: 'hiPotion', abbrev: 'HPOT', num: 2 },
  xPotion: { name: 'X Potion', key: 'xPotion', abbrev: 'XPOT', num: 3 },
  tomeOfVitality: { name: 'Tome of Vitality', key: 'tomeOfVitality', abbrev: 'VTOM', num: 4 },
  tomeOfDurability: { name: 'Tome of Durability', key: 'tomeOfDurability', abbrev: 'DTOM', num: 5 },
  tomeOfStrength: { name: 'Tome of Strength', key: 'tomeOfStrength', abbrev: 'STOM', num: 6 },
  tomeOfAgility: { name: 'Tome of Agility', key: 'tomeOfAgility', abbrev: 'ATOM', num: 7 },
  tomeOfWisdom: { name: 'Tome of Wisdom', key: 'tomeOfWisdom', abbrev: 'WTOM', num: 8 }
};

//Global state
var timeRef = null;
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
  * Helper Functions
  */

var randInt = function randomIntFromRange(min, max) {
  return ~~(min + Math.random() * (max - min + 1));
};

var devError = function createDevError() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Default Error';

  this.name = 'DevError';
  this.message = message;
  this.stack = new Error().stack;
};

var initZeroArray = function initZeroFilledArray(len) {
  var arr = [],
      i = 0,
      j = 0;

  arr.length = len;
  while (i < len) {
    arr[i] = [];
    arr[i].length = len;
    while (j < len) {
      arr[i][j] = 0, j++;
    }j = 0, i++;
  }
  return arr;
};

//get element by id
var getById = function getElById(id) {
  return document.getElementById(id);
};

//adds one or more classes seperated, by commas, by element id
var addClasses = function addClassesByElId(id) {
  if (getById(id)) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        _addClasses = [].concat(args) || [];

    _addClasses.forEach(function (el) {
      if (!classArr.includes(el)) classArr.push(el);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt add class: ' + id + '. Couldnt find node.');
  }
};

//removes one or more classes seperated, by commas, by element id
var removeClasses = function removeClassesByElId(id) {
  if (getById(id)) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        remClasses = [].concat(args) || [];

    remClasses.forEach(function (el) {
      if (classArr.includes(el)) classArr.splice(classArr.indexOf(el), 1);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt remove class: ' + id + '. Couldnt find node.');
  }
};

var initMemCanvas = function initCanvasToPointer(w, h, smoothing) {
  var tempCanv = document.createElement('canvas'),
      ctx = tempCanv.getContext('2d');

  tempCanv.width = w;
  tempCanv.height = h;
  ctx.imageSmoothingEnabled = smoothing;

  return tempCanv;
};

var calcRenderPadding = function calcCanvasRenderPadding(playerArr, aLen, rLen) {
  var sr = 0,
      pr = 0,
      sc = 0,
      pc = 0;

  if (playerArr[0] - ~~(rLen / 2) < 0) {
    sr = 0;
    pr = -1 * (playerArr[0] - ~~(rLen / 2));
  } else if (playerArr[0] + ~~(rLen / 2) + 1 > aLen) {
    pr = playerArr[0] + ~~(rLen / 2) + 1 - aLen;
    sr = aLen - rLen + pr;
  } else {
    sr = playerArr[0] - ~~(rLen / 2);
    pr = 0;
  }
  if (playerArr[1] - ~~(rLen / 2) < 0) {
    sc = 0;
    pc = -1 * (playerArr[1] - ~~(rLen / 2));
  } else if (playerArr[1] + ~~(rLen / 2) + 1 > aLen) {
    pc = playerArr[1] + ~~(rLen / 2) + 1 - aLen;
    sc = aLen - rLen + pc;
  } else {
    sc = playerArr[1] - ~~(rLen / 2);
    pc = 0;
  }

  return { sr: sr, sc: sc, pr: pr, pc: pc };
};

var setRenderArr = function setCanvasRenderArr(arr, rLen, padding) {
  var renderArr = [],
      sr = padding.sr,
      sc = padding.sc,
      i = 0,
      j = 0,
      m = 0,
      n = 0;

  m = rLen - padding.pr;
  n = rLen - padding.pc;
  renderArr.length = m;

  for (; i < m; i++) {
    renderArr[i] = [];
    renderArr[i].length;

    for (j = 0, n; j < n; j++) {
      renderArr[i][j] = arr[sr + i][sc + j];
    }
  }

  return renderArr;
};

var backgroundArray = function createBackgroundArray(arrSize) {
  var air = 10,
      flr = 40;

  //Random rectangle
  var newRoomOne = function createNewRoomOne(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        xFloorMax = xMax - 4,
        yFloorMin = yMin - 4,
        yFloorMax = yMax - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [];

    var i = 0,
        j = 0;

    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];
      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out on each tile from min rectangle size
  var newRoomTwo = function createNewRoomTwo(rows, cols) {
    //Subtract two to leave room for permimeter walls
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        yFloorMin = yMin - 4;

    var xPadL = randInt(2, xMax - xFloorMin - 2),
        xPadR = xMax - xFloorMin - xPadL,
        yPadT = randInt(2, yMax - yFloorMin - 2),
        yPadB = yMax - yFloorMin - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor area
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = xFloorMin;else if (i === 1) ext = xPadR - 2, s = yFloorMin;else if (i === 2) ext = yPadB - 2, s = xFloorMin;else ext = xPadL - 2, s = yFloorMin;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor area flr val in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + xFloorMin && i + 1 > yPadT && i < yPadT + yFloorMin) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + xFloorMin + i] = flr;
      }
    });
    floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + yFloorMin + i][xPadL + index] = flr;
      }
    });
    floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0]));
    xPadR = xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1]));
    yPadB = yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2]));
    xPadL = xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3]));

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out from random sides of rectangle
  var newRoomThree = function createNewRoomThree(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMax = xMax - 4,
        xFloorMin = xMin - 4,
        yFloorMax = yMax - 4,
        yFloorMin = yMin - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        sidesToExtend = [randInt(0, 1), randInt(0, 1), randInt(0, 1), randInt(0, 1)];

    var xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor size
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = w;else if (i === 1) ext = xPadR - 2, s = h;else if (i === 2) ext = yPadB - 2, s = w;else ext = xPadL - 2, s = h;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor size to 1's in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    sidesToExtend[0] && floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    sidesToExtend[1] && floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + w + i] = flr;
      }
    });
    sidesToExtend[2] && floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + h + i][xPadL + index] = flr;
      }
    });
    sidesToExtend[3] && floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = sidesToExtend[0] ? yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0])) : yPadT;
    xPadR = sidesToExtend[1] ? xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1])) : xPadR;
    yPadB = sidesToExtend[2] ? yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2])) : yPadB;
    xPadL = sidesToExtend[3] ? xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3])) : xPadL;

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  var createRooms = function createNewRooms() {
    var rows = 0,
        colsArr = [],
        cols = 0,
        xPadL = 0,
        xPadR = 0,
        yPadT = 0,
        yPadB = 0,
        xMax = 0,
        yMax = 0,
        roomType = 0,
        rooms = [],
        rmsRow = [],
        roomFloorArr = [],
        i = 0,
        j = 0;

    rows = randInt(3, 4) * 2;
    colsArr.length = rows;
    for (; i < rows; i++) {
      colsArr[i] = randInt(2, 4) * 2;
    }

    rooms = colsArr.map(function (el, index) {
      rmsRow = [];

      for (j = 0; j < el; j++) {
        roomType = randInt(1, 10);
        cols = el;

        if (roomType === 1) {
          var _newRoomOne = newRoomOne(rows, cols);

          xPadL = _newRoomOne.xPadL;
          xPadR = _newRoomOne.xPadR;
          yPadT = _newRoomOne.yPadT;
          yPadB = _newRoomOne.yPadB;
          xMax = _newRoomOne.xMax;
          yMax = _newRoomOne.yMax;
          roomFloorArr = _newRoomOne.roomFloorArr;
        } else if (roomType > 1 && roomType < 8) {
          var _newRoomTwo = newRoomTwo(rows, cols);

          xPadL = _newRoomTwo.xPadL;
          xPadR = _newRoomTwo.xPadR;
          yPadT = _newRoomTwo.yPadT;
          yPadB = _newRoomTwo.yPadB;
          xMax = _newRoomTwo.xMax;
          yMax = _newRoomTwo.yMax;
          roomFloorArr = _newRoomTwo.roomFloorArr;
        } else {
          var _newRoomThree = newRoomThree(rows, cols);

          xPadL = _newRoomThree.xPadL;
          xPadR = _newRoomThree.xPadR;
          yPadT = _newRoomThree.yPadT;
          yPadB = _newRoomThree.yPadB;
          xMax = _newRoomThree.xMax;
          yMax = _newRoomThree.yMax;
          roomFloorArr = _newRoomThree.roomFloorArr;
        }

        rmsRow[j] = {
          rows: rows,
          cols: cols,
          xPadL: xPadL,
          xPadR: xPadR,
          yPadT: yPadT,
          yPadB: yPadB,
          xMax: xMax,
          yMax: yMax,
          roomFloorArr: roomFloorArr,
          cnxns: [0, 0, 0, 0],
          curRow: index
        };
      }

      return rmsRow;
    });
    return rooms;
  };

  var stitchRooms = function stitchRoomArray(rooms) {
    var stitchArr = [],
        len = arrSize;

    var c = 0,
        i = 0,
        j = 0,
        k = 0,
        r = 0;

    stitchArr.length = len;
    while (r < len) {
      while (c < len) {
        stitchArr[r] = c === 0 ? rooms[k][i].roomFloorArr[j] : [].concat(_toConsumableArray(stitchArr[r]), _toConsumableArray(rooms[k][i].roomFloorArr[j]));
        c += rooms[k][i].xMax;
        i++;
      }
      if (j === rooms[k][i - 1].yMax - 1) j = 0, k++;else j++;
      c = 0, i = 0;
      r++;
    }
    return stitchArr;
  };

  var choosePaths = function newPaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow) {
    var len = stitchArr.length,
        xMax = rm.xMax,
        yMax = rm.yMax;

    var pathOpts = [],
        paths = [],
        goUp = false,
        goRt = false,
        goDn = false,
        goLt = false,
        chk = false,
        val = 0,
        i = 0,
        j = 0,
        k = 0;

    if (tieRule === 1 || tieRule === 2 && rm.cnxns[3] || tieRule === 4 && rm.cnxns[0]) {
      val = randInt(1, 3);
      goRt = val === 1 || val === 3 ? true : false;
      goDn = val === 2 || val === 3 ? true : false;
    } else if (tieRule === 2) {
      goRt = randInt(0, 1) ? true : false;
      goDn = true;
    } else if (tieRule === 3) {
      goDn = !rm.cnxns[3] || !tiedRow || randInt(0, 1) ? true : false;
    } else if (tieRule === 4) {
      goRt = true;
      goDn = randInt(0, 1) ? true : false;
    } else if (tieRule === 5) {
      goRt = !rm.cnxns[0] || !rooms[rm.curRow - 1][~~(chkCol / rooms[rm.curRow - 1][0].xMax)].cnxns[1] || randInt(0, 1) ? true : false;
    } else {
      goUp = !rm.cnxns[0] ? true : false;
      goLt = !rm.cnxns[3] ? true : false;
    }
    tiedRow = goDn ? true : tiedRow;

    if (goUp) {
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow - j < 2 || stitchArr[chkRow - j][k] === flr || stitchArr[chkRow - j - 1][k] === flr || stitchArr[chkRow - j][k + 1] === flr || stitchArr[chkRow - j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow - j > 1) pathOpts.push([1, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        goRt = true;
        try {
          throw new devError('No pathOpts up. Set right. -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goDn) {
      pathOpts.length = 0;
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow + j > len - 3 || stitchArr[chkRow + j][k] === flr || stitchArr[chkRow + j][k + 1] === flr || stitchArr[chkRow + j + 1][k] === flr || stitchArr[chkRow + j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow + j < len - 3) pathOpts.push([3, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        goRt = true;
        try {
          throw new devError('No pathOpts down. Set right. -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goRt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(xMax / 2) && (j > 2 * xMax || chkCol + j > len - 3 || stitchArr[k][chkCol + j] === flr || stitchArr[k - 1][chkCol + j] === flr || stitchArr[k][chkCol + j + 1] === flr || stitchArr[k + 1][chkCol + j] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol + j < len - 3) pathOpts.push([2, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        try {
          throw new devError('no pathOpts right -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }
    if (goLt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * xMax || chkCol - j < 2 || stitchArr[k][chkCol - j] === flr || stitchArr[k - 1][chkCol - j] === flr || stitchArr[k + 1][chkCol - j] === flr || stitchArr[k][chkCol - j - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol - j > 1) pathOpts.push([4, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        try {
          throw new devError('no pathOpts left -> BackgroundLayer.choosePaths');
        } catch (e) {
          console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
        }
      }
    }

    if (paths.length === 1) paths.push([0, 0, 0, 0]);else if (paths.length > 2) {
      try {
        throw new devError('paths.length > 2 -> BackgroundLayer.choosePaths');
      } catch (e) {
        console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule);
      }
    }

    return { paths: paths, tiedRow: tiedRow };
  };

  var applyPaths = function applyNewPaths(rm, rooms, stitchArr, paths) {
    var i = 0;

    paths.forEach(function (el) {
      if (el[0] === 1) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] - i][el[1]] = flr;
        }
        rm.cnxns[0] = 1;
        rooms[rm.curRow - 1][~~(el[1] / rooms[rm.curRow - 1][0].xMax)].cnxns[2] = 1;
      } else if (el[0] === 2) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] + i] = flr;
        }
        rm.cnxns[1] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) + 1].cnxns[3] = 1;
      } else if (el[0] === 3) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] + i][el[1]] = flr;
        }
        rm.cnxns[2] = 1;
        rooms[rm.curRow + 1][~~(el[1] / rooms[rm.curRow + 1][0].xMax)].cnxns[0] = 1;
      } else if (el[0] === 4) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] - i] = flr;
        }
        rm.cnxns[3] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) - 1].cnxns[1] = 1;
      }
    });

    return true;
  };

  var createPaths = function createNewPaths(rooms, stitchArr) {
    var len = stitchArr.length;

    var tiedRow = false,
        paths = [],
        rm = void 0,
        //{} pointer
    chkRow = 0,
        chkCol = 0,
        tieRule = 0,
        r = 0,
        c = 0,
        i = 0,
        j = 0;

    paths.length = ~~(len / 4);

    while (r < len) {
      while (c < len) {
        rm = rooms[j][i];
        chkRow = r + ~~(rm.yMax / 2);
        chkCol = c + ~~(rm.xMax / 2);
        tieRule = j === 0 && i === 0 ? 1 : j === 0 && i < rooms[j].length - 1 ? 2 : j < rooms.length - 1 && i === rooms[j].length - 1 ? 3 : j < rooms.length - 1 && i < rooms[j].length - 1 ? 4 : j === rooms.length - 1 && i < rooms[j].length - 1 ? 5 : 6;

        var _choosePaths = choosePaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow);

        paths = _choosePaths.paths;
        tiedRow = _choosePaths.tiedRow;

        applyPaths(rm, rooms, stitchArr, paths);

        c += rm.xMax;
        i++;
      }
      r += rooms[j][i - 1].yMax;
      j++;
      tiedRow = false;
      c = 0;
      i = 0;
    }

    return stitchArr;
  };

  var randomizeOrientation = function randomizeArrOrientation(connectedArr) {
    var len = connectedArr.length,
        orientation = randInt(1, 4);

    var orientedArr = [],
        i = 0,
        j = 0;

    var transposed = function transposeSquareArr(arr) {
      var tArr = [],
          len = arr.length;

      while (i < len) {
        tArr[i] = [];
        j = 0;

        while (j < len) {
          tArr[i][j] = arr[j][i], j++;
        }i++;
      }
      return tArr;
    };

    if (orientation === 1) {
      orientedArr = [].concat(_toConsumableArray(connectedArr));
    }
    if (orientation === 2) {
      //Rotate +90 deg
      orientedArr = transposed(connectedArr);
      orientedArr.forEach(function (el) {
        return el.reverse();
      });
    } else if (orientation === 3) {
      //Rotate 180 deg
      while (i < len) {
        orientedArr[i] = connectedArr[len - 1 - i].reverse();
        i++;
      }
    } else if (orientation === 4) {
      //Rotate -90 deg
      connectedArr.forEach(function (el) {
        return el.reverse();
      });
      orientedArr = transposed(connectedArr);
    }
    return { orientation: orientation, orientedArr: orientedArr };
  };

  var addWalls = function addArrWalls(orientedArr) {
    var walledArr = orientedArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = walledArr.length - 1;

    var i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (orientedArr[i][j] === air) {
          nArr[0] = walledArr[i - 1][j - 1];
          nArr[1] = walledArr[i - 1][j];
          nArr[2] = walledArr[i - 1][j + 1];
          nArr[3] = walledArr[i][j - 1];
          nArr[4] = walledArr[i][j + 1];
          nArr[5] = walledArr[i + 1][j - 1];
          nArr[6] = walledArr[i + 1][j];
          nArr[7] = walledArr[i + 1][j + 1];

          if (nArr.indexOf(flr) > -1) {
            if (nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && (nArr[1] === air || nArr[1] === flr) && (nArr[5] === flr && nArr[7] === flr || nArr[1] === flr && (nArr[5] === flr || nArr[7] === flr))) {
              el = 31;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && nArr[6] === air && (nArr[2] === flr && nArr[7] === flr || nArr[3] === flr && (nArr[2] === flr || nArr[7] === flr))) {
              el = 32;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && nArr[2] === flr && nArr[7] === flr) {
              el = 33;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[0] === flr && nArr[5] === flr || (nArr[0] === flr || nArr[5] === flr) && nArr[4] === flr)) {
              el = 34;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && (nArr[0] === flr && nArr[2] === flr || (nArr[0] === flr || nArr[2] === flr) && nArr[6] === flr)) {
              el = 35;
            } else if (nArr[4] === air && nArr[6] === air && (nArr[1] === flr && nArr[3] === flr || nArr[7] === flr)) {
              el = 21;
            } else if (nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[1] === flr && nArr[4] === flr || nArr[5] === flr)) {
              el = 23;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && (nArr[3] === flr && nArr[6] === flr || nArr[2] === flr)) {
              el = 25;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && (nArr[0] === flr || nArr[4] === flr && nArr[6] === flr)) {
              el = 27;
            } else if (nArr[3] > air && nArr[3] < flr && (nArr[1] === flr || nArr[6] === flr) || nArr[4] === air && (nArr[1] === flr && nArr[2] === flr || nArr[5] === flr && nArr[6] === flr)) {
              el = 22;
            } else if (nArr[1] > air && nArr[1] < flr || nArr[6] === air && (nArr[3] === flr || nArr[4] === flr)) {
              el = 24;
            } else if (nArr[1] === flr || nArr[3] === flr || nArr[4] === flr || nArr[6] === flr) {
              el = 26;
            }

            if (el) walledArr[i][j] = el;
          }
        }
        j++;
      }
      i++;
    }

    return walledArr;
  };

  var addFloors = function addArrFloors(walledArr) {
    var bgArr = walledArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = bgArr.length - 1,
        sFlr = flr - 1;

    var floorCoords = [],
        i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (walledArr[i][j] > sFlr) {
          nArr[0] = bgArr[i - 1][j - 1];
          nArr[1] = bgArr[i - 1][j];
          nArr[2] = bgArr[i - 1][j + 1];
          nArr[3] = bgArr[i][j - 1];
          nArr[4] = bgArr[i][j + 1];
          nArr[5] = bgArr[i + 1][j - 1];
          nArr[6] = bgArr[i + 1][j];
          nArr[7] = bgArr[i + 1][j + 1];
          floorCoords.push([i, j]);

          if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 41;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 42;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 43;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 44;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 45;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 46;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 47;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 48;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 49;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 51;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 52;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 53;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 54;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 55;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 56;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 57;
          }

          if (el) bgArr[i][j] = el;
        }
        j++;
      }
      i++;
    }
    return { bgArr: bgArr, floorCoords: floorCoords };
  };

  var rooms = createRooms();
  var stitchArr = stitchRooms(rooms);
  var connectedArr = createPaths(rooms, stitchArr);

  var _randomizeOrientation = randomizeOrientation(connectedArr),
      orientation = _randomizeOrientation.orientation,
      orientedArr = _randomizeOrientation.orientedArr;

  var walledArr = addWalls(orientedArr);

  var _addFloors = addFloors(walledArr),
      bgArr = _addFloors.bgArr,
      floorCoords = _addFloors.floorCoords;

  return { bgArr: bgArr, floorCoords: floorCoords };
};
'use strict';

var heroTypeStats = {
  Mage: {
    heroName: 'Forsyth',
    health: 53,
    attack: 12,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 12,
    durability: 10,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 0,
      attack: 5,
      defense: 0,
      vitality: 1,
      durability: 0,
      strength: 2,
      agility: 1
    }
  },
  Paladin: {
    heroName: 'Roland',
    health: 53,
    attack: 10,
    defense: 12,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 11,
    durability: 11,
    strength: 11,
    agility: 11,
    onLevelUp: {
      health: 6,
      attack: 1,
      defense: 2,
      vitality: 1,
      durability: 2,
      strength: 1,
      agility: 0
    }
  },
  Rogue: {
    heroName: 'Hanzo',
    health: 50,
    attack: 13,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 10,
    strength: 12,
    agility: 12,
    onLevelUp: {
      health: 6,
      attack: 3,
      defense: 0,
      vitality: 0,
      durability: 0,
      strength: 2,
      agility: 2
    }
  },
  Warrior: {
    heroName: 'Agis',
    health: 50,
    attack: 12,
    defense: 11,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 12,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 6,
      attack: 2,
      defense: 1,
      vitality: 0,
      durability: 1,
      strength: 2,
      agility: 1
    }
  }
};

var statConversion = {
  vitToHp: 9,
  durToHp: 3,
  durToDef: 2,
  durToDodge: 0.1,
  strToAtk: 2,
  strToDef: 1,
  strToHit: 0.25,
  agiToHit: 1,
  agiToDodge: 0.5,
  agiToCrit: 0.5
};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//stageSize, boardSize, tileSize, gameLevel, playerArr, bgArr, accArr, updateAccArr
var AccentLayer = function (_React$Component) {
  _inherits(AccentLayer, _React$Component);

  function AccentLayer(props) {
    _classCallCheck(this, AccentLayer);

    var _this = _possibleConstructorReturn(this, (AccentLayer.__proto__ || Object.getPrototypeOf(AccentLayer)).call(this, props));

    _this.initAccArr = _this.initAccArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getAccImages = _this.getAccImages.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setAccArr = _this.setAccArr.bind(_this);
    _this.drawAccents = _this.drawAccents.bind(_this);

    _this.state = {
      srcTileSize: 16,
      wallAcc: 20,
      flrAcc: 40,
      decor0: null,
      decor1: null,
      ground0: null,
      ground1: null,
      ore0: null,
      ore1: null,
      dec0Canv: null,
      dec1Canv: null,
      grnd0Canv: null,
      grnd1Canv: null,
      ore0Canv: null,
      ore1Canv: null,
      decorMap: {},
      groundMap: {},
      oreMap: {},
      corpseMap: [],
      paletteArrMap: {},
      tempCanv: null
    };
    return _this;
  }

  _createClass(AccentLayer, [{
    key: 'initAccArr',
    value: function initAccArr() {
      var len = this.props.boardSize,
          accArr = initZeroArray(len);

      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'getAccImages',
    value: function getAccImages() {
      var decor0 = new Image(),
          decor1 = new Image(),
          ground0 = new Image(),
          ground1 = new Image(),
          ore0 = new Image(),
          ore1 = new Image(),
          that = this;

      var i = 0;

      var handleAccLoad = function handleAccImageLoad() {
        i++;
        if (i === 6) {
          that.setState({ decor0: decor0, decor1: decor1, ground0: ground0, ground1: ground1, ore0: ore0, ore1: ore1 });

          //Delete after start screen created
          that.setPalettes(decor0, decor1, ground0, ground1, ore0, ore1, 1);
        }
      };

      decor0.src = 'img/accents/Decor0.png';
      decor1.src = 'img/accents/Decor1.png';
      ground0.src = 'img/accents/Ground0.png';
      ground1.src = 'img/accents/Ground1.png';
      ore0.src = 'img/accents/Ore0.png';
      ore1.src = 'img/accents/Ore1.png';

      decor0.addEventListener('load', handleAccLoad);
      decor1.addEventListener('load', handleAccLoad);
      ground0.addEventListener('load', handleAccLoad);
      ground1.addEventListener('load', handleAccLoad);
      ore0.addEventListener('load', handleAccLoad);
      ore1.addEventListener('load', handleAccLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var size = this.props.stageSize,
          smoothRender = false,
          tempCanv = initMemCanvas(size, size, smoothRender);

      this.setState({ tempCanv: tempCanv });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var decorMap = {},
          groundMap = {},
          oreMap = {},
          corpseMap = [],
          w = 0,
          h = 0,
          i = 0,
          j = 0;

      //init decorMap
      w = 8;
      h = 19;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          decorMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init groundMap
      w = 8;
      h = 7;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          groundMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init oreMap
      w = 3;
      h = 2;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          oreMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init corpseMap
      corpseMap = groundMap['48'];

      this.setPaletteArrMap(this.props.gameLevel, decorMap, groundMap, oreMap);
      this.setState({ decorMap: decorMap, groundMap: groundMap, oreMap: oreMap, corpseMap: corpseMap });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(decor0, decor1, ground0, ground1, ore0, ore1, gameLevel) {
      var lvl = gameLevel,
          gmTS = this.props.tileSize,
          srcTS = this.state.srcTileSize,
          scale = gmTS / srcTS,
          dH = 19 * gmTS,
          dW = 8 * gmTS,
          gH = 7 * gmTS,
          gW = 8 * gmTS,
          oH = 2 * gmTS,
          oW = 3 * gmTS;

      var dec0Canv = document.createElement('canvas'),
          dec0Ctx = dec0Canv.getContext('2d'),
          dec1Canv = document.createElement('canvas'),
          dec1Ctx = dec1Canv.getContext('2d'),
          grnd0Canv = document.createElement('canvas'),
          grnd0Ctx = grnd0Canv.getContext('2d'),
          grnd1Canv = document.createElement('canvas'),
          grnd1Ctx = grnd1Canv.getContext('2d'),
          ore0Canv = document.createElement('canvas'),
          ore0Ctx = ore0Canv.getContext('2d'),
          ore1Canv = document.createElement('canvas'),
          ore1Ctx = ore1Canv.getContext('2d'),
          srcX = 0,
          srcY = 0;

      //set decor
      srcY = 2 * srcTS;
      dec0Canv.width = dW;
      dec0Canv.height = dH;
      dec1Canv.width = dW;
      dec1Canv.height = dH;
      dec0Ctx.imageSmoothingEnabled = false;
      dec1Ctx.imageSmoothingEnabled = false;
      dec0Ctx.drawImage(decor0, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);
      dec1Ctx.drawImage(decor1, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);

      //set ground
      srcY = 0;
      grnd0Canv.width = gW;
      grnd0Canv.height = gH;
      grnd1Canv.width = gW;
      grnd1Canv.height = gH;
      grnd0Ctx.imageSmoothingEnabled = false;
      grnd1Ctx.imageSmoothingEnabled = false;
      grnd0Ctx.drawImage(ground0, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);
      grnd1Ctx.drawImage(ground1, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);

      //set ore
      srcX = lvl === 10 ? 5 * srcTS : 0;
      srcY = lvl === 1 ? 5 * srcTS : lvl === 2 ? 3 * srcTS : lvl === 3 ? 2 * srcTS : srcTS;
      ore0Canv.width = oW;
      ore0Canv.height = oH;
      ore1Canv.width = oW;
      ore1Canv.height = oH;
      ore0Ctx.imageSmoothingEnabled = false;
      ore1Ctx.imageSmoothingEnabled = false;
      ore0Ctx.drawImage(ore0, srcX, srcY, oW / scale, oH / scale, 0, 0, oW, oH);
      ore1Ctx.drawImage(ore1, srcX, srcY, oW / scale, oH / scale, 0, 0, oW, oH);

      this.setState({ dec0Canv: dec0Canv, dec1Canv: dec1Canv, grnd0Canv: grnd0Canv, grnd1Canv: grnd1Canv, ore0Canv: ore0Canv, ore1Canv: ore1Canv });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap(lvl, decorMap, groundMap, oreMap) {
      decorMap = decorMap || this.state.decorMap;
      groundMap = groundMap || this.state.groundMap;
      oreMap = oreMap || this.state.oreMap;

      var paletteArrMap = {};

      if (lvl && lvl < 5) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['4'], 'decor'],
          '22': [oreMap['0'], 'ore'],
          '23': [oreMap['3'], 'ore'],
          //rWall
          '24': [decorMap['7'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [oreMap['2'], 'ore'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['5'], 'decor'],
          '42': [decorMap['14'], 'decor'],
          '43': [decorMap['15'], 'decor'],
          '44': [groundMap['0'], 'ground'],
          '45': [decorMap['80'], 'decor'],
          '46': [decorMap['81'], 'decor'],
          '47': [decorMap['88'], 'decor'],
          '48': [decorMap['89'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl < 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['48'], 'decor'],
          '23': [decorMap['49'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [decorMap['2'], 'decor'],
          '26': [decorMap['7'], 'decor'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [decorMap['3'], 'decor'],
          '29': [decorMap['3'], 'decor'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['72'], 'decor'],
          '43': [decorMap['74'], 'decor'],
          '44': [decorMap['76'], 'decor'],
          '45': [decorMap['82'], 'decor'],
          '46': [decorMap['83'], 'decor'],
          '47': [decorMap['90'], 'decor'],
          '48': [decorMap['91'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl === 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['53'], 'decor'],
          '23': [decorMap['55'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['70'], 'decor'],
          '43': [decorMap['71'], 'decor'],
          '44': [decorMap['72'], 'decor'],
          '45': [decorMap['84'], 'decor'],
          '46': [decorMap['85'], 'decor'],
          '47': [decorMap['92'], 'decor'],
          '48': [decorMap['93'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      }
      this.setState({ paletteArrMap: paletteArrMap });
    }
  }, {
    key: 'setAccArr',
    value: function setAccArr(nextProps) {
      var bgArr = nextProps.bgArr,
          flr = this.state.flrAcc,
          wall = this.state.wallAcc,
          len = bgArr.length;

      var accArr = [].concat(_toConsumableArray(nextProps.accArr)),
          nArr = [0, 0, 0, 0, 0, 0, 0, 0],
          el = 0,
          n = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          n = bgArr[i][j];
          el = 0;

          if (n > wall) {
            nArr[0] = bgArr[i - 1][j - 1];
            nArr[1] = bgArr[i - 1][j];
            nArr[2] = bgArr[i - 1][j + 1];
            nArr[3] = bgArr[i][j - 1];
            nArr[4] = bgArr[i][j + 1];
            nArr[5] = bgArr[i + 1][j - 1];
            nArr[6] = bgArr[i + 1][j];
            nArr[7] = bgArr[i + 1][j + 1];

            if ([22, 25, 27, 35].includes(n) && nArr[6] > flr) {
              //tWall accents
              if (randInt(1, 12) === 5) el = randInt(21, 23);
            }
            if ([21, 24, 25, 32].includes(n) && nArr[3] > flr) {
              //rWall accents
              if (randInt(1, 15) === 5) el = randInt(24, 26);
            }
            if ([23, 24, 27, 34].includes(n) && nArr[4] > flr) {
              //lWall accents
              if (randInt(1, 15) === 5) el = randInt(27, 29);
            }
            if (n > flr) {
              //ground accents
              if (randInt(1, 50) === 7) el = randInt(41, 49);
            }
          }
          accArr[i][j] = el;
          j++;
        }
        j = 0;
        i++;
      }
      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'drawAccents',
    value: function drawAccents(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var accArr = this.props.accArr,
          map = this.state.paletteArrMap,
          playerArr = this.props.playerArr,
          ts = this.props.tileSize,
          px = this.props.stageSize,
          decor0 = this.state.dec0Canv,
          decor1 = this.state.dec1Canv,
          ground0 = this.state.grnd0Canv,
          ground1 = this.state.grnd1Canv,
          ore0 = this.state.ore0Canv,
          ore1 = this.state.ore1Canv,
          dec0Data = decor0.getContext('2d').getImageData(0, 0, decor0.width, decor0.height).data,
          dec1Data = decor1.getContext('2d').getImageData(0, 0, decor1.width, decor1.height).data,
          grnd0Data = ground0.getContext('2d').getImageData(0, 0, ground0.width, ground0.height).data,
          grnd1Data = ground1.getContext('2d').getImageData(0, 0, ground1.width, ground1.height).data,
          ore0Data = ore0.getContext('2d').getImageData(0, 0, ore0.width, ore0.height).data,
          ore1Data = ore1.getContext('2d').getImageData(0, 0, ore1.width, ore1.height).data,
          rLen = px / ts,
          accLen = accArr.length,
          frame = (timestamp - timeRef) % 1000 * .06;

      var dCtx = document.getElementById('acc-layer').getContext('2d'),
          tempCanv = this.state.tempCanv,
          tempCtx = tempCanv.getContext('2d'),
          tImgData = tempCtx.createImageData(px, px),
          tImgPixData = tImgData.data,
          renderArr = [],
          iData = 0,
          pData = 0,
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          img = null,
          imgW = 0,
          m = [],
          el = 0,
          srcX = 0,
          srcY = 0,
          dX = 0,
          dY = 0,
          h = 0,
          w = 0,
          i = 0,
          j = 0;

      if (playerArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (playerArr[0] - ~~(rLen / 2));
      } else if (playerArr[0] + ~~(rLen / 2) + 1 > accLen) {
        pr = playerArr[0] + ~~(rLen / 2) + 1 - accLen;
        sr = accLen - rLen + pr;
      } else {
        sr = playerArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (playerArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (playerArr[1] - ~~(rLen / 2));
      } else if (playerArr[1] + ~~(rLen / 2) + 1 > accLen) {
        pc = playerArr[1] + ~~(rLen / 2) + 1 - accLen;
        sc = accLen - rLen + pc;
      } else {
        sc = playerArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = accArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el) {
            m = map['' + el];

            if (frame > 29) {
              if (m[1] === 'decor') img = dec0Data, imgW = decor0.width;else if (m[1] === 'ore') img = ore0Data, imgW = ore0.width;else img = grnd0Data, imgW = ground0.width;
            } else {
              if (m[1] === 'decor') img = dec1Data, imgW = decor1.width;else if (m[1] === 'ore') img = ore1Data, imgW = ore1.width;else img = grnd1Data, imgW = ground1.width;
            }

            srcX = m[0][0];
            srcY = m[0][1];
            dX = sx + j * ts;
            dY = sy + i * ts;
            h = 0;

            while (h < ts) {
              w = 0;
              while (w < ts) {
                pData = (dX + w + (dY + h) * px) * 4;
                iData = (srcX + w + (srcY + h) * imgW) * 4;

                tImgPixData[pData] = img[iData];
                tImgPixData[pData + 1] = img[iData + 1];
                tImgPixData[pData + 2] = img[iData + 2];
                tImgPixData[pData + 3] = img[iData + 3];
                w++;
              }
              h++;
            }
          }
        }
      }

      dCtx.putImageData(tImgData, 0, 0);
      window.requestAnimationFrame(this.drawAccents);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getAccImages();
      this.initAccArr();
      this.initTempCanvas();
      this.initPaletteMaps();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.setPaletteArrMap(nextProps.gameLevel);
        if (this.state.decor0) {
          this.setPalettes(this.state.decor0, this.state.decor1, this.state.ground0, this.state.ground1, this.state.ore0, this.state.ore1, nextProps.gameLevel);
        }
      }
      if (this.props.bgArr !== nextProps.bgArr) {
        this.setAccArr(nextProps);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.dec0Canv !== this.state.dec0Canv) {
        window.requestAnimationFrame(this.drawAccents);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'acc-layer',
        className: 'acc-layer',
        width: size,
        height: size });
    }
  }]);

  return AccentLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, boardSize, tileSize, gameLevel, bgArr, updateBgArr, playerArr
var BackgroundLayer = function (_React$Component) {
  _inherits(BackgroundLayer, _React$Component);

  function BackgroundLayer(props) {
    _classCallCheck(this, BackgroundLayer);

    var _this = _possibleConstructorReturn(this, (BackgroundLayer.__proto__ || Object.getPrototypeOf(BackgroundLayer)).call(this, props));

    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getBgImages = _this.getBgImages.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.drawBackground = _this.drawBackground.bind(_this);

    _this.state = {
      srcTileSize: 16,
      floorImg: null,
      wallImg: null,
      floorPalette: {},
      wallPalette: {},
      floorPaletteMap: {},
      wallPaletteMap: {},
      tempCanv: {},
      playerLoc: []
    };
    return _this;
  }

  _createClass(BackgroundLayer, [{
    key: 'getBgImages',
    value: function getBgImages() {
      var floorImg = new Image(),
          wallImg = new Image(),
          that = this;

      var i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 2) {
          that.setState({ floorImg: floorImg, wallImg: wallImg });

          //Delete after start screen created
          that.setPalettes(floorImg, wallImg, that.props.gameLevel);
        }
      };

      floorImg.src = 'img/terrain/Floor.png';
      wallImg.src = 'img/terrain/Wall.png';
      floorImg.addEventListener('load', handleLoad);
      wallImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var canvas = document.createElement('canvas'),
          ctx = canvas.getContext('2d'),
          size = this.props.stageSize;

      canvas.width = size;
      canvas.height = size;
      ctx.imageSmoothingEnabled = false;

      this.setState({ tempCanv: { canvas: canvas, ctx: ctx } });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var floorPaletteMap = {
        '41': [0, 0],
        '42': [ts, 0],
        '43': [2 * ts, 0],
        '44': [0, ts],
        '45': [ts, ts],
        '46': [2 * ts, ts],
        '47': [0, 2 * ts],
        '48': [ts, 2 * ts],
        '49': [2 * ts, 2 * ts],
        '51': [3 * ts, 0],
        '52': [3 * ts, ts],
        '53': [3 * ts, 2 * ts],
        '54': [4 * ts, ts],
        '55': [5 * ts, ts],
        '56': [6 * ts, ts],
        '57': [5 * ts, 0]
      };

      var wallPaletteMap = {
        '21': [0, 0],
        '22': [ts, 0],
        '23': [2 * ts, 0],
        '24': [0, ts],
        '25': [0, 2 * ts],
        '26': [ts, ts],
        '27': [2 * ts, 2 * ts],
        '31': [4 * ts, 0],
        '32': [3 * ts, ts],
        '33': [4 * ts, ts],
        '34': [5 * ts, ts],
        '35': [4 * ts, 2 * ts],
        '36': [3 * ts, 0]
      };

      this.setState({ floorPaletteMap: floorPaletteMap, wallPaletteMap: wallPaletteMap });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(floorImg, wallImg, gameLevel) {
      var lvl = gameLevel,
          gmTileSize = this.props.tileSize,
          srcTileSize = this.state.srcTileSize,
          scale = gmTileSize / srcTileSize,
          h = 3 * gmTileSize,
          fw = 7 * gmTileSize,
          ww = 6 * gmTileSize;

      var fCanvas = document.createElement('canvas'),
          fCtx = fCanvas.getContext('2d'),
          wCanvas = document.createElement('canvas'),
          wCtx = wCanvas.getContext('2d'),
          srcY = 3 * srcTileSize;

      srcY *= lvl === 1 ? 5 : lvl === 2 ? 6 : lvl === 3 ? 7 : lvl === 4 ? 8 : lvl === 5 ? 1 : lvl < 8 ? 2 : lvl < 10 ? 3 : lvl === 10 ? 4 : 1;

      fCanvas.width = fw;
      fCanvas.height = h;
      fCtx.imageSmoothingEnabled = false;
      fCtx.drawImage(floorImg, 0, srcY, fw / scale, h / scale, 0, 0, fw, h);

      wCanvas.width = ww;
      wCanvas.height = h;
      wCtx.imageSmoothingEnabled = false;
      wCtx.drawImage(wallImg, 0, srcY, ww / scale, h / scale, 0, 0, ww, h);

      this.setState({
        floorPalette: { canvas: fCanvas, ctx: fCtx },
        wallPalette: { canvas: wCanvas, ctx: wCtx }
      });

      //Delete after start screen created
      this.props.playerArr !== [0, 0] && this.drawBackground(this.props, this.state);
    }
  }, {
    key: 'drawBackground',
    value: function drawBackground(nextProps, nextState) {
      var flrImg = nextState.floorPalette.canvas,
          wallImg = nextState.wallPalette.canvas,
          flrImgMap = nextState.floorPaletteMap,
          wallImgMap = nextState.wallPaletteMap,
          bgArr = nextProps.bgArr,
          playerArr = nextProps.playerArr,
          ts = nextProps.tileSize,
          px = nextProps.stageSize,
          bgLen = bgArr.length,
          rLen = px / ts,
          air = 10,
          flr = 40;

      var dCtx = document.getElementById('bg-layer').getContext('2d'),
          tempCanv = nextState.tempCanv.canvas,
          tempCtx = nextState.tempCanv.ctx,
          renderArr = [],
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          img = null,
          map = {},
          el = 0,
          srcX = 0,
          srcY = 0,
          i = 0,
          j = 0;

      if (playerArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (playerArr[0] - ~~(rLen / 2));
      } else if (playerArr[0] + ~~(rLen / 2) + 1 > bgLen) {
        pr = playerArr[0] + ~~(rLen / 2) + 1 - bgLen;
        sr = bgLen - rLen + pr;
      } else {
        sr = playerArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (playerArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (playerArr[1] - ~~(rLen / 2));
      } else if (playerArr[1] + ~~(rLen / 2) + 1 > bgLen) {
        pc = playerArr[1] + ~~(rLen / 2) + 1 - bgLen;
        sc = bgLen - rLen + pc;
      } else {
        sc = playerArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = bgArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      tempCtx.fillRect(0, 0, px, px);
      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el > air) {
            img = el < flr ? wallImg : flrImg;
            map = el < flr ? wallImgMap : flrImgMap;
            srcX = map['' + el][0];
            srcY = map['' + el][1];
            tempCtx.drawImage(img, srcX, srcY, ts, ts, sx + j * ts, sy + i * ts, ts, ts);
          }
        }
      }

      dCtx.drawImage(tempCanv, 0, 0);
      this.setState({ playerLoc: [].concat(_toConsumableArray(playerArr)) });
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getBgImages();
      this.initTempCanvas();
      this.initPaletteMaps();

      var _backgroundArray = backgroundArray(this.props.boardSize),
          bgArr = _backgroundArray.bgArr,
          floorCoords = _backgroundArray.floorCoords,
          hWallCoords = _backgroundArray.hWallCoords,
          vWallCoords = _backgroundArray.vWallCoords;

      this.props.updateBgArr(bgArr, floorCoords, hWallCoords, vWallCoords);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel && nextProps.gameLevel !== 0) {
        var _backgroundArray2 = backgroundArray(this.props.boardSize),
            bgArr = _backgroundArray2.bgArr,
            floorCoords = _backgroundArray2.floorCoords,
            hWallCoords = _backgroundArray2.hWallCoords,
            vWallCoords = _backgroundArray2.vWallCoords;

        this.props.updateBgArr(bgArr, floorCoords, hWallCoords, vWallCoords);

        if (this.state.floorImg) {
          this.setPalettes(this.state.floorImg, this.state.wallImg, nextProps.gameLevel);
        }
      }

      if (nextProps.playerArr !== this.state.playerLoc && nextProps.playerArr !== [0, 0] && this.state.floorPalette.canvas) {
        this.drawBackground(nextProps, this.state);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'bg-layer',
        className: 'bg-layer',
        width: size,
        height: size });
    }
  }]);

  return BackgroundLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, inventory, itemPalettes, interactItem, quickConsume, updateGameClassState
var ConsumableItems = function (_React$Component) {
  _inherits(ConsumableItems, _React$Component);

  function ConsumableItems(props) {
    _classCallCheck(this, ConsumableItems);

    var _this = _possibleConstructorReturn(this, (ConsumableItems.__proto__ || Object.getPrototypeOf(ConsumableItems)).call(this, props));

    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.updateConsumeCanvas = _this.updateConsumeCanvas.bind(_this);

    _this.state = {
      cItems: ['potion', 'hiPotion', 'xPotion', 'tomeOfVitality', 'tomeOfDurability', 'tomeOfStrength', 'tomeOfAgility', 'tomeOfWisdom']
    };
    return _this;
  }

  _createClass(ConsumableItems, [{
    key: 'handleInteractItem',
    value: function handleInteractItem(nextProps) {
      var num = nextProps.quickConsume.num,
          inv = nextProps.inventory,
          interactItem = Object.assign({}, nextProps.interactItem),
          m = consumableAbbrevMap;

      var name = '',
          item = null,
          props = null;

      for (props in m) {
        if (num == m[props].num) name = m[props].name;
      }

      item = inv[name];

      if (item && item.count > 0) {
        interactItem.count += 1;
        interactItem.type = 'use';
        interactItem.item = item;

        nextProps.updateGameClassState({ interactItem: interactItem });
      }
    }
  }, {
    key: 'updateConsumeCanvas',
    value: function updateConsumeCanvas(nextProps) {
      var item = nextProps.interactItem.item,
          action = nextProps.interactItem.type,
          m = consumableAbbrevMap;

      var props = null,
          dCtx = null,
          palette = null,
          loc = [],
          update = false;

      if (action === 'pickup' && item.count === 1) {
        update = true;
      } else if (action === 'use' && item.count === 0) {
        update = true;
      }

      if (update) {
        for (props in m) {
          if (item.name === m[props].name) dCtx = getById(props + '-canvas').getContext('2d');
        }

        palette = nextProps.itemPalettes[item.palette];
        loc = item.iconLoc;

        if (action === 'use') dCtx.clearRect(0, 0, loc[2], loc[3]);else dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.quickConsume.count !== nextProps.quickConsume.count && nextProps.quickConsume.count) {
        this.handleInteractItem(nextProps);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count && ['pickup', 'use'].includes(nextProps.interactItem.type) && nextProps.interactItem.item.type === 'consumable') {
        this.updateConsumeCanvas(nextProps);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var m = consumableAbbrevMap,
          itm = this.state.cItems,
          inv = this.props.inventory,
          ts = this.props.tileSize;

      var output = [],
          count = 0;

      output = itm.map(function (el) {
        count = 0;
        if (inv[m[el].name]) count = inv[m[el].name].count;
        return React.createElement(
          'div',
          { className: 'consumable-col', key: 'consumable-col' + m[el].num },
          React.createElement(
            'p',
            { className: 'consumable-col-num', key: 'consumable-col-num' + m[el].num },
            m[el].num
          ),
          React.createElement('canvas', {
            id: el + '-canvas',
            className: 'consumable-canvas',
            key: el + '-canvas',
            width: ts,
            height: ts }),
          React.createElement(
            'p',
            { className: 'consumable-col-abbrev', key: 'consumable-col-abbrev' + m[el].num },
            m[el].abbrev
          ),
          React.createElement(
            'p',
            { className: 'consumable-col-count', key: 'consumable-col-count' + m[el].num },
            'x' + count
          )
        );
      });

      return React.createElement(
        'div',
        { className: 'consumable-items' },
        output
      );
    }
  }]);

  return ConsumableItems;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, tileSize, floor, gameLevel, levels, hero, playerArr, bgArr, updateBgArr, floorCoords,
//updateFloorCoords, updatePlayerArr, itemArr, itemPalettes, updateGameClassState, itemPaletteArrMap
//inventory, interactItem, heroFacing
var GameStage = function (_React$Component) {
  _inherits(GameStage, _React$Component);

  function GameStage(props) {
    _classCallCheck(this, GameStage);

    var _this = _possibleConstructorReturn(this, (GameStage.__proto__ || Object.getPrototypeOf(GameStage)).call(this, props));

    _this.updateAccArr = _this.updateAccArr.bind(_this);

    _this.state = {
      stageSize: 480,
      accArr: []
    };
    return _this;
  }

  _createClass(GameStage, [{
    key: 'updateAccArr',
    value: function updateAccArr(accArr) {
      this.setState({ accArr: accArr });
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'stage' },
        React.createElement(BackgroundLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgArr: this.props.bgArr,
          updateBgArr: this.props.updateBgArr,
          playerArr: this.props.playerArr }),
        React.createElement(AccentLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          accArr: this.state.accArr,
          updateAccArr: this.updateAccArr }),
        React.createElement(ItemLayer, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          levels: this.props.levels,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          floorCoords: this.props.floorCoords,
          itemArr: this.props.itemArr,
          itemPalettes: this.props.itemPalettes,
          itemPaletteArrMap: this.props.itemPaletteArrMap,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(PlayerLayer, {
          stageSize: this.state.stageSize,
          tileSize: this.props.tileSize,
          hero: this.props.hero,
          heroFacing: this.props.heroFacing,
          gameLevel: this.props.gameLevel,
          bgArr: this.props.bgArr,
          playerArr: this.props.playerArr,
          floorCoords: this.props.floorCoords,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(OptionOverlay, {
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          overlayMode: this.props.overlayMode,
          updateGameClassState: this.props.updateGameClassState })
      );
    }
  }]);

  return GameStage;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, hero, heroIcon, inventory, itemPalettes, interactItem, updateGameClassState
var Hero = function (_React$Component) {
  _inherits(Hero, _React$Component);

  function Hero(props) {
    _classCallCheck(this, Hero);

    var _this = _possibleConstructorReturn(this, (Hero.__proto__ || Object.getPrototypeOf(Hero)).call(this, props));

    _this.initHero = _this.initHero.bind(_this);
    _this.changeStats = _this.changeStats.bind(_this);
    _this.handleLevelUp = _this.handleLevelUp.bind(_this);
    _this.paintHeroIcon = _this.paintHeroIcon.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.updateEquipCanvas = _this.updateEquipCanvas.bind(_this);

    _this.state = {
      heroName: "",
      experience: 0,
      expToLevel: 0,
      charLevel: 0,
      gold: 0,
      curHealth: 0,
      bHealth: 0,
      bAttack: 0,
      bDefense: 0,
      bHit: 0,
      bCrit: 0,
      bDodge: 0,
      bVitality: 0,
      bDurability: 0,
      bStrength: 0,
      bAgility: 0,
      statPoints: 0,
      onLevelUp: {},
      head: null,
      weapon: null,
      amulet: null,
      armor: null,
      shield: null,
      glove: null,
      ring: null,
      foot: null,
      iHealth: 0,
      iAttack: 0,
      iDefense: 0,
      iHit: 0,
      iCrit: 0,
      iDodge: 0,
      iVitality: 0,
      iDurability: 0,
      iStrength: 0,
      iAgility: 0,
      bExpToLevel: 100,
      expLevelMult: 1.75,
      interactItemCount: 0
    };
    return _this;
  }

  _createClass(Hero, [{
    key: 'initHero',
    value: function initHero(hero) {
      var char = Object.assign({}, heroTypeStats[hero]),
          bHp = char.health,
          bVit = char.vitality,
          bDur = char.durability,
          conv = statConversion;

      this.setState({
        heroName: char.heroName,
        charLevel: 1,
        expToLevel: this.state.bExpToLevel,
        curHealth: bHp + conv.vitToHp * bVit + conv.durToHp * bDur,
        bHealth: bHp,
        bAttack: char.attack,
        bDefense: char.defense,
        bHit: char.hit,
        bCrit: char.crit,
        bDodge: char.dodge,
        bVitality: bVit,
        bDurability: bDur,
        bStrength: char.strength,
        bAgility: char.agility,
        onLevelUp: char.onLevelUp
      });
    }
  }, {
    key: 'paintHeroIcon',
    value: function paintHeroIcon(icon) {
      var ctx = document.getElementById('hero-icon').getContext('2d');

      ctx.drawImage(icon, 0, 0);
    }
  }, {
    key: 'changeStats',
    value: function changeStats(stats) {
      var decStats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var attr = Object.assign({}, stats),
          decAttr = Object.assign({}, decStats);

      var newState = Object.assign({}, this.state),
          prop = null;

      for (prop in attr) {
        newState[prop] += attr[prop];
      }for (prop in decAttr) {
        newState[prop] -= decAttr[prop];
      }return newState;
    }
  }, {
    key: 'handleLevelUp',
    value: function handleLevelUp(lvl) {
      var onLvl = this.state.onLevelUp,
          bHealth = this.state.bHealth + onLvl.health,
          bVitality = this.state.bVitality + onLvl.vitality,
          bDurability = this.state.bDurability + onLvl.durability,
          iHealth = this.state.iHealth,
          iVitality = this.state.iVitality,
          iDurability = this.state.durability,
          conv = statConversion,
          maxHealth = bHealth + iHealth + conv.vitToHp * (bVitality + iVitality) + conv.durToHp * (bDurability + iDurability),
          lvlUpPoints = 2;

      this.setState(function (prevState, props) {
        return {
          expToLevel: prevState.expLevelMult * prevState.expToLevel,
          bHealth: prevState.bHealth + onLvl.health,
          bAttack: prevState.bAttack + onLvl.attack,
          bDefense: prevState.bDefense + onLvl.defense,
          bVitality: prevState.bVitality + onLvl.vitality,
          bDurability: prevState.bDurability + onLvl.durability,
          bStrength: prevState.bStrength + onLvl.strength,
          bAgility: prevState.bAgility + onLvl.agility,
          statPoints: prevState.statPoints + lvlUpPoints,
          curHealth: maxHealth
        };
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(nextProps) {
      var inventory = Object.assign({}, nextProps.inventory),
          item = inventory[nextProps.interactItem.item.name],
          updateInventory = false,
          updateCanvas = false,
          curItem = null,
          nState = {},
          maxHp = 0,
          hp = 0,
          vit = 0,
          dur = 0;

      var action = nextProps.interactItem.type,
          conv = statConversion,
          stats = item.stats,
          iType = item.type;

      if (action === 'pickup' && item.type === 'gold') nState = this.changeStats(stats);else if (action === 'use') {
        updateInventory = true;
        item.count -= 1;

        nState = this.changeStats(stats);
      } else if (action === 'unequip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];
        inventory[curItem.name].equipped = false;

        nState = this.changeStats({}, curItem.stats);
        nState[iType] = null;
      } else if (action === 'equip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];

        if (curItem) {
          inventory[curItem.name].equipped = false;
          nState = this.changeStats(stats, curItem.stats);
        } else nState = this.changeStats(stats);

        item.equipped = true;
        nState[iType] = item;
      }

      hp = nState.bHealth + nState.iHealth;
      vit = nState.iVitality + nState.bVitality;
      dur = nState.iDurability + nState.bDurability;
      maxHp = hp + conv.vitToHp * vit + conv.durToHp * dur;

      if (nState.curHealth > maxHp) nState.curHealth = maxHp;
      if (updateCanvas) this.updateEquipCanvas(item);
      if (updateInventory) this.props.updateGameClassState({ inventory: inventory });

      this.setState(nState);
    }
  }, {
    key: 'updateEquipCanvas',
    value: function updateEquipCanvas(item) {
      var palette = this.props.itemPalettes[item.palette],
          loc = item.iconLoc;

      var dCtx = getById(item.type + '-canvas').getContext('2d');

      dCtx.clearRect(0, 0, loc[2], loc[3]);

      if (item.equipped) {
        dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.state.heroName === "" && nextProps.hero) {
        this.initHero(nextProps.hero);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count) {

        console.log('interactItem');
        console.log(nextProps.interactItem.type, nextProps.interactItem.item.name);

        this.handleInteractItem(nextProps);
      }
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.props.heroIcon !== nextProps.heroIcon && nextProps.heroIcon) {
        this.paintHeroIcon(nextProps.heroIcon);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var ts = this.props.tileSize,
          none = 'None',
          conv = statConversion,
          lvl = this.state.charLevel,
          curHp = this.state.curHealth,
          gold = this.state.gold,
          exp = this.state.experience,
          expToLvl = this.state.expToLevel,
          vit = this.state.bVitality + this.state.iVitality,
          dur = this.state.bDurability + this.state.iDurability,
          str = this.state.bStrength + this.state.iStrength,
          agi = this.state.bAgility + this.state.iAgility,
          atk = this.state.bAttack + this.state.iAttack + conv.strToAtk * str,
          def = this.state.bDefense + this.state.iDefense + conv.durToDef * dur + conv.strToDef * str,
          maxHp = this.state.bHealth + this.state.iHealth + conv.vitToHp * vit + conv.durToHp * dur,
          hed = this.state.head ? this.state.head.name : none,
          wep = this.state.weapon ? this.state.weapon.name : none,
          amu = this.state.amulet ? this.state.amulet.name : none,
          bod = this.state.armor ? this.state.armor.name : none,
          shd = this.state.shield ? this.state.shield.name : none,
          glv = this.state.glove ? this.state.glove.name : none,
          rng = this.state.ring ? this.state.ring.name : none,
          ft = this.state.foot ? this.state.foot.name : none;

      return React.createElement(
        'div',
        { className: 'hero' },
        React.createElement(
          'p',
          { className: 'hero-heading' },
          'Character Info'
        ),
        React.createElement(
          'div',
          { className: 'hero-type' },
          React.createElement('canvas', { id: 'hero-icon', className: 'hero-icon', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Name: ',
              this.state.heroName
            ),
            React.createElement(
              'p',
              null,
              'Type: ',
              this.props.hero
            )
          )
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Level: ',
          lvl
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Health: ',
          curHp,
          '/',
          maxHp
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Gold: ',
          gold
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Exp: ',
          exp,
          '/',
          expToLvl
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Atk: ',
          atk
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Def: ',
          def
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Vit: ',
          vit
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Dur: ',
          dur
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Str: ',
          str
        ),
        React.createElement(
          'p',
          { className: 'stat-row' },
          'Agi: ',
          agi
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'head-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Head'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              hed
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'weapon-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Weapon'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              wep
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'amulet-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Amulet'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              amu
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'armor-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Armor'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              bod
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'shield-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Shield'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              shd
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'glove-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Glove'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              glv
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'ring-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Ring'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              rng
            )
          )
        ),
        React.createElement(
          'div',
          { className: 'equip-row' },
          React.createElement('canvas', { id: 'foot-canvas', className: 'equip-canv', width: ts, height: ts }),
          React.createElement(
            'div',
            { className: 'stat-col' },
            React.createElement(
              'p',
              null,
              'Foot'
            ),
            React.createElement(
              'p',
              { className: 'equip-name' },
              ft
            )
          )
        )
      );
    }
  }]);

  return Hero;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: inventory, interactItem, updateGameClassState
var InventoryOverlay = function (_React$Component) {
  _inherits(InventoryOverlay, _React$Component);

  function InventoryOverlay(props) {
    _classCallCheck(this, InventoryOverlay);

    var _this = _possibleConstructorReturn(this, (InventoryOverlay.__proto__ || Object.getPrototypeOf(InventoryOverlay)).call(this, props));

    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.updateOptFocus = _this.updateOptFocus.bind(_this);
    _this.setList = _this.setList.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);

    _this.state = {
      invCategories: ['Head', 'Amulet', 'Weapon', 'Armor', 'Shield', 'Glove', 'Ring', 'Foot', 'Consumable'],
      bRowId: 'item-row',
      bColId: 'item-col',
      focusClass: 'optFocus',
      row: 0,
      col: 0
    };
    return _this;
  }

  _createClass(InventoryOverlay, [{
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code,
          cats = this.state.invCategories,
          len = cats.length;

      var _state = this.state,
          row = _state.row,
          col = _state.col,
          delta = [];


      if ((el === 'ArrowUp' || el === 'KeyW') && row > 0) delta = [-1, 0];else if ((el === 'ArrowRight' || el === 'KeyD') && col < len - 1) delta = [0, 1];else if (el === 'ArrowDown' || el === 'KeyS') delta = [1, 0];else if ((el === 'ArrowLeft' || el === 'KeyA') && col > 0) delta = [0, -1];else if (el === 'KeyI' || el === 'KeyE') this.props.updateGameClassState({ overlayMode: 'off' });else if ((el === 'Space' || el === 'Enter') && getById(this.state.bRowId + this.state.row)) {
        var name = getById(this.state.bRowId + row).querySelectorAll('span')[1].innerText,
            type = this.state.invCategories[this.state.col].toLowerCase();

        this.handleInteractItem(name);
      }

      if (delta.length > 0) this.updateOptFocus([row, col], delta);
    }
  }, {
    key: 'updateOptFocus',
    value: function updateOptFocus(coordsArr) {
      var deltaArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var bIds = [this.state.bRowId, this.state.bColId];

      var update = false,
          nextVal = '',
          nState = {};

      if (deltaArr[1] !== 0) {
        nState['row'] = 0;
        nextVal = coordsArr[1] + deltaArr[1];

        if (getById(bIds[1] + nextVal)) nState['col'] = nextVal;
      } else {
        nextVal = coordsArr[0] + deltaArr[0];

        if (getById(bIds[0] + nextVal)) nState['row'] = nextVal;
      }

      if (nState.hasOwnProperty('row')) {
        update = true;
        this.setState(nState);
      }

      return update;
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'setList',
    value: function setList(inv, header) {
      var conv = statConvertWordMap;

      var list = [],
          props = null,
          p = null,
          el = null,
          equipped = '',
          stats = '';

      for (props in inv) {
        if (inv[props].type === header && inv[props].count > 0) {
          el = inv[props];
          stats = '';

          for (p in el.stats) {
            stats += '' + conv[p] + el.stats[p] + ' ';
          }if (el.type === 'consumable') list.push([el.count, el.name, stats]);else equipped = el.equipped ? 'E' : ' ', list.push([equipped, el.name, stats]);
        }
      }
      return list;
    }
  }, {
    key: 'setItems',
    value: function setItems(list, colNames, bRowId) {
      var _this2 = this;

      var row = this.state.row;

      var classes = '';

      return [].concat(_toConsumableArray(Array(list.length))).map(function (x, i) {
        classes = i === row ? bRowId + ' ' + _this2.state.focusClass : bRowId;
        return React.createElement(
          'div',
          { id: bRowId + i, className: classes, key: list[i][1] },
          React.createElement(
            'span',
            { className: colNames[0].toLowerCase() + '-col', key: list[i][0] },
            list[i][0]
          ),
          React.createElement(
            'span',
            { className: colNames[1].toLowerCase() + '-col', key: list[i][1] + '-col' },
            list[i][1]
          ),
          React.createElement(
            'span',
            { className: colNames[2].toLowerCase() + '-col', key: list[i][2] },
            list[i][2]
          )
        );
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(name) {
      var item = this.props.inventory[name],
          cats = this.state.invCategories;

      var interactItem = Object.assign({}, this.props.interactItem),
          action = '';

      action = item.type === cats[cats.length - 1].toLowerCase() ? 'use' : item.equipped ? 'unequip' : 'equip';

      interactItem.count += 1;
      interactItem.type = action;
      interactItem.item = item;

      this.props.updateGameClassState({ interactItem: interactItem });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this3.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var cats = [].concat(_toConsumableArray(this.state.invCategories)),
          _state2 = this.state,
          row = _state2.row,
          col = _state2.col,
          bRowId = _state2.bRowId,
          bColId = _state2.bColId,
          focusClass = _state2.focusClass,
          header = cats[col].toLowerCase(),
          inv = this.props.inventory,
          abbrev = equipAbbrevMap;


      var colHeaders = null,
          iHeaders = null,
          items = null,
          classes = '';

      var colNames = header === 'consumable' ? ['Quantity', 'Name', 'Stats'] : ['Equipped', 'Name', 'Stats'];

      var list = this.setList(inv, header);

      colHeaders = cats.map(function (x, i) {
        classes = i === col ? bColId + ' ' + focusClass : bColId;
        return React.createElement(
          'span',
          { id: bColId + i, className: classes, key: x },
          abbrev[x]
        );
      });

      iHeaders = [].concat(_toConsumableArray(Array(colNames.length))).map(function (x, i) {
        return React.createElement(
          'span',
          { className: 'item-header item-header-' + i, key: colNames[i] },
          colNames[i]
        );
      });

      items = this.setItems(list, colNames, bRowId);

      return React.createElement(
        'div',
        { id: 'inv-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'inv-header' },
          'Inventory'
        ),
        React.createElement(
          'div',
          { className: 'inv-categories' },
          colHeaders
        ),
        React.createElement(
          'div',
          { className: 'item-list' },
          React.createElement(
            'div',
            { className: 'iheader-row' },
            iHeaders
          ),
          items
        )
      );
    }
  }]);

  return InventoryOverlay;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, stageSize, tileSize, gameLevel, levels, bgArr, itemArr, updateGameClassState
//playerArr, itemPalettes, floorCoords, itemPaletteArrMap
var ItemLayer = function (_React$Component) {
  _inherits(ItemLayer, _React$Component);

  function ItemLayer(props) {
    _classCallCheck(this, ItemLayer);

    var _this = _possibleConstructorReturn(this, (ItemLayer.__proto__ || Object.getPrototypeOf(ItemLayer)).call(this, props));

    _this.initItemArr = _this.initItemArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getItemImages = _this.getItemImages.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setSpawnQuants = _this.setSpawnQuants.bind(_this);
    _this.setItemArr = _this.setItemArr.bind(_this);
    _this.drawItems = _this.drawItems.bind(_this);

    _this.state = {
      srcTileSize: 16,
      itemTypes: [],
      images: {},
      spawnQuants: [],
      tempCanv: null,
      lvlProcessed: 0
    };
    return _this;
  }

  _createClass(ItemLayer, [{
    key: 'initItemArr',
    value: function initItemArr() {
      var len = this.props.boardSize,
          itemArr = initZeroArray(len);

      this.props.updateGameClassState({ itemArr: itemArr });
    }
  }, {
    key: 'getItemImages',
    value: function getItemImages() {
      var path = 'img/items/',
          type = '.png',
          that = this;

      var amuletImg = void 0,
          armorImg = void 0,
          bookImg = void 0,
          bootImg = void 0,
          chest0Img = void 0,
          chest1Img = void 0,
          gloveImg = void 0,
          hatImg = void 0,
          longWepImg = void 0,
          medWepImg = void 0,
          moneyImg = void 0,
          potionImg = void 0,
          ringImg = void 0,
          shieldImg = void 0,
          shortWepImg = void 0,
          wandImg = void 0,
          images = {
        amuletImg: amuletImg,
        armorImg: armorImg,
        bookImg: bookImg,
        bootImg: bootImg,
        chest0Img: chest0Img,
        chest1Img: chest1Img,
        gloveImg: gloveImg,
        hatImg: hatImg,
        longWepImg: longWepImg,
        medWepImg: medWepImg,
        moneyImg: moneyImg,
        potionImg: potionImg,
        ringImg: ringImg,
        shieldImg: shieldImg,
        shortWepImg: shortWepImg,
        wandImg: wandImg
      },
          el = void 0,
          iLen = 0,
          i = 0;

      var handleItemLoad = function handleItemImageLoad() {
        i++;
        if (i === iLen) {
          that.setState({ images: images });
          that.setPalettes(images);
        }
      };

      for (el in images) {
        images[el] = new Image();
        images[el].src = path + el[0].toUpperCase() + el.slice(1, -3) + type;
        images[el].addEventListener('load', handleItemLoad);
        iLen++;
      }
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var size = this.props.stageSize,
          smoothRender = false,
          tempCanv = initMemCanvas(size, size, smoothRender);

      this.setState({ tempCanv: tempCanv });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var ts = this.props.tileSize,
          srcTs = this.state.srcTileSize,
          scale = ts / srcTs,
          renderSmoothing = false,
          imgPixDataName = 'imgPixData';

      var itemPalettes = {},
          p = null,
          el = null,
          ctx = null,
          img = null,
          name = '',
          w = 0,
          h = 0;

      for (el in images) {
        img = images[el];
        name = el.slice(0, -3) + 'Palette';
        w = img.width;
        h = img.height;
        p = itemPalettes;
        p[name] = document.createElement('canvas');
        p[name].width = scale * w;
        p[name].height = scale * h;
        ctx = p[name].getContext('2d');
        ctx.imageSmoothingEnabled = renderSmoothing;
        ctx.drawImage(img, 0, 0, w, h, 0, 0, p[name].width, p[name].height);
        p[name][imgPixDataName] = ctx.getImageData(0, 0, p[name].width, p[name].height).data;
      }

      this.props.updateGameClassState({ itemPalettes: itemPalettes });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap() {
      var itemTypes = [itemAmulets, itemArmors, itemFeet, itemGloves, itemHelmets, itemRings, itemShields, itemWeapons, itemConsumables, chestConsumables];

      var itemPaletteArrMap = {},
          i = 101,
          props = null;

      itemTypes.forEach(function (el) {
        for (props in el) {
          el[props]['itemArrVal'] = i;
          itemPaletteArrMap['' + i] = el[props];
          i++;
        }
      });

      this.setSpawnQuants(itemTypes);
      this.setState({ itemTypes: itemTypes });
      this.props.updateGameClassState({ itemPaletteArrMap: itemPaletteArrMap });
    }
  }, {
    key: 'setSpawnQuants',
    value: function setSpawnQuants(itemTypes) {
      var levels = this.props.levels,
          valKey = 'itemArrVal';

      var spawnQuants = [],
          item = [],
          spawnObj = {},
          props = null,
          lvl = 0,
          val = 0,
          i = 0;

      spawnQuants.length = levels;
      while (i < levels) {
        spawnQuants[i] = [], i++;
      }itemTypes.forEach(function (el) {
        for (props in el) {
          spawnObj = el[props];
          val = spawnObj[valKey];
          for (lvl in spawnObj.spawnQuant) {
            item = [val, spawnObj.spawnQuant[lvl]];
            spawnQuants[lvl * 1 - 1].push(item);
          }
        }
      });

      this.setState({ spawnQuants: spawnQuants });
    }
  }, {
    key: 'setItemArr',
    value: function setItemArr(nextProps, nextState) {
      var quants = nextState.spawnQuants,
          lvl = nextProps.gameLevel;

      var itemArr = [].concat(_toConsumableArray(nextProps.itemArr)),
          floorCoords = [].concat(_toConsumableArray(nextProps.floorCoords)),
          len = itemArr.length,
          fLen = floorCoords.length,
          coord = [],
          index = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          itemArr[i][j] = 0, j++;
        }j = 0, i++;
      }

      quants[lvl - 1].forEach(function (el) {
        for (i = 0; i < el[1]; i++) {
          index = randInt(0, fLen);
          coord = floorCoords[index];
          itemArr[coord[0]][coord[1]] = el[0];
          floorCoords.splice(index, 1);
          fLen--;
        }
      });

      this.setState({ lvlProcessed: lvl });
      this.props.updateGameClassState({ floorCoords: floorCoords, itemArr: itemArr });
    }
  }, {
    key: 'drawItems',
    value: function drawItems(nextProps) {
      var iArr = nextProps.itemArr,
          pArr = nextProps.playerArr,
          map = nextProps.itemPaletteArrMap,
          pals = nextProps.itemPalettes,
          ts = nextProps.tileSize,
          px = nextProps.stageSize,
          iLen = iArr.length,
          rLen = px / ts;

      var dCtx = document.getElementById('item-layer').getContext('2d'),
          tempCanv = this.state.tempCanv,
          tempCtx = tempCanv.getContext('2d'),
          tImgData = tempCtx.createImageData(px, px),
          tImgPixData = tImgData.data,
          renderArr = [],
          iData = 0,
          pData = 0,
          sr = 0,
          sc = 0,
          pr = 0,
          pc = 0,
          sx = 0,
          sy = 0,
          img = null,
          imgW = 0,
          m = [],
          el = 0,
          srcX = 0,
          srcY = 0,
          dX = 0,
          dY = 0,
          h = 0,
          w = 0,
          i = 0,
          j = 0;

      //Use helper functions if performance is acceptable
      //const padding = calcRenderPadding(playerArr, iLen, rLen);
      //const renderArr = setRenderArr(itemArr, rLen, padding);

      if (pArr[0] - ~~(rLen / 2) < 0) {
        sr = 0;
        pr = -1 * (pArr[0] - ~~(rLen / 2));
      } else if (pArr[0] + ~~(rLen / 2) + 1 > iLen) {
        pr = pArr[0] + ~~(rLen / 2) + 1 - iLen;
        sr = iLen - rLen + pr;
      } else {
        sr = pArr[0] - ~~(rLen / 2);
        pr = 0;
      }
      if (pArr[1] - ~~(rLen / 2) < 0) {
        sc = 0;
        pc = -1 * (pArr[1] - ~~(rLen / 2));
      } else if (pArr[1] + ~~(rLen / 2) + 1 > iLen) {
        pc = pArr[1] + ~~(rLen / 2) + 1 - iLen;
        sc = iLen - rLen + pc;
      } else {
        sc = pArr[1] - ~~(rLen / 2);
        pc = 0;
      }

      renderArr.length = rLen - pr;
      while (i < rLen - pr) {
        renderArr[i] = [];
        renderArr[i].length = rLen - pc;
        while (j < rLen - pc) {
          renderArr[i][j] = iArr[sr + i][sc + j], j++;
        }j = 0, i++;
      }

      sx = !sc && pc ? pc * ts : 0;
      sy = !sr && pr ? pr * ts : 0;

      for (i = 0; i < renderArr.length; i++) {
        for (j = 0; j < renderArr[i].length; j++) {
          el = renderArr[i][j];
          if (el) {
            m = ['consumable', 'gold', 'openChest'].includes(map['' + el].type) ? map['' + el] : chestConsumables.closedChest;;
            img = pals[m.palette].imgPixData;
            imgW = pals[m.palette].width;
            srcX = m.iconLoc[0];
            srcY = m.iconLoc[1];
            dX = sx + j * ts;
            dY = sy + i * ts;
            h = 0;

            while (h < ts) {
              w = 0;
              while (w < ts) {
                pData = (dX + w + (dY + h) * px) * 4;
                iData = (srcX + w + (srcY + h) * imgW) * 4;

                tImgPixData[pData] = img[iData];
                tImgPixData[pData + 1] = img[iData + 1];
                tImgPixData[pData + 2] = img[iData + 2];
                tImgPixData[pData + 3] = img[iData + 3];
                w++;
              }
              h++;
            }
          }
        }
      }

      dCtx.putImageData(tImgData, 0, 0);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getItemImages();
      this.initItemArr();
      this.initTempCanvas();
      this.setPaletteArrMap();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if ((this.props.playerArr[0] !== nextProps.playerArr[0] || this.props.playerArr[1] !== nextProps.playerArr[1]) && nextProps.itemPalettes.potionPalette) {

        this.drawItems(nextProps);
      }
      if (nextState.lvlProcessed !== nextProps.gameLevel && (this.props.floorCoords.length !== nextProps.floorCoords.length || !this.props.floorCoords.every(function (arr, i) {
        return arr.every(function (el, j) {
          return el === nextProps.floorCoords[i][j];
        });
      }))) {

        this.setItemArr(nextProps, nextState);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'item-layer',
        className: 'item-layer',
        width: size,
        height: size });
    }
  }]);

  return ItemLayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: inventory, interactItem, overlayMode, updateGameClassState
var OptionOverlay = function (_React$Component) {
  _inherits(OptionOverlay, _React$Component);

  function OptionOverlay() {
    _classCallCheck(this, OptionOverlay);

    return _possibleConstructorReturn(this, (OptionOverlay.__proto__ || Object.getPrototypeOf(OptionOverlay)).apply(this, arguments));
  }

  _createClass(OptionOverlay, [{
    key: 'render',
    value: function render() {
      var mode = this.props.overlayMode;

      var content = null;

      if (mode === 'inv-overlay') {
        content = React.createElement(InventoryOverlay, {
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          updateGameClassState: this.props.updateGameClassState });
      }

      return React.createElement(
        'div',
        null,
        content
      );
    }
  }]);

  return OptionOverlay;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, tileSize, hero, heroFacing, gameLevel, bgArr, playerArr, updateGameClassState,
//floorCoords
var PlayerLayer = function (_React$Component) {
  _inherits(PlayerLayer, _React$Component);

  function PlayerLayer(props) {
    _classCallCheck(this, PlayerLayer);

    var _this = _possibleConstructorReturn(this, (PlayerLayer.__proto__ || Object.getPrototypeOf(PlayerLayer)).call(this, props));

    _this.getPlayerImages = _this.getPlayerImages.bind(_this);
    _this.initPaletteMap = _this.initPaletteMap.bind(_this);
    _this.setPalette = _this.setPalette.bind(_this);
    _this.setHeroIcon = _this.setHeroIcon.bind(_this);
    _this.pickPlayerStart = _this.pickPlayerStart.bind(_this);
    _this.drawPlayer = _this.drawPlayer.bind(_this);

    _this.state = {
      srcTileSize: 16,
      mageImg: null,
      rogueImg: null,
      paladinImg: null,
      warriorImg: null,
      playerPalette: null,
      playerPaletteMap: {}
    };
    return _this;
  }

  _createClass(PlayerLayer, [{
    key: 'getPlayerImages',
    value: function getPlayerImages() {
      var mageImg = new Image(),
          rogueImg = new Image(),
          paladinImg = new Image(),
          warriorImg = new Image(),
          that = this;

      var i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 4) {
          that.setState({ mageImg: mageImg, rogueImg: rogueImg, paladinImg: paladinImg, warriorImg: warriorImg });

          //temporary palette assignment until start screen is created
          that.setPalette(that.props);
        }
      };

      mageImg.src = 'img/heroes/Mage.png';
      rogueImg.src = 'img/heroes/Rogue.png';
      paladinImg.src = 'img/heroes/Paladin.png';
      warriorImg.src = 'img/heroes/Warrior.png';
      mageImg.addEventListener('load', handleLoad);
      rogueImg.addEventListener('load', handleLoad);
      paladinImg.addEventListener('load', handleLoad);
      warriorImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'initPaletteMap',
    value: function initPaletteMap() {
      var ts = this.props.tileSize,
          w = 4;

      var playerPaletteMap = {},
          j = 0;

      ['down', 'left', 'right', 'up'].forEach(function (el, i) {
        for (j = 0; j < w; j++) {
          playerPaletteMap[el + (j + 1)] = [i * ts, j * ts];
        }
      });

      this.setState({ playerPaletteMap: playerPaletteMap });
    }
  }, {
    key: 'setPalette',
    value: function setPalette(nextProps) {
      var hero = nextProps.hero.toLowerCase(),
          srcImg = this.state[hero + 'Img'],
          srcTS = this.state.srcTileSize,
          gmTS = nextProps.tileSize,
          scale = gmTS / srcTS,
          w = 4 * gmTS,
          h = 4 * gmTS;

      var canvas = document.createElement('canvas'),
          ctx = null;

      canvas.width = w;
      canvas.height = h;
      ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(srcImg, 0, 0, w / scale, h / scale, 0, 0, w, h);

      this.setState({ playerPalette: { canvas: canvas, ctx: ctx } }, this.setHeroIcon(canvas));
    }
  }, {
    key: 'setHeroIcon',
    value: function setHeroIcon(canvas) {
      var w = this.props.tileSize,
          h = w;

      var heroIcon = document.createElement('canvas'),
          hCtx = null;

      heroIcon.width = w;
      heroIcon.height = h;
      hCtx = heroIcon.getContext('2d');
      hCtx.imageSmoothingEnabled = false;
      hCtx.drawImage(canvas, 0, 0, w, h, 0, 0, w, h);
      this.props.updateGameClassState({ heroIcon: heroIcon });
    }
  }, {
    key: 'pickPlayerStart',
    value: function pickPlayerStart(nextProps) {
      var playerArr = nextProps.floorCoords[randInt(0, nextProps.floorCoords.length - 1)];
      nextProps.updateGameClassState({ playerArr: playerArr });
    }
  }, {
    key: 'drawPlayer',
    value: function drawPlayer(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var img = this.state.playerPalette.canvas,
          imgD = this.props.tileSize,
          dir = this.props.heroFacing,
          dx = (this.props.stageSize - imgD) / 2,
          dy = dx,
          srcY = dir === 'down' ? 0 : dir === 'left' ? 1 : dir === 'right' ? 2 : 3,
          frameStep = Math.floor((timestamp - timeRef) % 1000 * .06 / 15);

      var canvas = document.getElementById('player-layer'),
          ctx = canvas.getContext('2d');

      ctx.clearRect(dx, dy, imgD, imgD);
      ctx.drawImage(img, frameStep * imgD, srcY * imgD, imgD, imgD, dx, dy, imgD, imgD);
      window.requestAnimationFrame(this.drawPlayer);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getPlayerImages();
      this.initPaletteMap();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.bgArr !== nextProps.bgArr) {
        this.pickPlayerStart(nextProps);
      }
      /*
      if (!this.state.playerPalette && nextProps.hero && this.state.mageImg) {
        this.setPalette(nextProps);
      }
      */
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.playerPalette !== this.state.playerPalette) {
        window.requestAnimationFrame(this.drawPlayer);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'player-layer',
        className: 'player-layer',
        width: size,
        height: size });
    }
  }]);

  return PlayerLayer;
}(React.Component);
'use strict';

/**
 * Consumable Items
 */

var itemConsumables = {
  //Potions
  potion: {
    name: 'Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { curHealth: 50 },
    spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
  },
  hiPotion: {
    name: 'Hi Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { curHealth: 150 },
    spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
  },
  xPotion: {
    name: 'X Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [96, 64, 32, 32],
    buy: 150,
    sell: 75,
    stats: { curHealth: 500 },
    spawnQuant: { '10': 1 }
  },
  //Tomes
  tomeOfVitality: {
    name: 'Tome of Vitality',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 160, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iVitality: 1 },
    spawnQuant: { '3': 1, '6': 1, '9': 1 }
  },
  tomeOfDurability: {
    name: 'Tome of Durability',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iDurability: 1 },
    spawnQuant: { '2': 1, '5': 1, '8': 1 }
  },
  tomeOfStrength: {
    name: 'Tome of Strength',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1, '4': 1, '8': 1 }
  },
  tomeOfAgility: {
    name: 'Tome of Agility',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [64, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iAgility: 1 },
    spawnQuant: { '2': 1, '5': 1, '9': 1 }
  },
  tomeOfWisdom: {
    name: 'Tome of Wisdom',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 160, 32, 32],
    buy: 200,
    sell: 100,
    stats: { statPoints: 1 },
    spawnQuant: { '4': 1, '6': 1, '8': 1, '10': 1 }
  },
  //Gold
  gold1: {
    name: 'a little Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(1, 3);
      } },
    spawnQuant: { '1': 10, '2': 10, '3': 7, '4': 5, '5': 3 }
  },
  gold2: {
    name: 'some Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(4, 7);
      } },
    spawnQuant: { '3': 2, '4': 4, '5': 7, '6': 9, '7': 6, '8': 3, '9': 1 }
  },
  gold3: {
    name: 'a small pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(8, 12);
      } },
    spawnQuant: { '7': 3, '8': 6, '9': 7, '10': 4 }
  },
  gold4: {
    name: 'a pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(13, 17);
      } },
    spawnQuant: { '9': 2, '10': 6 }
  }
};

var chestConsumables = {
  closedChest: {
    name: 'Treasure Chest',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 0, 32, 32]
  },
  openChest: {
    name: 'Treasure Chest',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 0, 32, 32]
  },
  closedBarrel: {
    name: 'Barrel',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 32, 32, 32]
  },
  openBarrel: {
    name: 'Barrel',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 32, 32, 32]
  }
};
'use strict';

/**
 * Amulets
 */

var itemAmulets = {
  //Mage Amulets
  mageAmu1: {
    name: "Damaged Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '3': 1 }
  },
  mageAmu2: {
    name: "Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 12, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  mageAmu3: {
    name: "Enchanted Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 16, iStrength: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Rogue Amulets
  rogueAmu1: {
    name: "Damaged Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueAmu2: {
    name: "Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '5': 1 }
  },
  rogueAmu3: {
    name: "Enchanted Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 8, iStrength: 1, iAgility: 4 },
    spawnQuant: { '7': 1 }
  },
  //Warrior Amulets
  warriorAmu1: {
    name: "Damaged Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorAmu2: {
    name: "Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [196, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iDurability: 1 },
    spawnQuant: { '5': 1 }
  },
  warriorAmu3: {
    name: "Enchanted Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iStrength: 4, iDurability: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Paladin Amulets
  paladinAmu1: {
    name: "Damaged Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinAmu2: {
    name: "Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 3, iDurabilty: 1 },
    spawnQuant: { '5': 1 }
  },
  paladinAmu3: {
    name: "EnchantedAmulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iVitality: 4, iStrength: 1, iDurabilty: 2 },
    spawnQuant: { '7': 1 }
  }
};
'use strict';

/**
 * Armor
 */

var itemArmors = {
  //Mage armor
  clothArm1: {
    name: "Moldy Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iVitality: 1, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothArm2: {
    name: "Adept Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  clothArm3: {
    name: "Shining Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iVitality: 3, iStrength: 2, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  clothArm4: {
    name: "Ancient Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 12, iVitality: 4, iStrength: 3, iDurability: 1 },
    spawnQuant: { '8': 1 }
  },
  clothArm5: {
    name: "Brilliant Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 16, iVitality: 6, iStrength: 3, iDurability: 1 },
    spawnQuant: { '10': 1 }
  },
  //Rogue armor
  leatherArm1: {
    name: "Cracked Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 256, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 1, iAgility: 1 },
    spawnQuant: { '2': 1 }
  },
  leatherArm2: {
    name: "Supple Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 256, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 8, iStrength: 1, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  leatherArm3: {
    name: "Reinforced Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 256, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 2, iAgility: 2 },
    spawnQuant: { '6': 1 }
  },
  leatherArm4: {
    name: "Rune Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 256, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 20, iStrength: 2, iAgility: 4 },
    spawnQuant: { '8': 1 }
  },
  leatherArm5: {
    name: "Dark Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 256, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 20, iStrength: 3, iAgility: 6 },
    spawnQuant: { '10': 1 }
  },
  //Warrior armor
  chainArm1: {
    name: "Rusted Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  chainArm2: {
    name: "Bronze Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 12, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  chainArm3: {
    name: "Reinforced Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [234, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 3, iAgility: 1 },
    spawnQuant: { '6': 1 }
  },
  chainArm4: {
    name: "Rune Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 24, iStrength: 4, iAgility: 1 },
    spawnQuant: { '8': 1 }
  },
  chainArm5: {
    name: "Brilliant Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 28, iStrength: 5, iDurability: 1, iAgility: 1 },
    spawnQuant: { '10': 1 }
  },
  //Paladin armor
  plateArm1: {
    name: "Rusted Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 12 },
    spawnQuant: { '2': 1 }
  },
  plateArm2: {
    name: "Bronze Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 192, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 16, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  plateArm3: {
    name: "Reinforced Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 192, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 24, iDurability: 2 },
    spawnQuant: { '6': 1 }
  },
  plateArm4: {
    name: "Rune Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 32, iVitality: 1, iDurability: 2 },
    spawnQuant: { '8': 1 }
  },
  plateArm5: {
    name: "Brilliant Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [224, 192, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 36, iVitality: 2, iDurability: 3 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

/**
 * Feet
 */

var itemFeet = {
  //Mage Feet
  mageFt1: {
    name: "Tattered Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 1, iStrength: 1, iAgility: 1 },
    spawnQuant: { '4': 1 }
  },
  mageFt2: {
    name: "Fine Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  //Rogue Feet
  rogueFt1: {
    name: "Tattered Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  rogueFt2: {
    name: "Fine Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior Feet
  warriorFt1: {
    name: "Rusted Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  warriorFt2: {
    name: "Fine Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin Feet
  paladinFt1: {
    name: "Rusted Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  paladinFt2: {
    name: "Fine Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 16, iVitality: 1, iDurability: 2 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

/**
 * Gloves
 */

var itemGloves = {
  mageGlv1: {
    name: "Cloth Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [32, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 2, iStrength: 1, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueGlv1: {
    name: "Leather Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorGlv1: {
    name: "Battle Mitts",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [64, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinGlv1: {
    name: "Plate Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [96, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iDurabilty: 2 },
    spawnQuant: { '3': 1 }
  }
};
'use strict';

/**
 * Helmets
 */

var itemHelmets = {
  //Mage Cloth
  clothHead1: {
    name: 'Snazzy Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 3, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothHead2: {
    name: 'Wizard Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 6, iStrength: 4 },
    spawnQuant: { '5': 1 }
  },
  clothHead3: {
    name: 'Enchanted Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 8, iVitality: 12, iStrength: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Rogue Leather
  leatherHead1: {
    name: 'Soft Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  leatherHead2: {
    name: 'Hardened Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iDurability: 1, iAgility: 6 },
    spawnQuant: { '5': 1 }
  },
  leatherHead3: {
    name: 'Rune Leather Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 16, iStrength: 4, iDurability: 2, iAgility: 10 },
    spawnQuant: { '8': 1 }
  },
  //Warrior Mail
  mailHead1: {
    name: 'Chainmail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 2, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  mailHead2: {
    name: 'Platemail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 5, iDurability: 2, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  mailHead3: {
    name: 'Platemail Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 24, iStrength: 8, iDurability: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Paladin Crown
  crownHead1: {
    name: "Desciple's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2 },
    spawnQuant: { '2': 1 }
  },
  crownHead2: {
    name: "Golden Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iVitality: 4, iDurability: 4, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  crownHead3: {
    name: "King's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 96, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 12, iVitality: 10, iDurability: 5, iStrength: 2 },
    spawnQuant: { '8': 1 }
  }
};
'use strict';

/**
 * Rings
 */

var itemRings = {
  //Mage rings
  mageRng1: {
    name: "Damaged Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAttack: 4 },
    spawnQuant: { '1': 1 }
  },
  mageRng2: {
    name: "Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  mageRng3: {
    name: "Enchanted Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iAttack: 12, iVitality: 1, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Rogue rings
  rogueRng1: {
    name: "Damaged Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  rogueRng2: {
    name: "Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iStrength: 1, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  rogueRng3: {
    name: "Enchanted Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 32, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iVitalitY: 1, iStrength: 1, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior rings
  warriorRng1: {
    name: "Damaged Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  warriorRng2: {
    name: "Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDurability: 1, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorRng3: {
    name: "Enchanted Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [96, 96, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDurability: 1, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin rings
  paladinRng1: {
    name: "Damaged Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iVitality: 1 },
    spawnQuant: { '1': 1 }
  },
  paladinRng2: {
    name: "Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 1, iDurability: 1, iStrength: 1 },
    spawnQuant: { '3': 1 }
  },
  paladinRng3: {
    name: "Enchanted Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2, iStrength: 1 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Shields
 */

var itemShields = _defineProperty({
  mageShd1: {
    name: "Arcane Shield",
    type: 'shield',
    palette: 'armorPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 4, iVitality: 2, iStrength: 1, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  rogueShd1: {
    name: "Hardened Buckler",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 8, iDurability: 1, iAgility: 3 },
    spawnQuant: { '6': 1 }
  },
  warriorShd1: {
    name: "Kite Shield of Wrath",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 12, iStrength: 3 },
    spawnQuant: { '6': 1 }
  }
}, 'warriorShd1', {
  name: "Kite Shield of Rightousness",
  type: 'shield',
  palette: 'shieldPalette',
  iconLoc: [192, 0, 32, 32],
  buy: 40,
  sell: 20,
  stats: { iDefense: 12, iVitality: 2, iDurability: 1 },
  spawnQuant: { '6': 1 }
});
'use strict';

/**
 * Weapons
 */

var itemWeapons = {
  //Wands
  wand1: {
    name: 'Bent Stick',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 160, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '1': 1 }
  },
  wand2: {
    name: 'Summoning Fork',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 20 },
    spawnQuant: { '2': 1 }
  },
  wand3: {
    name: 'Scavenged Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 28, iVitality: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  wand4: {
    name: 'Oak Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 52, iVitality: 1, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  wand5: {
    name: 'Rune Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 72, iVitality: 2, iStrength: 2 },
    spawnQuant: { '6': 1 }
  },
  wand6: {
    name: 'Blazing Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 88, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  wand7: {
    name: 'Divining Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 112, iVitality: 4, iStrength: 2, iAgility: 2 },
    spawnQuant: { '10': 1 }
  },
  //Short Weapons
  knife1: {
    name: 'Arrow Head',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  knife2: {
    name: 'Bone Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  knife3: {
    name: 'Fishing Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iAgility: 4 },
    spawnQuant: { '4': 1 }
  },
  knife4: {
    name: 'Jagged Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 1, iAgility: 5 },
    spawnQuant: { '5': 1 }
  },
  knife5: {
    name: 'Rune Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 48, iStrength: 2, iAgility: 6 },
    spawnQuant: { '7': 1 }
  },
  knife6: {
    name: 'Coral Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 68, iStrength: 2, iAgility: 7 },
    spawnQuant: { '9': 1 }
  },
  knife7: {
    name: 'Divining Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 92, iStrength: 3, iAgility: 9 },
    spawnQuant: { '10': 1 }
  },
  //Swords
  sword1: {
    name: 'Rough Club',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  sword2: {
    name: 'Practice Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iStrength: 2 },
    spawnQuant: { '2': 1 }
  },
  sword3: {
    name: 'Short Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iStrength: 4 },
    spawnQuant: { '4': 1 }
  },
  sword4: {
    name: 'Bronze Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 5, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  sword5: {
    name: 'Rune Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 44, iStrength: 7, iAgility: 2 },
    spawnQuant: { '7': 1 }
  },
  sword6: {
    name: 'Coral Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 60, iStrength: 9, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  sword7: {
    name: 'Dark Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 80, iStrength: 11, iAgility: 3 },
    spawnQuant: { '10': 1 }
  },
  // Polearms
  pole1: {
    name: 'Long Pole',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iDurability: 1 },
    spawnQuant: { '1': 1 }
  },
  pole2: {
    name: 'Big Spade',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iVitality: 1, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  pole3: {
    name: 'Trident',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 16, iVitality: 2, iDurability: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  pole4: {
    name: 'Narrow Spear',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 24, iVitality: 3, iDurability: 2, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  pole5: {
    name: 'Rune Voulge',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 64, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 36, iVitality: 4, iDurability: 2, iStrength: 4 },
    spawnQuant: { '7': 1 }
  },
  pole6: {
    name: 'Coral Bardiche',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 48, iVitality: 4, iDurability: 4, iStrength: 5 },
    spawnQuant: { '9': 1 }
  },
  pole7: {
    name: 'Royal Poleaxe',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 72, iVitality: 5, iDurability: 5, iStrength: 5 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var roomSize = {
  '4': { min: 16, max: 30 },
  '6': { min: 14, max: 20 },
  '8': { min: 11, max: 15 }
};

/**
  * React Components
  */

var GameLevel = function (_React$Component) {
  _inherits(GameLevel, _React$Component);

  function GameLevel() {
    _classCallCheck(this, GameLevel);

    return _possibleConstructorReturn(this, (GameLevel.__proto__ || Object.getPrototypeOf(GameLevel)).apply(this, arguments));
  }

  _createClass(GameLevel, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'level' },
        'Game Level'
      );
    }
  }]);

  return GameLevel;
}(React.Component);

var EnemiesRemaining = function (_React$Component2) {
  _inherits(EnemiesRemaining, _React$Component2);

  function EnemiesRemaining() {
    _classCallCheck(this, EnemiesRemaining);

    return _possibleConstructorReturn(this, (EnemiesRemaining.__proto__ || Object.getPrototypeOf(EnemiesRemaining)).apply(this, arguments));
  }

  _createClass(EnemiesRemaining, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'enemies-remaining' },
        'Enemies Remaining'
      );
    }
  }]);

  return EnemiesRemaining;
}(React.Component);

var EnemyStats = function (_React$Component3) {
  _inherits(EnemyStats, _React$Component3);

  function EnemyStats() {
    _classCallCheck(this, EnemyStats);

    return _possibleConstructorReturn(this, (EnemyStats.__proto__ || Object.getPrototypeOf(EnemyStats)).apply(this, arguments));
  }

  _createClass(EnemyStats, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'enemy-stats' },
        'Enemy Stats'
      );
    }
  }]);

  return EnemyStats;
}(React.Component);

var ActivityLog = function (_React$Component4) {
  _inherits(ActivityLog, _React$Component4);

  function ActivityLog() {
    _classCallCheck(this, ActivityLog);

    return _possibleConstructorReturn(this, (ActivityLog.__proto__ || Object.getPrototypeOf(ActivityLog)).apply(this, arguments));
  }

  _createClass(ActivityLog, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'activity-log' },
        'Activity Log'
      );
    }
  }]);

  return ActivityLog;
}(React.Component);

var GameTips = function (_React$Component5) {
  _inherits(GameTips, _React$Component5);

  function GameTips() {
    _classCallCheck(this, GameTips);

    return _possibleConstructorReturn(this, (GameTips.__proto__ || Object.getPrototypeOf(GameTips)).apply(this, arguments));
  }

  _createClass(GameTips, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'tips' },
        'Game Tips'
      );
    }
  }]);

  return GameTips;
}(React.Component);

var Game = function (_React$Component6) {
  _inherits(Game, _React$Component6);

  function Game(props) {
    _classCallCheck(this, Game);

    var _this6 = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this, props));

    _this6.updateBgArr = _this6.updateBgArr.bind(_this6);
    _this6.handleKeyDown = _this6.handleKeyDown.bind(_this6);
    _this6.updatePlayerArr = _this6.updatePlayerArr.bind(_this6);
    _this6.updateGameClassState = _this6.updateGameClassState.bind(_this6);
    _this6.pickupItem = _this6.pickupItem.bind(_this6);
    _this6.focus = _this6.focus.bind(_this6);
    _this6.maintainFocus = _this6.maintainFocus.bind(_this6);
    _this6.endFocus = _this6.endFocus.bind(_this6);

    _this6.state = {
      boardSize: 120,
      tileSize: 32,
      wall: 20,
      floor: 40,
      gameLevel: 8,
      levels: 10,
      hero: 'Mage',
      heroIcon: null,
      heroFacing: '',
      inventory: {},
      playerArr: [],
      bgArr: [],
      itemArr: [],
      floorCoords: [],
      itemPalettes: {},
      itemPaletteArrMap: {},
      interactItem: { count: 0, type: '', item: {} },
      quickConsume: { count: 0, num: 0 },
      //type: pickup, use, equip, unequip, buy, sell
      enemyArr: [],
      enemyPalegges: {},
      enemyPaletteArrMap: {},
      initAttack: { count: 0, stats: {}, coords: {} },
      attackRound: { count: 0, attacks: [] },
      enemyDead: { count: 0, enemy: {} },
      playerDead: false,
      overlayMode: 'off'
      //inv-overlay, inGameOptions, startOptions
    };
    return _this6;
  }

  _createClass(Game, [{
    key: 'updateBgArr',
    value: function updateBgArr(bgArr, floorCoords) {
      this.setState({ bgArr: bgArr, floorCoords: floorCoords });
    }
  }, {
    key: 'updatePlayerArr',
    value: function updatePlayerArr(playerArr) {
      this.setState({ playerArr: [].concat(_toConsumableArray(playerArr)) });
    }
  }, {
    key: 'updateGameClassState',
    value: function updateGameClassState() {
      var updatedEls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setState(updatedEls);
    }
  }, {
    key: 'pickupItem',
    value: function pickupItem(coord, val) {
      var item = Object.assign({}, this.state.itemPaletteArrMap['' + val]),
          inventory = Object.assign({}, this.state.inventory),
          itemArr = [].concat(_toConsumableArray(this.state.itemArr)),
          pArr = this.state.playerArr;

      var nState = {},
          interactItem = Object.assign({}, this.state.interactItem),
          dir = '';

      if (item.type !== 'openChest') {
        if (inventory[item.name]) inventory[item.name].count += 1;else item.count = 1, item.equipped = false, inventory[item.name] = item;

        if (['consumable', 'gold'].includes(item.type)) itemArr[coord[0]][coord[1]] = 0;else itemArr[coord[0]][coord[1]] = chestConsumables.openChest.itemArrVal;

        interactItem.count += 1;
        interactItem.type = 'pickup';
        interactItem.item = item;
        nState = { itemArr: itemArr, inventory: inventory, interactItem: interactItem };

        console.log('Picked up', item.name);
      }

      dir = coord[0] < pArr[0] ? 'up' : coord[0] > pArr[0] ? 'down' : coord[1] < pArr[1] ? 'left' : 'right';

      if (this.state.heroFacing !== dir) nState.heroFacing = dir;

      nState.playerArr = coord;
      this.setState(nState);
    }
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(e) {
      if (this.state.overlayMode === 'off') {

        var el = e.nativeEvent.code,
            arr = [].concat(_toConsumableArray(this.state.playerArr)),
            bg = this.state.bgArr,
            itm = this.state.itemArr,
            flr = this.state.floor,
            dir = this.state.heroFacing,
            len = this.state.boardSize - 1,
            consumeDigits = ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8'];

        var r = arr[0],
            c = arr[1],
            nState = {};

        if (el === 'ArrowUp' || el === 'KeyW') {
          if (r > 0 && bg[r - 1][c] > flr) {
            r--;
            if (itm[r][c]) this.pickupItem([r, c], itm[r][c]);else {
              nState.playerArr = [r, c];
              if (dir !== 'up') nState.heroFacing = 'up';
              this.setState(nState);
            }
          } else if (dir !== 'up') {
            this.setState({ heroFacing: 'up' });
          }
        } else if (el === 'ArrowRight' || el === 'KeyD') {
          if (c < len && bg[r][c + 1] > flr) {
            c++;
            if (itm[r][c]) this.pickupItem([r, c], itm[r][c]);else {
              nState.playerArr = [r, c];
              if (dir !== 'right') nState.heroFacing = 'right';
              this.setState(nState);
            }
          } else if (dir !== 'right') {
            this.setState({ heroFacing: 'right' });
          }
        } else if (el === 'ArrowDown' || el === 'KeyS') {
          if (r < len && bg[r + 1][c] > flr) {
            r++;
            if (itm[r][c]) this.pickupItem([r, c], itm[r][c]);else {
              nState.playerArr = [r, c];
              if (dir !== 'down') nState.heroFacing = 'down';
              this.setState(nState);
            }
          } else if (dir !== 'down') {
            this.setState({ heroFacing: 'down' });
          }
        } else if (el === 'ArrowLeft' || el === 'KeyA') {
          if (c > 0 && bg[r][c - 1] > flr) {
            c--;
            if (itm[r][c]) this.pickupItem([r, c], itm[r][c]);else {
              nState.playerArr = [r, c];
              if (dir !== 'left') nState.heroFacing = 'left';
              this.setState(nState);
            }
          } else if (dir !== 'left') {
            this.setState({ heroFacing: 'left' });
          }
        } else if (el === 'KeyI' || el === 'KeyE') {
          this.setState({ overlayMode: 'inv-overlay' });
        } else if (consumeDigits.includes(el)) {
          this.setState({ quickConsume: { count: this.state.quickConsume.count + 1, num: el.slice(-1) } });
        }
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'maintainFocus',
    value: function maintainFocus() {
      var _this7 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this7.focus();
      }, 250);
    }
  }, {
    key: 'endFocus',
    value: function endFocus() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.maintainFocus();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.state.overlayMode !== nextState.overlayMode) {
        if (nextState.overlayMode === 'off') this.maintainFocus();else this.endFocus();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'game', tabIndex: '0', onKeyDown: this.handleKeyDown },
        React.createElement(
          'div',
          { className: 'col-lft' },
          React.createElement(GameLevel, null),
          React.createElement(Hero, {
            tileSize: this.state.tileSize,
            hero: this.state.hero,
            heroIcon: this.state.heroIcon,
            inventory: this.state.inventory,
            itemPalettes: this.state.itemPalettes,
            interactItem: this.state.interactItem,
            updateGameClassState: this.updateGameClassState })
        ),
        React.createElement(
          'div',
          { className: 'col-mid' },
          React.createElement(
            'div',
            { className: 'title' },
            'CrimsonQuest'
          ),
          React.createElement(GameStage, {
            boardSize: this.state.boardSize,
            tileSize: this.state.tileSize,
            floor: this.state.floor,
            gameLevel: this.state.gameLevel,
            levels: this.state.levels,
            hero: this.state.hero,
            playerArr: this.state.playerArr,
            heroFacing: this.state.heroFacing,
            updatePlayerArr: this.updatePlayerArr,
            bgArr: this.state.bgArr,
            updateBgArr: this.updateBgArr,
            floorCoords: this.state.floorCoords,
            itemArr: this.state.itemArr,
            itemPalettes: this.state.itemPalettes,
            itemPaletteArrMap: this.state.itemPaletteArrMap,
            inventory: this.state.inventory,
            interactItem: this.state.interactItem,
            overlayMode: this.state.overlayMode,
            updateGameClassState: this.updateGameClassState }),
          React.createElement(ConsumableItems, {
            tileSize: this.state.tileSize,
            inventory: this.state.inventory,
            itemPalettes: this.state.itemPalettes,
            interactItem: this.state.interactItem,
            quickConsume: this.state.quickConsume,
            updateGameClassState: this.updateGameClassState })
        ),
        React.createElement(
          'div',
          { className: 'col-rgt' },
          React.createElement(EnemiesRemaining, null),
          React.createElement(EnemyStats, null),
          React.createElement(ActivityLog, null),
          React.createElement(GameTips, null)
        )
      );
    }
  }]);

  return Game;
}(React.Component);

/**
	*		Static Page Components
	*/

/**
	*		@desc React Class renders page header
	*		@returns {HTML} page header
	*/


var PageHeader = function (_React$Component7) {
  _inherits(PageHeader, _React$Component7);

  function PageHeader() {
    _classCallCheck(this, PageHeader);

    return _possibleConstructorReturn(this, (PageHeader.__proto__ || Object.getPrototypeOf(PageHeader)).apply(this, arguments));
  }

  _createClass(PageHeader, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-header' },
        React.createElement(
          'h1',
          null,
          'CrimsonQuest'
        )
      );
    }
  }]);

  return PageHeader;
}(React.Component);

/**
	*		@desc React Class renders page footer
	*		@returns {HTML} page header
	*/


var PageFooter = function (_React$Component8) {
  _inherits(PageFooter, _React$Component8);

  function PageFooter() {
    _classCallCheck(this, PageFooter);

    return _possibleConstructorReturn(this, (PageFooter.__proto__ || Object.getPrototypeOf(PageFooter)).apply(this, arguments));
  }

  _createClass(PageFooter, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-footer' },
        React.createElement(
          'span',
          null,
          '\xA9 2017 Isaac Burbank.'
        ),
        React.createElement(
          'span',
          null,
          'Tiles By\xA0',
          React.createElement(
            'a',
            { href: 'http://opengameart.org/content/dawnlike-16x16-universal-rogue-like-tileset-v181', target: '_blank' },
            'DragonDePlatino'
          )
        )
      );
    }
  }]);

  return PageFooter;
}(React.Component);

/**
	*		Full App Class
	*/

/**
	*		@desc React Class renders full page
	*		@returns {HTML} full app
	*/


var App = function (_React$Component9) {
  _inherits(App, _React$Component9);

  function App() {
    _classCallCheck(this, App);

    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  _createClass(App, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg' },
        React.createElement(PageHeader, null),
        React.createElement(
          'div',
          { className: 'pg-content' },
          React.createElement(Game, null)
        ),
        React.createElement(PageFooter, null)
      );
    }
  }]);

  return App;
}(React.Component);

/**
	*		Render App to DOM
	*/

/**
	*		@desc ReactDOM renders app to HTML root node
	*		@returns {DOM} full page
	*/


ReactDOM.render(React.createElement(App, null), document.getElementById('root'));