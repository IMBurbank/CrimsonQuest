'use strict';

var enemyAvian = {
  timidBat: {
    name: 'Timid Bat',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [128, 352],
    spawnQuant: { '1': 20 },
    boss: false,
    aggression: 2,
    levelRange: [1, 1],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  annoyedOwl: {
    name: 'Annoyed Owl',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [32, 320],
    spawnQuant: { '1': 15, '2': 15 },
    boss: false,
    aggression: 2,
    levelRange: [1, 2],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  bloodBat: {
    name: 'Blood Bat',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [64, 352],
    spawnQuant: { '3': 15, '4': 15 },
    boss: false,
    aggression: 3,
    levelRange: [4, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  deathHawk: {
    name: 'Death Hawk',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [32, 32],
    spawnQuant: { '5': 15, '6': 15 },
    boss: false,
    aggression: 4,
    levelRange: [6, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  bloodBeak: {
    name: 'Blood Beak',
    type: 'avian',
    palette: ['avian0Palette', 'avian1Palette'],
    iconLoc: [160, 96],
    spawnQuant: { '7': 15, '8': 15 },
    boss: false,
    aggression: 4,
    levelRange: [7, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyDemon = {
  deviousImp: {
    name: 'Devious Imp',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [64, 128],
    spawnQuant: { '4': 10, '5': 15 },
    boss: false,
    aggression: 3,
    levelRange: [5, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  chupacabra: {
    name: 'Chupacabra',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [0, 256],
    spawnQuant: { '6': 20, '7': 20 },
    boss: false,
    aggression: 3,
    levelRange: [5, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  vileSuccubus: {
    name: 'Vile Succubus',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [0, 224],
    spawnQuant: { '7': 10, '8': 15 },
    boss: false,
    aggression: 4,
    levelRange: [7, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssHound: {
    name: 'Vile Succubus',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [160, 0],
    spawnQuant: { '8': 15, '9': 15 },
    boss: false,
    aggression: 4,
    levelRange: [8, 9],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  demonGuard: {
    name: 'Demon Guard',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [32, 32],
    spawnQuant: { '9': 15, '10': 15 },
    boss: false,
    aggression: 5,
    levelRange: [9, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssCambion: {
    name: 'Abyss Cambion',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 64],
    spawnQuant: { '10': 15 },
    boss: false,
    aggression: 5,
    levelRange: [10, 11],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  agares: {
    name: 'Agares',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [224, 32],
    spawnQuant: { '6': 1 },
    boss: true,
    aggression: 3,
    levelRange: [8, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  asmodius: {
    name: 'Asmodius',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [128, 32],
    spawnQuant: { '7': 1 },
    boss: true,
    aggression: 4,
    levelRange: [9, 9],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  belphagor: {
    name: 'Belphagor',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 0],
    spawnQuant: { '8': 1 },
    boss: true,
    aggression: 5,
    levelRange: [10, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  astaroth: {
    name: 'Astaroth',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [192, 32],
    spawnQuant: { '9': 1 },
    boss: true,
    aggression: 5,
    levelRange: [12, 12],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  azazel: {
    name: 'Azazel',
    type: 'demon',
    palette: ['demon0Palette', 'demon1Palette'],
    iconLoc: [96, 32],
    spawnQuant: { '10': 1 },
    boss: true,
    aggression: 5,
    levelRange: [13, 13],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyElemental = {
  sandElemental: {
    name: 'Sand Elemental',
    type: 'elemental',
    palette: ['elemental0Palette', 'elemental1Palette'],
    iconLoc: [0, 32],
    spawnQuant: { '3': 15, '4': 20 },
    boss: false,
    aggression: 3,
    levelRange: [3, 4],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  fireElemental: {
    name: 'Fire Elemental',
    type: 'elemental',
    palette: ['elemental0Palette', 'elemental1Palette'],
    iconLoc: [64, 160],
    spawnQuant: { '5': 10, '6': 15 },
    boss: false,
    aggression: 4,
    levelRange: [5, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyHumanoid = {
  eliTheTraitor: {
    name: 'Eli the Traitor',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [160, 192],
    spawnQuant: { '1': 1 },
    boss: true,
    aggression: 3,
    levelRange: [2, 2],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  borisTheButcher: {
    name: 'Boris the Butcher',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [0, 0],
    spawnQuant: { '2': 1 },
    boss: true,
    aggression: 3,
    levelRange: [3, 3],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  phanxTheRaider: {
    name: 'Phanx the Raider',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [32, 64],
    spawnQuant: { '3': 1 },
    boss: true,
    aggression: 3,
    levelRange: [5, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  quorakTheCannibal: {
    name: 'Quorak the Cannibal',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [64, 128],
    spawnQuant: { '4': 1 },
    boss: true,
    aggression: 4,
    levelRange: [6, 6],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  theDarkDisciple: {
    name: 'The Dark Disciple',
    type: 'humanoid',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [128, 192],
    spawnQuant: { '5': 1 },
    boss: true,
    aggression: 4,
    levelRange: [7, 7],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  travelingMerchant: {
    name: 'Traveling Merchant',
    type: 'merchant',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [32, 160],
    spawnQuant: { '1': 1 },
    boss: false,
    aggression: 0,
    levelRange: [5, 5],
    baseStats: {
      bHealth: 10,
      bAttack: 0,
      bDefense: 150,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 0,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    },
    inventory: {
      'Potion': {
        name: 'Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 200,
        palette: 'potionPalette',
        iconLoc: [0, 0, 32, 32],
        buy: 20,
        sell: 10,
        stats: { curHealth: 50 },
        spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
      },
      'Hi Potion': {
        name: 'Hi Potion',
        type: 'consumable',
        count: 3,
        equipped: false,
        itemArrVal: 201,
        palette: 'potionPalette',
        iconLoc: [64, 0, 32, 32],
        buy: 50,
        sell: 25,
        stats: { curHealth: 150 },
        spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
      }
    }
  },
  seedyMerchant: {
    name: 'Seedy Merchant',
    type: 'merchant',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [64, 160],
    spawnQuant: { '5': 1 },
    boss: false,
    aggression: 0,
    levelRange: [8, 8],
    baseStats: {
      bHealth: 10,
      bAttack: 0,
      bDefense: 150,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 0,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    },
    inventory: {
      'Potion': {
        name: 'Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 200,
        palette: 'potionPalette',
        iconLoc: [0, 0, 32, 32],
        buy: 20,
        sell: 10,
        stats: { curHealth: 50 },
        spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
      },
      'Hi Potion': {
        name: 'Hi Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 201,
        palette: 'potionPalette',
        iconLoc: [64, 0, 32, 32],
        buy: 50,
        sell: 25,
        stats: { curHealth: 150 },
        spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
      }
    }
  },
  darkMerchant: {
    name: 'Dark Merchant',
    type: 'merchant',
    palette: ['humanoid0Palette', 'humanoid1Palette'],
    iconLoc: [160, 160],
    spawnQuant: { '9': 1 },
    boss: false,
    aggression: 0,
    levelRange: [12, 12],
    baseStats: {
      bHealth: 10,
      bAttack: 0,
      bDefense: 150,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 0,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    },
    inventory: {
      'Potion': {
        name: 'Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 200,
        palette: 'potionPalette',
        iconLoc: [0, 0, 32, 32],
        buy: 20,
        sell: 10,
        stats: { curHealth: 50 },
        spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
      },
      'Hi Potion': {
        name: 'Hi Potion',
        type: 'consumable',
        count: 3,
        equipped: false,
        itemArrVal: 201,
        palette: 'potionPalette',
        iconLoc: [64, 0, 32, 32],
        buy: 50,
        sell: 25,
        stats: { curHealth: 150 },
        spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
      },
      xPotion: {
        name: 'X Potion',
        type: 'consumable',
        count: 5,
        equipped: false,
        itemArrVal: 202,
        palette: 'potionPalette',
        iconLoc: [96, 64, 32, 32],
        buy: 150,
        sell: 75,
        stats: { curHealth: 500 },
        spawnQuant: { '10': 1 }
      }
    }
  }
};
'use strict';

var enemyReptile = {
  bloodSnake: {
    name: 'Blood Snake',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 128],
    spawnQuant: { '1': 10, '2': 20 },
    boss: false,
    aggression: 3,
    levelRange: [2, 3],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  wingedViper: {
    name: 'Winged Viper',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 0],
    spawnQuant: { '2': 10, '3': 15 },
    boss: false,
    aggression: 3,
    levelRange: [2, 4],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  },
  abyssDragon: {
    name: 'Abyss Dragon',
    type: 'reptile',
    palette: ['reptile0Palette', 'reptile1Palette'],
    iconLoc: [96, 128],
    spawnQuant: { '10': 15 },
    boss: false,
    aggression: 4,
    levelRange: [10, 11],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

var enemyUndead = {
  necromancer: {
    name: 'Necromancer',
    type: 'undead',
    palette: ['undead0Palette', 'undead1Palette'],
    iconLoc: [0, 160],
    spawnQuant: { '9': 15 },
    boss: false,
    aggression: 4,
    levelRange: [8, 10],
    baseStats: {
      bHealth: 10,
      bAttack: 4,
      bDefense: 15,
      bHit: 60,
      bCrit: 5,
      bDodge: 15,
      bVitality: 2,
      bDurability: 4,
      bStrength: 5,
      bAgility: 10
    },
    onLevelUp: {
      bHealth: 6,
      bAttack: 3,
      bDefense: 4,
      bVitality: 2,
      bDurability: 2,
      bStrength: 2,
      bAgility: 3
    }
  }
};
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
  * Helper Functions
  */

var randInt = function randomIntFromRange(min, max) {
  return ~~(min + Math.random() * (max - min + 1));
};

var devError = function createDevError() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Default Error';

  this.name = 'DevError';
  this.message = message;
  this.stack = new Error().stack;
};

var initZeroArray = function initZeroFilledArray(len) {
  var arr = [],
      i = 0,
      j = 0;

  arr.length = len;
  while (i < len) {
    arr[i] = [];
    arr[i].length = len;
    while (j < len) {
      arr[i][j] = 0, j++;
    }j = 0, i++;
  }
  return arr;
};

//get element by id
var getById = function getElById(id) {
  return document.getElementById(id);
};

//adds one or more classes seperated, by commas, by element id
var addClasses = function addClassesByElId(id) {
  if (getById(id)) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        _addClasses = [].concat(args) || [];

    _addClasses.forEach(function (el) {
      if (!classArr.includes(el)) classArr.push(el);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt add class: ' + id + '. Couldnt find node.');
  }
};

//removes one or more classes seperated, by commas, by element id
var removeClasses = function removeClassesByElId(id) {
  if (getById(id)) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    var classArr = getById(id).getAttribute('class').split(' '),
        remClasses = [].concat(args) || [];

    remClasses.forEach(function (el) {
      if (classArr.includes(el)) classArr.splice(classArr.indexOf(el), 1);
    });
    getById(id).setAttribute('class', classArr.join(' '));
  } else {
    console.log('Didnt remove class: ' + id + '. Couldnt find node.');
  }
};

var initMemCanvas = function initCanvasToPointer(w, h, smoothing) {
  var tempCanv = document.createElement('canvas'),
      ctx = tempCanv.getContext('2d');

  tempCanv.width = w;
  tempCanv.height = h;
  ctx.imageSmoothingEnabled = smoothing;

  return tempCanv;
};

var linearDistance = function calcLinearDistance(a, b) {
  return Math.sqrt(Math.pow(a[1] - b[1], 2) + Math.pow(a[0] - b[0], 2));
};

var calcRenderPadding = function calcCanvasRenderPadding(playerArr, aLen, rLen, tileSize) {
  var startRow = 0,
      padRow = 0,
      startCol = 0,
      padCol = 0,
      renderArrHeight = 0,
      renderArrWidth = 0,
      sX = 0,
      sY = 0;

  if (paddingCache['' + playerArr]) {
    var _paddingCache = paddingCache['' + playerArr];
    startRow = _paddingCache.startRow;
    startCol = _paddingCache.startCol;
    renderArrHeight = _paddingCache.renderArrHeight;
    renderArrWidth = _paddingCache.renderArrWidth;
    sX = _paddingCache.sX;
    sY = _paddingCache.sY;
  } else {
    if (playerArr[0] - ~~(rLen / 2) < 0) {
      startRow = 0;
      padRow = -1 * (playerArr[0] - ~~(rLen / 2));
    } else if (playerArr[0] + ~~(rLen / 2) + 1 > aLen) {
      padRow = playerArr[0] + ~~(rLen / 2) + 1 - aLen;
      startRow = aLen - rLen + padRow;
    } else {
      startRow = playerArr[0] - ~~(rLen / 2);
      padRow = 0;
    }

    if (playerArr[1] - ~~(rLen / 2) < 0) {
      startCol = 0;
      padCol = -1 * (playerArr[1] - ~~(rLen / 2));
    } else if (playerArr[1] + ~~(rLen / 2) + 1 > aLen) {
      padCol = playerArr[1] + ~~(rLen / 2) + 1 - aLen;
      startCol = aLen - rLen + padCol;
    } else {
      startCol = playerArr[1] - ~~(rLen / 2);
      padCol = 0;
    }

    renderArrHeight = rLen - padRow;
    renderArrWidth = rLen - padCol;
    sX = !startCol && padCol ? padCol * tileSize : 0;
    sY = !startRow && padRow ? padRow * tileSize : 0;

    paddingCache['' + playerArr] = { startRow: startRow, startCol: startCol, renderArrHeight: renderArrHeight, renderArrWidth: renderArrWidth, sX: sX, sY: sY };
  }

  return { startRow: startRow, startCol: startCol, renderArrHeight: renderArrHeight, renderArrWidth: renderArrWidth, sX: sX, sY: sY };
};

var setRenderArr = function setCanvasRenderArr(arr, rLen, padding) {
  var renderArr = [],
      sr = padding.sr,
      sc = padding.sc,
      i = 0,
      j = 0,
      m = 0,
      n = 0;

  m = rLen - padding.pr;
  n = rLen - padding.pc;
  renderArr.length = m;

  for (; i < m; i++) {
    renderArr[i] = [];
    renderArr[i].length;

    for (j = 0, n; j < n; j++) {
      renderArr[i][j] = arr[sr + i][sc + j];
    }
  }

  return renderArr;
};

var backgroundArray = function createBackgroundArray(arrSize) {
  var air = 10,
      flr = 40;

  //Random rectangle
  var newRoomOne = function createNewRoomOne(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        xFloorMax = xMax - 4,
        yFloorMin = yMin - 4,
        yFloorMax = yMax - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [];

    var i = 0,
        j = 0;

    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];
      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out on each tile from min rectangle size
  var newRoomTwo = function createNewRoomTwo(rows, cols) {
    //Subtract two to leave room for permimeter walls
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMin = xMin - 4,
        yFloorMin = yMin - 4;

    var xPadL = randInt(2, xMax - xFloorMin - 2),
        xPadR = xMax - xFloorMin - xPadL,
        yPadT = randInt(2, yMax - yFloorMin - 2),
        yPadB = yMax - yFloorMin - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor area
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = xFloorMin;else if (i === 1) ext = xPadR - 2, s = yFloorMin;else if (i === 2) ext = yPadB - 2, s = xFloorMin;else ext = xPadL - 2, s = yFloorMin;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor area flr val in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + xFloorMin && i + 1 > yPadT && i < yPadT + yFloorMin) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + xFloorMin + i] = flr;
      }
    });
    floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + yFloorMin + i][xPadL + index] = flr;
      }
    });
    floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0]));
    xPadR = xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1]));
    yPadB = yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2]));
    xPadL = xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3]));

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  //Random out from random sides of rectangle
  var newRoomThree = function createNewRoomThree(rows, cols) {
    var xMin = roomSize[cols].min,
        xMax = roomSize[cols].max,
        yMin = roomSize[rows].min,
        yMax = roomSize[rows].max,
        xFloorMax = xMax - 4,
        xFloorMin = xMin - 4,
        yFloorMax = yMax - 4,
        yFloorMin = yMin - 4,
        w = randInt(xFloorMin, xFloorMax),
        h = randInt(yFloorMin, yFloorMax),
        sidesToExtend = [randInt(0, 1), randInt(0, 1), randInt(0, 1), randInt(0, 1)];

    var xPadL = randInt(2, xMax - w - 2),
        xPadR = xMax - w - xPadL,
        yPadT = randInt(2, yMax - h - 2),
        yPadB = yMax - h - yPadT,
        roomFloorArr = [],
        floorExtendArr = [],
        ext = 0,
        s = 0,
        i = 0,
        j = 0;

    //create arrays to extend min floor size
    floorExtendArr.length = 4;
    for (i = 0; i < 4; i++) {
      floorExtendArr[i] = [];

      if (i === 0) ext = yPadT - 2, s = w;else if (i === 1) ext = xPadR - 2, s = h;else if (i === 2) ext = yPadB - 2, s = w;else ext = xPadL - 2, s = h;

      for (j = 0; j < s; j++) {
        floorExtendArr[i][j] = randInt(0, ext);
      }
    }

    //Set min floor size to 1's in roomFloorArr
    roomFloorArr.length = yMax;
    for (i = 0; i < yMax; i++) {
      roomFloorArr[i] = [];

      for (j = 0; j < xMax; j++) {
        if (j + 1 > xPadL && j < xPadL + w && i + 1 > yPadT && i < yPadT + h) {
          roomFloorArr[i][j] = flr;
        } else {
          roomFloorArr[i][j] = air;
        }
      }
    }

    //Extend top, right, bottom, left floor edges per floorExtendArr
    sidesToExtend[0] && floorExtendArr[0].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT - 1 - i][xPadL + index] = flr;
      }
    });
    sidesToExtend[1] && floorExtendArr[1].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL + w + i] = flr;
      }
    });
    sidesToExtend[2] && floorExtendArr[2].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + h + i][xPadL + index] = flr;
      }
    });
    sidesToExtend[3] && floorExtendArr[3].forEach(function (el, index) {
      for (i = 0; i < el; i++) {
        roomFloorArr[yPadT + index][xPadL - 1 - i] = flr;
      }
    });

    yPadT = sidesToExtend[0] ? yPadT - Math.max.apply(Math, _toConsumableArray(floorExtendArr[0])) : yPadT;
    xPadR = sidesToExtend[1] ? xPadR - Math.max.apply(Math, _toConsumableArray(floorExtendArr[1])) : xPadR;
    yPadB = sidesToExtend[2] ? yPadB - Math.max.apply(Math, _toConsumableArray(floorExtendArr[2])) : yPadB;
    xPadL = sidesToExtend[3] ? xPadL - Math.max.apply(Math, _toConsumableArray(floorExtendArr[3])) : xPadL;

    return {
      xPadL: xPadL,
      xPadR: xPadR,
      yPadT: yPadT,
      yPadB: yPadB,
      xMax: xMax,
      yMax: yMax,
      roomFloorArr: roomFloorArr
    };
  };

  var createRooms = function createNewRooms() {
    var rows = 0,
        colsArr = [],
        cols = 0,
        xPadL = 0,
        xPadR = 0,
        yPadT = 0,
        yPadB = 0,
        xMax = 0,
        yMax = 0,
        roomType = 0,
        rooms = [],
        rmsRow = [],
        roomFloorArr = [],
        i = 0,
        j = 0;

    rows = randInt(3, 4) * 2;
    colsArr.length = rows;
    for (; i < rows; i++) {
      colsArr[i] = randInt(2, 4) * 2;
    }

    rooms = colsArr.map(function (el, index) {
      rmsRow = [];

      for (j = 0; j < el; j++) {
        roomType = randInt(1, 10);
        cols = el;

        if (roomType === 1) {
          var _newRoomOne = newRoomOne(rows, cols);

          xPadL = _newRoomOne.xPadL;
          xPadR = _newRoomOne.xPadR;
          yPadT = _newRoomOne.yPadT;
          yPadB = _newRoomOne.yPadB;
          xMax = _newRoomOne.xMax;
          yMax = _newRoomOne.yMax;
          roomFloorArr = _newRoomOne.roomFloorArr;
        } else if (roomType > 1 && roomType < 8) {
          var _newRoomTwo = newRoomTwo(rows, cols);

          xPadL = _newRoomTwo.xPadL;
          xPadR = _newRoomTwo.xPadR;
          yPadT = _newRoomTwo.yPadT;
          yPadB = _newRoomTwo.yPadB;
          xMax = _newRoomTwo.xMax;
          yMax = _newRoomTwo.yMax;
          roomFloorArr = _newRoomTwo.roomFloorArr;
        } else {
          var _newRoomThree = newRoomThree(rows, cols);

          xPadL = _newRoomThree.xPadL;
          xPadR = _newRoomThree.xPadR;
          yPadT = _newRoomThree.yPadT;
          yPadB = _newRoomThree.yPadB;
          xMax = _newRoomThree.xMax;
          yMax = _newRoomThree.yMax;
          roomFloorArr = _newRoomThree.roomFloorArr;
        }

        rmsRow[j] = {
          rows: rows,
          cols: cols,
          xPadL: xPadL,
          xPadR: xPadR,
          yPadT: yPadT,
          yPadB: yPadB,
          xMax: xMax,
          yMax: yMax,
          roomFloorArr: roomFloorArr,
          cnxns: [0, 0, 0, 0],
          curRow: index
        };
      }

      return rmsRow;
    });
    return rooms;
  };

  var stitchRooms = function stitchRoomArray(rooms) {
    var stitchArr = [],
        len = arrSize;

    var c = 0,
        i = 0,
        j = 0,
        k = 0,
        r = 0;

    stitchArr.length = len;
    while (r < len) {
      while (c < len) {
        stitchArr[r] = c === 0 ? rooms[k][i].roomFloorArr[j] : [].concat(_toConsumableArray(stitchArr[r]), _toConsumableArray(rooms[k][i].roomFloorArr[j]));
        c += rooms[k][i].xMax;
        i++;
      }
      if (j === rooms[k][i - 1].yMax - 1) j = 0, k++;else j++;
      c = 0, i = 0;
      r++;
    }
    return stitchArr;
  };

  var choosePaths = function newPaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow) {
    var len = stitchArr.length,
        xMax = rm.xMax,
        yMax = rm.yMax,
        riskySmall = 14,
        colOneCheckColMax = 15;

    var pathOpts = [],
        paths = [],
        goUp = false,
        goRt = false,
        goDn = false,
        goLt = false,
        chk = false,
        val = 0,
        i = 0,
        j = 0,
        k = 0;

    if (tieRule === 1 || tieRule === 2 && rm.cnxns[3] || tieRule === 4 && rm.cnxns[0]) {
      val = randInt(1, 3);
      goRt = val === 1 || val === 3 ? true : false;
      goDn = val === 2 || val === 3 ? true : false;
    } else if (tieRule === 2) {
      goRt = randInt(0, 1) ? true : false;
      goDn = true;
    } else if (tieRule === 3) {
      goDn = !rm.cnxns[3] || !tiedRow || randInt(0, 1) ? true : false;
    } else if (tieRule === 4) {
      goRt = true;
      goDn = randInt(0, 1) ? true : false;
    } else if (tieRule === 5) {
      goRt = !rm.cnxns[0] || !rooms[rm.curRow - 1][~~(chkCol / rooms[rm.curRow - 1][0].xMax)].cnxns[1] || randInt(0, 1) ? true : false;
    } else {
      goUp = !rm.cnxns[0] ? true : false;
      goLt = !rm.cnxns[3] ? true : false;
    }
    tiedRow = goDn ? true : tiedRow;

    if (rm.yMax - rm.yPadT - rm.yPadB < riskySmall && !goRt && [1, 2, 4, 5].includes(tieRule)) {

      goRt = true;
      if (tieRule > 2) goUp = true;
      if (chkCol > colOneCheckColMax) goLt = true;
    }
    if (rm.xMax - rm.xPadL - rm.xPadR < riskySmall) {
      if (tieRule > 3) goUp = true;
      if (tieRule < 5) goDn = true;
      if (chkCol > colOneCheckColMax) goLt = true;
    }

    if (goUp) {
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow - j < 2 || stitchArr[chkRow - j][k] === flr || stitchArr[chkRow - j - 1][k] === flr || stitchArr[chkRow - j][k + 1] === flr || stitchArr[chkRow - j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow - j > 1) pathOpts.push([1, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        if (tieRule !== 3 || tieRule !== 6) goRt = true;
        if (tieRule > 2) goDn = true;
        /*
        try { throw new devError('No pathOpts up. Set right&down. -> BackgroundLayer.choosePaths'); }
        catch(e) { console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule); }
        */
      }
    }
    if (goDn) {
      pathOpts.length = 0;
      i = 0;

      while (i < xMax) {
        if (stitchArr[chkRow][chkCol - ~~(xMax / 2) + i] === flr) {
          k = chkCol - ~~(xMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * yMax || chkRow + j > len - 3 || stitchArr[chkRow + j][k] === flr || stitchArr[chkRow + j][k + 1] === flr || stitchArr[chkRow + j + 1][k] === flr || stitchArr[chkRow + j][k - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * yMax && chkRow + j < len - 3) pathOpts.push([3, k, chkRow, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        if (tieRule !== 3 || tieRule !== 6) goRt = true;
        if (chkCol > colOneCheckColMax) goLt = true;
        /*
        try { throw new devError('No pathOpts down. Set right&left. -> BackgroundLayer.choosePaths'); }
        catch(e) { console.log(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule); }
        */
      }
    }
    if (goRt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(xMax / 2) && (j > 2 * xMax || chkCol + j > len - 3 || stitchArr[k][chkCol + j] === flr || stitchArr[k - 1][chkCol + j] === flr || stitchArr[k][chkCol + j + 1] === flr || stitchArr[k + 1][chkCol + j] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol + j < len - 3) pathOpts.push([2, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        if (chkCol > colOneCheckColMax) goLt = true;
        /*
        try { throw new devError('no pathOpts right, go left. -> BackgroundLayer.choosePaths'); }
        catch(e) { console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule); }
        */
      }
    }
    if (goLt) {
      pathOpts.length = 0;
      i = 0;

      while (i < yMax) {
        if (stitchArr[chkRow - ~~(yMax / 2) + i][chkCol] === flr) {
          k = chkRow - ~~(yMax / 2) + i;
          chk = false;
          j = 0;

          while (!chk) {
            j++;

            if (j > ~~(yMax / 2) && (j > 2 * xMax || chkCol - j < 2 || stitchArr[k][chkCol - j] === flr || stitchArr[k - 1][chkCol - j] === flr || stitchArr[k + 1][chkCol - j] === flr || stitchArr[k][chkCol - j - 1] === flr)) {
              chk = true;
            }
          }
          if (j < 2 * xMax && chkCol - j > 1) pathOpts.push([4, chkCol, k, j]);
        }
        i++;
      }
      if (pathOpts.length > 0) paths.push(pathOpts[randInt(0, pathOpts.length - 1)]);else {
        /*
        try { throw new devError('no pathOpts left -> BackgroundLayer.choosePaths'); }
        catch(e) { console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule); }
        */
      }
    }
    /*
    if (paths.length === 1) paths.push([0,0,0,0]);
    else if (paths.length > 2) {
      try { throw new devError('paths.length > 2 -> BackgroundLayer.choosePaths'); }
      catch(e) { console.error(e.name, e.message, e.stack, chkRow, chkCol, rm.curRow, tieRule); }
    }
    */

    return { paths: paths, tiedRow: tiedRow };
  };

  var applyPaths = function applyNewPaths(rm, rooms, stitchArr, paths) {
    var i = 0;

    paths.forEach(function (el) {
      if (el[0] === 1) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] - i][el[1]] = flr;
        }
        rm.cnxns[0] = 1;
        rooms[rm.curRow - 1][~~(el[1] / rooms[rm.curRow - 1][0].xMax)].cnxns[2] = 1;
      } else if (el[0] === 2) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] + i] = flr;
        }
        rm.cnxns[1] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) + 1].cnxns[3] = 1;
      } else if (el[0] === 3) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2] + i][el[1]] = flr;
        }
        rm.cnxns[2] = 1;
        rooms[rm.curRow + 1][~~(el[1] / rooms[rm.curRow + 1][0].xMax)].cnxns[0] = 1;
      } else if (el[0] === 4) {
        i = 0;
        while (i < el[3]) {
          i++;
          stitchArr[el[2]][el[1] - i] = flr;
        }
        rm.cnxns[3] = 1;
        rooms[rm.curRow][~~(el[1] / rooms[rm.curRow][0].xMax) - 1].cnxns[1] = 1;
      }
    });

    return true;
  };

  var createPaths = function createNewPaths(rooms, stitchArr) {
    var len = stitchArr.length;

    var tiedRow = false,
        paths = [],
        rm = void 0,
        //{} pointer
    chkRow = 0,
        chkCol = 0,
        tieRule = 0,
        r = 0,
        c = 0,
        i = 0,
        j = 0;

    paths.length = ~~(len / 4);

    while (r < len) {
      while (c < len) {
        rm = rooms[j][i];
        chkRow = r + ~~(rm.yMax / 2);
        chkCol = c + ~~(rm.xMax / 2);
        tieRule = j === 0 && i === 0 ? 1 : j === 0 && i < rooms[j].length - 1 ? 2 : j < rooms.length - 1 && i === rooms[j].length - 1 ? 3 : j < rooms.length - 1 && i < rooms[j].length - 1 ? 4 : j === rooms.length - 1 && i < rooms[j].length - 1 ? 5 : 6;

        var _choosePaths = choosePaths(rm, rooms, stitchArr, chkRow, chkCol, tieRule, tiedRow);

        paths = _choosePaths.paths;
        tiedRow = _choosePaths.tiedRow;

        applyPaths(rm, rooms, stitchArr, paths);

        c += rm.xMax;
        i++;
      }
      r += rooms[j][i - 1].yMax;
      j++;
      tiedRow = false;
      c = 0;
      i = 0;
    }

    return stitchArr;
  };

  var randomizeOrientation = function randomizeArrOrientation(connectedArr) {
    var len = connectedArr.length,
        orientation = randInt(1, 4);

    var orientedArr = [],
        i = 0,
        j = 0;

    var transposed = function transposeSquareArr(arr) {
      var tArr = [],
          len = arr.length;

      while (i < len) {
        tArr[i] = [];
        j = 0;

        while (j < len) {
          tArr[i][j] = arr[j][i], j++;
        }i++;
      }
      return tArr;
    };

    if (orientation === 1) {
      orientedArr = [].concat(_toConsumableArray(connectedArr));
    }
    if (orientation === 2) {
      //Rotate +90 deg
      orientedArr = transposed(connectedArr);
      orientedArr.forEach(function (el) {
        return el.reverse();
      });
    } else if (orientation === 3) {
      //Rotate 180 deg
      while (i < len) {
        orientedArr[i] = connectedArr[len - 1 - i].reverse();
        i++;
      }
    } else if (orientation === 4) {
      //Rotate -90 deg
      connectedArr.forEach(function (el) {
        return el.reverse();
      });
      orientedArr = transposed(connectedArr);
    }
    return { orientation: orientation, orientedArr: orientedArr };
  };

  var addWalls = function addArrWalls(orientedArr) {
    var walledArr = orientedArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = walledArr.length - 1;

    var i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (orientedArr[i][j] === air) {
          nArr[0] = walledArr[i - 1][j - 1];
          nArr[1] = walledArr[i - 1][j];
          nArr[2] = walledArr[i - 1][j + 1];
          nArr[3] = walledArr[i][j - 1];
          nArr[4] = walledArr[i][j + 1];
          nArr[5] = walledArr[i + 1][j - 1];
          nArr[6] = walledArr[i + 1][j];
          nArr[7] = walledArr[i + 1][j + 1];

          if (nArr.includes(flr)) {
            if (nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && (nArr[1] === air || nArr[1] === flr) && (nArr[5] === flr && nArr[7] === flr || nArr[1] === flr && (nArr[5] === flr || nArr[7] === flr))) {
              el = 31;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && nArr[6] === air && (nArr[2] === flr && nArr[7] === flr || nArr[3] === flr && (nArr[2] === flr || nArr[7] === flr))) {
              el = 32;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && nArr[6] === air && nArr[2] === flr && nArr[7] === flr) {
              el = 33;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[0] === flr && nArr[5] === flr || (nArr[0] === flr || nArr[5] === flr) && nArr[4] === flr)) {
              el = 34;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && nArr[4] === air && (nArr[0] === flr && nArr[2] === flr || (nArr[0] === flr || nArr[2] === flr) && nArr[6] === flr)) {
              el = 35;
            } else if (nArr[4] === air && nArr[6] === air && (nArr[1] === flr && nArr[3] === flr || nArr[7] === flr)) {
              el = 21;
            } else if (nArr[3] > air && nArr[3] < flr && nArr[6] === air && (nArr[1] === flr && nArr[4] === flr || nArr[5] === flr)) {
              el = 23;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[4] === air && (nArr[3] === flr && nArr[6] === flr || nArr[2] === flr)) {
              el = 25;
            } else if (nArr[1] > air && nArr[1] < flr && nArr[3] > air && nArr[3] < flr && (nArr[0] === flr || nArr[4] === flr && nArr[6] === flr)) {
              el = 27;
            } else if (nArr[3] > air && nArr[3] < flr && (nArr[1] === flr || nArr[6] === flr) || nArr[4] === air && (nArr[1] === flr && nArr[2] === flr || nArr[5] === flr && nArr[6] === flr)) {
              el = 22;
            } else if (nArr[1] > air && nArr[1] < flr || nArr[6] === air && (nArr[3] === flr || nArr[4] === flr)) {
              el = 24;
            } else if (nArr[1] === flr || nArr[3] === flr || nArr[4] === flr || nArr[6] === flr) {
              el = 26;
            }

            if (el) walledArr[i][j] = el;
          }
        }
        j++;
      }
      i++;
    }

    return walledArr;
  };

  var addFloors = function addArrFloors(walledArr) {
    var bgArr = walledArr,
        nArr = [0, 0, 0, 0, 0, 0, 0, 0],
        len = bgArr.length - 1,
        sFlr = flr - 1;

    var floorCoords = [],
        i = 1,
        j = 1,
        el = 0;

    while (i < len) {
      j = 1;

      while (j < len) {
        el = 0;

        if (walledArr[i][j] > sFlr) {
          nArr[0] = bgArr[i - 1][j - 1];
          nArr[1] = bgArr[i - 1][j];
          nArr[2] = bgArr[i - 1][j + 1];
          nArr[3] = bgArr[i][j - 1];
          nArr[4] = bgArr[i][j + 1];
          nArr[5] = bgArr[i + 1][j - 1];
          nArr[6] = bgArr[i + 1][j];
          nArr[7] = bgArr[i + 1][j + 1];
          floorCoords.push([i, j]);

          if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 41;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 42;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 43;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 44;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] > sFlr) {
            el = 45;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 46;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 47;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 48;
          } else if (nArr[1] > sFlr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 49;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 51;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] > sFlr) {
            el = 52;
          } else if (nArr[1] > sFlr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 53;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 54;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] > sFlr && nArr[6] < flr) {
            el = 55;
          } else if (nArr[1] < flr && nArr[3] > sFlr && nArr[4] < flr && nArr[6] < flr) {
            el = 56;
          } else if (nArr[1] < flr && nArr[3] < flr && nArr[4] < flr && nArr[6] < flr) {
            el = 57;
          }

          if (el) bgArr[i][j] = el;
        }
        j++;
      }
      i++;
    }
    return { bgArr: bgArr, floorCoords: floorCoords };
  };

  var rooms = createRooms();
  var stitchArr = stitchRooms(rooms);
  var connectedArr = createPaths(rooms, stitchArr);

  var _randomizeOrientation = randomizeOrientation(connectedArr),
      orientation = _randomizeOrientation.orientation,
      orientedArr = _randomizeOrientation.orientedArr;

  var walledArr = addWalls(orientedArr);

  var _addFloors = addFloors(walledArr),
      bgArr = _addFloors.bgArr,
      floorCoords = _addFloors.floorCoords;

  return { bgArr: bgArr, floorCoords: floorCoords };
};
'use strict';

//Global state
var timeRef = null;
var paddingCache = {};

/**
 * Global Settings
 */

//Room size Settings
var roomSize = {
  '4': { min: 16, max: 30 },
  '6': { min: 14, max: 20 },
  '8': { min: 11, max: 15 }
};

var consumableAbbrevMap = {
  potion: { name: 'Potion', key: 'potion', abbrev: 'LPOT', num: 1 },
  hiPotion: { name: 'Hi Potion', key: 'hiPotion', abbrev: 'HPOT', num: 2 },
  xPotion: { name: 'X Potion', key: 'xPotion', abbrev: 'XPOT', num: 3 },
  tomeOfVitality: { name: 'Tome of Vitality', key: 'tomeOfVitality', abbrev: 'VTOM', num: 4 },
  tomeOfDurability: { name: 'Tome of Durability', key: 'tomeOfDurability', abbrev: 'DTOM', num: 5 },
  tomeOfStrength: { name: 'Tome of Strength', key: 'tomeOfStrength', abbrev: 'STOM', num: 6 },
  tomeOfAgility: { name: 'Tome of Agility', key: 'tomeOfAgility', abbrev: 'ATOM', num: 7 },
  tomeOfWisdom: { name: 'Tome of Wisdom', key: 'tomeOfWisdom', abbrev: 'WTOM', num: 8 }
};

var equipAbbrevMap = {
  Head: 'HED',
  Amulet: 'AMU',
  Weapon: 'WEP',
  Armor: 'AMR',
  Shield: 'SLD',
  Glove: 'GLV',
  Ring: 'RNG',
  Foot: 'FT',
  Consumable: 'CNS'
};

var statConvertWordMap = {
  curHealth: 'HP',
  iAttack: 'Atk',
  iDefense: 'Def',
  iVitality: 'Vit',
  iDurability: 'Dur',
  iStrength: 'Str',
  iAgility: 'Agi'
};

//Hero Stat Conversions
var statConversion = {
  vitToHp: 9,
  durToHp: 3,
  durToDef: 2,
  durToDodge: 0.1,
  strToAtk: 2,
  strToDef: 1,
  strToHit: 0.25,
  agiToHit: 1,
  agiToDodge: 0.5,
  agiToCrit: 0.5,
  atkToHpRange: [3, 5],
  defToHpRange: [1, 3],
  lvlToExpRange: [9, 12],
  lvlToGoldRange: [2, 3],
  expLevelMult: 1.75,
  lvlUpSkillPoints: 2,
  bossMultiplier: 2.5
};

/**
  *   Hero stats
  */

var heroTypeStats = {
  Mage: {
    heroName: 'Forsyth',
    health: 53,
    attack: 12,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 12,
    durability: 10,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 0,
      attack: 5,
      defense: 0,
      vitality: 1,
      durability: 0,
      strength: 2,
      agility: 1
    },
    description: 'Not your usual paper tiger. Devasting attack and high vitality.'
  },
  Paladin: {
    heroName: 'Roland',
    health: 53,
    attack: 10,
    defense: 12,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 11,
    durability: 11,
    strength: 11,
    agility: 11,
    onLevelUp: {
      health: 6,
      attack: 1,
      defense: 2,
      vitality: 1,
      durability: 2,
      strength: 1,
      agility: 0
    },
    description: 'Keeper of the faith. Very durable. Not terribly agile.'
  },
  Rogue: {
    heroName: 'Hanzo',
    health: 50,
    attack: 13,
    defense: 10,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 10,
    strength: 12,
    agility: 12,
    onLevelUp: {
      health: 6,
      attack: 3,
      defense: 0,
      vitality: 0,
      durability: 0,
      strength: 2,
      agility: 2
    },
    description: 'Fierce. Deadly. Agile. Just don\'t get hit.'
  },
  Warrior: {
    heroName: 'Agis',
    health: 50,
    attack: 12,
    defense: 11,
    hit: 90,
    crit: 5,
    dodge: 10,
    vitality: 10,
    durability: 12,
    strength: 12,
    agility: 10,
    onLevelUp: {
      health: 6,
      attack: 2,
      defense: 1,
      vitality: 0,
      durability: 1,
      strength: 2,
      agility: 1
    },
    description: 'Well-rounded. Fierce. Fairly agile. You don\'t need health if your enemy is dead.'
  }
};
'use strict';

/**
 * Consumable Items
 */

var itemConsumables = {
  //Potions
  potion: {
    name: 'Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { curHealth: 50 },
    spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
  },
  hiPotion: {
    name: 'Hi Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { curHealth: 150 },
    spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
  },
  xPotion: {
    name: 'X Potion',
    type: 'consumable',
    palette: 'potionPalette',
    iconLoc: [96, 64, 32, 32],
    buy: 150,
    sell: 75,
    stats: { curHealth: 500 },
    spawnQuant: { '10': 1 }
  },
  //Tomes
  tomeOfVitality: {
    name: 'Tome of Vitality',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 160, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iVitality: 1 },
    spawnQuant: { '3': 1, '6': 1, '9': 1 }
  },
  tomeOfDurability: {
    name: 'Tome of Durability',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iDurability: 1 },
    spawnQuant: { '2': 1, '5': 1, '8': 1 }
  },
  tomeOfStrength: {
    name: 'Tome of Strength',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1, '4': 1, '8': 1 }
  },
  tomeOfAgility: {
    name: 'Tome of Agility',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [64, 224, 32, 32],
    buy: 100,
    sell: 50,
    stats: { iAgility: 1 },
    spawnQuant: { '2': 1, '5': 1, '9': 1 }
  },
  tomeOfWisdom: {
    name: 'Tome of Wisdom',
    type: 'consumable',
    palette: 'bookPalette',
    iconLoc: [0, 160, 32, 32],
    buy: 200,
    sell: 100,
    stats: { statPoints: 1 },
    spawnQuant: { '4': 1, '6': 1, '8': 1, '10': 1 }
  },
  //Gold
  gold1: {
    name: 'a little Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(1, 3);
      } },
    spawnQuant: { '1': 10, '2': 10, '3': 7, '4': 5, '5': 3 }
  },
  gold2: {
    name: 'some Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [32, 32, 32, 32],
    stats: { get gold() {
        return randInt(4, 7);
      } },
    spawnQuant: { '3': 2, '4': 4, '5': 7, '6': 9, '7': 6, '8': 3, '9': 1 }
  },
  gold3: {
    name: 'a small pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(8, 12);
      } },
    spawnQuant: { '7': 3, '8': 6, '9': 7, '10': 4 }
  },
  gold4: {
    name: 'a pile of Gold',
    type: 'gold',
    palette: 'moneyPalette',
    iconLoc: [0, 32, 32, 32],
    stats: { get gold() {
        return randInt(13, 17);
      } },
    spawnQuant: { '9': 2, '10': 6 }
  }
};

var chestConsumables = {
  closedChest: {
    name: 'Treasure Chest',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 0, 32, 32]
  },
  openChest: {
    name: 'Treasure Chest',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 0, 32, 32]
  },
  closedBarrel: {
    name: 'Barrel',
    type: 'closedChest',
    palette: 'chest0Palette',
    iconLoc: [32, 32, 32, 32]
  },
  openBarrel: {
    name: 'Barrel',
    type: 'openChest',
    palette: 'chest1Palette',
    iconLoc: [32, 32, 32, 32]
  }
};
'use strict';

/**
 * Amulets
 */

var itemAmulets = {
  //Mage Amulets
  mageAmu1: {
    name: "Damaged Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '3': 1 }
  },
  mageAmu2: {
    name: "Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 12, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  mageAmu3: {
    name: "Enchanted Amulet of Striking",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 16, iStrength: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Rogue Amulets
  rogueAmu1: {
    name: "Damaged Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueAmu2: {
    name: "Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iAttack: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '5': 1 }
  },
  rogueAmu3: {
    name: "Enchanted Amulet of Stealth",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 8, iStrength: 1, iAgility: 4 },
    spawnQuant: { '7': 1 }
  },
  //Warrior Amulets
  warriorAmu1: {
    name: "Damaged Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorAmu2: {
    name: "Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [196, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iDurability: 1 },
    spawnQuant: { '5': 1 }
  },
  warriorAmu3: {
    name: "Enchanted Amulet of Power",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iStrength: 4, iDurability: 2, iAgility: 1 },
    spawnQuant: { '7': 1 }
  },
  //Paladin Amulets
  paladinAmu1: {
    name: "Damaged Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinAmu2: {
    name: "Amulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 3, iDurabilty: 1 },
    spawnQuant: { '5': 1 }
  },
  paladinAmu3: {
    name: "EnchantedAmulet of Life",
    type: 'amulet',
    palette: 'amuletPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iVitality: 4, iStrength: 1, iDurabilty: 2 },
    spawnQuant: { '7': 1 }
  }
};
'use strict';

/**
 * Armor
 */

var itemArmors = {
  //Mage armor
  clothArm1: {
    name: "Moldy Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iVitality: 1, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothArm2: {
    name: "Adept Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  clothArm3: {
    name: "Shining Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iVitality: 3, iStrength: 2, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  clothArm4: {
    name: "Ancient Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 12, iVitality: 4, iStrength: 3, iDurability: 1 },
    spawnQuant: { '8': 1 }
  },
  clothArm5: {
    name: "Brilliant Robe",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 16, iVitality: 6, iStrength: 3, iDurability: 1 },
    spawnQuant: { '10': 1 }
  },
  //Rogue armor
  leatherArm1: {
    name: "Cracked Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 256, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 1, iAgility: 1 },
    spawnQuant: { '2': 1 }
  },
  leatherArm2: {
    name: "Supple Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 256, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 8, iStrength: 1, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  leatherArm3: {
    name: "Reinforced Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [96, 256, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 2, iAgility: 2 },
    spawnQuant: { '6': 1 }
  },
  leatherArm4: {
    name: "Rune Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 256, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 20, iStrength: 2, iAgility: 4 },
    spawnQuant: { '8': 1 }
  },
  leatherArm5: {
    name: "Dark Leather Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [128, 256, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 20, iStrength: 3, iAgility: 6 },
    spawnQuant: { '10': 1 }
  },
  //Warrior armor
  chainArm1: {
    name: "Rusted Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  chainArm2: {
    name: "Bronze Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 12, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  chainArm3: {
    name: "Reinforced Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [234, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 16, iStrength: 3, iAgility: 1 },
    spawnQuant: { '6': 1 }
  },
  chainArm4: {
    name: "Rune Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 24, iStrength: 4, iAgility: 1 },
    spawnQuant: { '8': 1 }
  },
  chainArm5: {
    name: "Brilliant Chainmail Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 28, iStrength: 5, iDurability: 1, iAgility: 1 },
    spawnQuant: { '10': 1 }
  },
  //Paladin armor
  plateArm1: {
    name: "Rusted Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 12 },
    spawnQuant: { '2': 1 }
  },
  plateArm2: {
    name: "Bronze Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [32, 192, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 16, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  plateArm3: {
    name: "Reinforced Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [160, 192, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 24, iDurability: 2 },
    spawnQuant: { '6': 1 }
  },
  plateArm4: {
    name: "Rune Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [192, 192, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDefense: 32, iVitality: 1, iDurability: 2 },
    spawnQuant: { '8': 1 }
  },
  plateArm5: {
    name: "Brilliant Plate Armor",
    type: 'armor',
    palette: 'armorPalette',
    iconLoc: [224, 192, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iDefense: 36, iVitality: 2, iDurability: 3 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

/**
 * Feet
 */

var itemFeet = {
  //Mage Feet
  mageFt1: {
    name: "Tattered Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iVitality: 1, iStrength: 1, iAgility: 1 },
    spawnQuant: { '4': 1 }
  },
  mageFt2: {
    name: "Fine Cloth Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  //Rogue Feet
  rogueFt1: {
    name: "Tattered Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iAgility: 2 },
    spawnQuant: { '4': 1 }
  },
  rogueFt2: {
    name: "Fine Leather Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior Feet
  warriorFt1: {
    name: "Rusted Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 4, iStrength: 2 },
    spawnQuant: { '4': 1 }
  },
  warriorFt2: {
    name: "Fine Chain Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin Feet
  paladinFt1: {
    name: "Rusted Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iDefense: 8, iDurability: 1 },
    spawnQuant: { '4': 1 }
  },
  paladinFt2: {
    name: "Fine Plate Boots",
    type: 'foot',
    palette: 'bootPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 16, iVitality: 1, iDurability: 2 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

/**
 * Gloves
 */

var itemGloves = {
  mageGlv1: {
    name: "Cloth Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [32, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iVitality: 2, iStrength: 1, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  rogueGlv1: {
    name: "Leather Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [0, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iStrength: 2, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorGlv1: {
    name: "Battle Mitts",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [64, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  paladinGlv1: {
    name: "Plate Gloves",
    type: 'glove',
    palette: 'glovePalette',
    iconLoc: [96, 0, 32, 32],
    buy: 30,
    sell: 15,
    stats: { iDefense: 8, iDurabilty: 2 },
    spawnQuant: { '3': 1 }
  }
};
'use strict';

/**
 * Helmets
 */

var itemHelmets = {
  //Mage Cloth
  clothHead1: {
    name: 'Snazzy Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 3, iStrength: 1 },
    spawnQuant: { '2': 1 }
  },
  clothHead2: {
    name: 'Wizard Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 4, iVitality: 6, iStrength: 4 },
    spawnQuant: { '5': 1 }
  },
  clothHead3: {
    name: 'Enchanted Hat',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 8, iVitality: 12, iStrength: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Rogue Leather
  leatherHead1: {
    name: 'Soft Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 1, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  leatherHead2: {
    name: 'Hardened Leather Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 32, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iStrength: 2, iDurability: 1, iAgility: 6 },
    spawnQuant: { '5': 1 }
  },
  leatherHead3: {
    name: 'Rune Leather Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 16, iStrength: 4, iDurability: 2, iAgility: 10 },
    spawnQuant: { '8': 1 }
  },
  //Warrior Mail
  mailHead1: {
    name: 'Chainmail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDefense: 4, iStrength: 2, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  mailHead2: {
    name: 'Platemail Cap',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 12, iStrength: 5, iDurability: 2, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  mailHead3: {
    name: 'Platemail Helmet',
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 24, iStrength: 8, iDurability: 4, iAgility: 2 },
    spawnQuant: { '8': 1 }
  },
  //Paladin Crown
  crownHead1: {
    name: "Desciple's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2 },
    spawnQuant: { '2': 1 }
  },
  crownHead2: {
    name: "Golden Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iDefense: 8, iVitality: 4, iDurability: 4, iStrength: 1 },
    spawnQuant: { '5': 1 }
  },
  crownHead3: {
    name: "King's Crown",
    type: 'head',
    palette: 'hatPalette',
    iconLoc: [64, 96, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iDefense: 12, iVitality: 10, iDurability: 5, iStrength: 2 },
    spawnQuant: { '8': 1 }
  }
};
'use strict';

/**
 * Rings
 */

var itemRings = {
  //Mage rings
  mageRng1: {
    name: "Damaged Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAttack: 4 },
    spawnQuant: { '1': 1 }
  },
  mageRng2: {
    name: "Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iAgility: 1 },
    spawnQuant: { '3': 1 }
  },
  mageRng3: {
    name: "Enchanted Ring of Striking",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [64, 64, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iAttack: 12, iVitality: 1, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Rogue rings
  rogueRng1: {
    name: "Damaged Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  rogueRng2: {
    name: "Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iStrength: 1, iAgility: 2 },
    spawnQuant: { '3': 1 }
  },
  rogueRng3: {
    name: "Enchanted Ring of Stealth",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [160, 32, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iVitalitY: 1, iStrength: 1, iAgility: 3 },
    spawnQuant: { '9': 1 }
  },
  //Warrior rings
  warriorRng1: {
    name: "Damaged Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  warriorRng2: {
    name: "Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [0, 64, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iDurability: 1, iStrength: 2 },
    spawnQuant: { '3': 1 }
  },
  warriorRng3: {
    name: "Enchanted Ring of Power",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [96, 96, 32, 32],
    buy: 50,
    sell: 25,
    stats: { iDurability: 1, iStrength: 3, iAgility: 1 },
    spawnQuant: { '9': 1 }
  },
  //Paladin rings
  paladinRng1: {
    name: "Damaged Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 5,
    sell: 2,
    stats: { iVitality: 1 },
    spawnQuant: { '1': 1 }
  },
  paladinRng2: {
    name: "Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 1, iDurability: 1, iStrength: 1 },
    spawnQuant: { '3': 1 }
  },
  paladinRng3: {
    name: "Enchanted Ring of Life",
    type: 'ring',
    palette: 'ringPalette',
    iconLoc: [192, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iVitality: 2, iDurability: 2, iStrength: 1 },
    spawnQuant: { '9': 1 }
  }
};
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Shields
 */

var itemShields = _defineProperty({
  mageShd1: {
    name: "Arcane Shield",
    type: 'shield',
    palette: 'armorPalette',
    iconLoc: [32, 96, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 4, iVitality: 2, iStrength: 1, iDurability: 1 },
    spawnQuant: { '6': 1 }
  },
  rogueShd1: {
    name: "Hardened Buckler",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 8, iDurability: 1, iAgility: 3 },
    spawnQuant: { '6': 1 }
  },
  warriorShd1: {
    name: "Kite Shield of Wrath",
    type: 'shield',
    palette: 'shieldPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iDefense: 12, iStrength: 3 },
    spawnQuant: { '6': 1 }
  }
}, 'warriorShd1', {
  name: "Kite Shield of Rightousness",
  type: 'shield',
  palette: 'shieldPalette',
  iconLoc: [192, 0, 32, 32],
  buy: 40,
  sell: 20,
  stats: { iDefense: 12, iVitality: 2, iDurability: 1 },
  spawnQuant: { '6': 1 }
});
'use strict';

/**
 * Weapons
 */

var itemWeapons = {
  //Wands
  wand1: {
    name: 'Bent Stick',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 160, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 8 },
    spawnQuant: { '1': 1 }
  },
  wand2: {
    name: 'Summoning Fork',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 96, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 20 },
    spawnQuant: { '2': 1 }
  },
  wand3: {
    name: 'Scavenged Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 28, iVitality: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  wand4: {
    name: 'Oak Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [96, 128, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 52, iVitality: 1, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  wand5: {
    name: 'Rune Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 72, iVitality: 2, iStrength: 2 },
    spawnQuant: { '6': 1 }
  },
  wand6: {
    name: 'Blazing Wand',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 88, iVitality: 2, iStrength: 2, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  wand7: {
    name: 'Divining Rod',
    type: 'weapon',
    palette: 'wandPalette',
    iconLoc: [0, 192, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 112, iVitality: 4, iStrength: 2, iAgility: 2 },
    spawnQuant: { '10': 1 }
  },
  //Short Weapons
  knife1: {
    name: 'Arrow Head',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 32, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iAgility: 1 },
    spawnQuant: { '1': 1 }
  },
  knife2: {
    name: 'Bone Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [64, 32, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iAgility: 2 },
    spawnQuant: { '2': 1 }
  },
  knife3: {
    name: 'Fishing Knife',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iAgility: 4 },
    spawnQuant: { '4': 1 }
  },
  knife4: {
    name: 'Jagged Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [224, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 1, iAgility: 5 },
    spawnQuant: { '5': 1 }
  },
  knife5: {
    name: 'Rune Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 32, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 48, iStrength: 2, iAgility: 6 },
    spawnQuant: { '7': 1 }
  },
  knife6: {
    name: 'Coral Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 68, iStrength: 2, iAgility: 7 },
    spawnQuant: { '9': 1 }
  },
  knife7: {
    name: 'Divining Dagger',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 92, iStrength: 3, iAgility: 9 },
    spawnQuant: { '10': 1 }
  },
  //Swords
  sword1: {
    name: 'Rough Club',
    type: 'weapon',
    palette: 'shortWepPalette',
    iconLoc: [32, 64, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iStrength: 1 },
    spawnQuant: { '1': 1 }
  },
  sword2: {
    name: 'Practice Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 12, iStrength: 2 },
    spawnQuant: { '2': 1 }
  },
  sword3: {
    name: 'Short Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 20, iStrength: 4 },
    spawnQuant: { '4': 1 }
  },
  sword4: {
    name: 'Bronze Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [64, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 32, iStrength: 5, iAgility: 1 },
    spawnQuant: { '5': 1 }
  },
  sword5: {
    name: 'Rune Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [96, 0, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 44, iStrength: 7, iAgility: 2 },
    spawnQuant: { '7': 1 }
  },
  sword6: {
    name: 'Coral Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [0, 0, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 60, iStrength: 9, iAgility: 2 },
    spawnQuant: { '9': 1 }
  },
  sword7: {
    name: 'Dark Sword',
    type: 'weapon',
    palette: 'medWepPalette',
    iconLoc: [32, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 80, iStrength: 11, iAgility: 3 },
    spawnQuant: { '10': 1 }
  },
  // Polearms
  pole1: {
    name: 'Long Pole',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [64, 128, 32, 32],
    buy: 10,
    sell: 5,
    stats: { iAttack: 4, iDurability: 1 },
    spawnQuant: { '1': 1 }
  },
  pole2: {
    name: 'Big Spade',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 128, 32, 32],
    buy: 20,
    sell: 10,
    stats: { iAttack: 8, iVitality: 1, iDurability: 1 },
    spawnQuant: { '2': 1 }
  },
  pole3: {
    name: 'Trident',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [192, 0, 32, 32],
    buy: 40,
    sell: 20,
    stats: { iAttack: 16, iVitality: 2, iDurability: 1, iStrength: 1 },
    spawnQuant: { '4': 1 }
  },
  pole4: {
    name: 'Narrow Spear',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [160, 0, 32, 32],
    buy: 60,
    sell: 30,
    stats: { iAttack: 24, iVitality: 3, iDurability: 2, iStrength: 2 },
    spawnQuant: { '5': 1 }
  },
  pole5: {
    name: 'Rune Voulge',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 64, 32, 32],
    buy: 80,
    sell: 40,
    stats: { iAttack: 36, iVitality: 4, iDurability: 2, iStrength: 4 },
    spawnQuant: { '7': 1 }
  },
  pole6: {
    name: 'Coral Bardiche',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [32, 128, 32, 32],
    buy: 110,
    sell: 55,
    stats: { iAttack: 48, iVitality: 4, iDurability: 4, iStrength: 5 },
    spawnQuant: { '9': 1 }
  },
  pole7: {
    name: 'Royal Poleaxe',
    type: 'weapon',
    palette: 'longWepPalette',
    iconLoc: [128, 0, 32, 32],
    buy: 140,
    sell: 70,
    stats: { iAttack: 72, iVitality: 5, iDurability: 5, iStrength: 5 },
    spawnQuant: { '10': 1 }
  }
};
'use strict';

var interactivePortals = {
  inactivePortal: {
    name: 'Inactive Portal',
    type: 'door',
    palette: ['door0Palette', 'door1Palette'],
    iconLoc: [64, 160, 32, 32]
  },
  activePortal: {
    name: 'Active Portal',
    type: 'door',
    palette: ['door0Palette', 'door1Palette'],
    iconLoc: [96, 160, 32, 32]
  }
};
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: gameLevel, levelUpCount, interactItem, increasedStat, exchangeAttacks, enemyDead

var ActivityLog = function (_React$Component) {
  _inherits(ActivityLog, _React$Component);

  function ActivityLog(props) {
    _classCallCheck(this, ActivityLog);

    var _this = _possibleConstructorReturn(this, (ActivityLog.__proto__ || Object.getPrototypeOf(ActivityLog)).call(this, props));

    _this.initActivityLog = _this.initActivityLog.bind(_this);
    _this.recycleLog = _this.recycleLog.bind(_this);
    _this.resetLog = _this.resetLog.bind(_this);
    _this.logAdd = _this.logAdd.bind(_this);
    _this.logLevelUp = _this.logLevelUp.bind(_this);
    _this.logItem = _this.logItem.bind(_this);
    _this.logStatPoint = _this.logStatPoint.bind(_this);
    _this.logAttacks = _this.logAttacks.bind(_this);
    _this.logEnemyDead = _this.logEnemyDead.bind(_this);

    _this.logLen = 300;
    _this.renderLen = 30;
    _this.logArrayPadding = 10;
    _this.enemyDeadCount = 0;

    _this.state = {
      log: [],
      //{type:'', message:''}
      index: -1
    };
    return _this;
  }

  _createClass(ActivityLog, [{
    key: 'initActivityLog',
    value: function initActivityLog() {
      var log = this.state.log;


      log.length = this.logLen;
      this.setState({ log: log });
    }
  }, {
    key: 'resetLog',
    value: function resetLog() {
      this.setState({ index: -1 });
    }
  }, {
    key: 'recycleLog',
    value: function recycleLog(log, index) {
      var len = this.renderLen;

      var i = 0;

      for (; i < len; i++) {
        log[i] = log[index - len + i + 1];
      }index = len - 1;

      this.setState({ log: log, index: index });
    }
  }, {
    key: 'logAdd',
    value: function logAdd(logArr) {
      var _state = this.state,
          index = _state.index,
          log = _state.log;


      logArr.forEach(function (el) {
        index++, log[index] = el;
      });

      if (index > this.logLen - this.logArrayPadding) this.recycleLog(log, index);else this.setState({ log: log, index: index });
    }
  }, {
    key: 'logLevelUp',
    value: function logLevelUp() {
      this.logAdd([{ type: 'log-level', message: 'Level Up!' }]);
    }
  }, {
    key: 'logItem',
    value: function logItem(nextProps) {
      var interactItem = nextProps.interactItem,
          action = interactItem.type,
          itemType = 'log-item',
          statType = 'log-stat';


      var verb = action.charAt(0).toUpperCase() + action.slice(1),
          itemLog = [],
          stat = '',
          statDisplay = void 0;

      if (action.slice(0, 3) === 'buy') {
        if (action === 'buySuccess') {
          itemLog.push({ type: itemType, message: verb.slice(0, 3) + ' ' + interactItem.item.name });
        } else if (action === 'buyFail') {
          itemLog.push({ type: itemType, message: 'Not enough to buy.' });
        }
      } else {
        itemLog.push({ type: itemType, message: verb + ' ' + interactItem.item.name });
      }

      if (action === 'use') {
        for (stat in interactItem.item.stats) {
          statDisplay = stat === 'curHealth' ? stat.slice(3) : stat.slice(1);
          itemLog.push({ type: statType, message: 'Increased ' + statDisplay });
        }
      }

      this.logAdd(itemLog);
    }
  }, {
    key: 'logStatPoint',
    value: function logStatPoint(nextProps) {
      var increasedStat = nextProps.increasedStat;


      this.logAdd([{ type: 'log-stat', message: increasedStat.type + ' ' + increasedStat.stat + '.' }]);
    }
  }, {
    key: 'logAttacks',
    value: function logAttacks(nextProps) {
      var enemyDead = nextProps.enemyDead,
          attacks = nextProps.exchangeAttacks.attacks,
          type = 'log-attack';


      var message = '',
          attackLog = [];

      attacks.forEach(function (el) {
        message = el.from === 'hero' ? 'You attack ' + el.to + '.' : el.from + ' attacks you.';
        attackLog.push({ type: type, message: message });

        message = el.type.charAt(0).toUpperCase() + el.type.slice(1) + ': ' + el.damage + ' damage.';
        attackLog.push({ type: type, message: message });
      });

      if (enemyDead.count !== this.enemyDeadCount) this.logEnemyDead(enemyDead, attackLog);else this.logAdd(attackLog);
    }
  }, {
    key: 'logEnemyDead',
    value: function logEnemyDead(enemyDead, attackLog) {
      var experience = enemyDead.experience,
          gold = enemyDead.gold,
          source = enemyDead.source,
          count = enemyDead.count,
          name = source.name,
          enemyDeadType = 'log-attack',
          experienceType = 'log-stat';


      attackLog.push({ type: enemyDeadType, message: name + ' died.' });
      attackLog.push({ type: experienceType, message: 'Gained ' + experience + ' experience.' });
      attackLog.push({ type: experienceType, message: 'Looted ' + gold + ' gold.' });

      if (source.boss) {
        attackLog.push({ type: experienceType, message: 'A portal has opened somewhere....' });
      }

      this.enemyDeadCount = count;
      this.logAdd(attackLog);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initActivityLog();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.levelUpCount !== nextProps.levelUpCount) {
        this.logLevelUp();
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count) {
        this.logItem(nextProps);
      }
      if (this.props.increasedStat.count !== nextProps.increasedStat.count) {
        this.logStatPoint(nextProps);
      }
      if (this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count) {
        this.logAttacks(nextProps);
      }
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.resetLog();
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.levelUpCount !== nextProps.levelUpCount || this.props.interactItem.count !== nextProps.interactItem.count || this.props.increasedStat.count !== nextProps.increasedStat.count || this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count || this.props.gameLevel !== nextProps.gameLevel) {

        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _state2 = this.state,
          log = _state2.log,
          index = _state2.index,
          len = index < this.renderLen - 1 ? index : this.renderLen - 1;


      var renderLog = [],
          i = 0;

      for (i = len; i > -1; i--) {
        renderLog.push(React.createElement(ActivityLogRow, {
          key: i + log[index - i].message,
          type: log[index - i].type,
          message: log[index - i].message }));
      }

      return React.createElement(
        'div',
        { className: 'activity-log' },
        React.createElement(
          'div',
          { className: 'log-content' },
          renderLog
        )
      );
    }
  }]);

  return ActivityLog;
}(React.Component);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: type, message

var ActivityLogRow = function (_React$Component) {
  _inherits(ActivityLogRow, _React$Component);

  function ActivityLogRow() {
    _classCallCheck(this, ActivityLogRow);

    return _possibleConstructorReturn(this, (ActivityLogRow.__proto__ || Object.getPrototypeOf(ActivityLogRow)).apply(this, arguments));
  }

  _createClass(ActivityLogRow, [{
    key: "render",
    value: function render() {

      return React.createElement(
        "p",
        { className: "log " + this.props.type },
        this.props.message
      );
    }
  }]);

  return ActivityLogRow;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, inventory, itemPalettes, interactItem, quickConsume, updateGameClassState
var ConsumableItems = function (_React$Component) {
  _inherits(ConsumableItems, _React$Component);

  function ConsumableItems(props) {
    _classCallCheck(this, ConsumableItems);

    var _this = _possibleConstructorReturn(this, (ConsumableItems.__proto__ || Object.getPrototypeOf(ConsumableItems)).call(this, props));

    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.updateConsumeCanvas = _this.updateConsumeCanvas.bind(_this);

    _this.state = {
      cItems: ['potion', 'hiPotion', 'xPotion', 'tomeOfVitality', 'tomeOfDurability', 'tomeOfStrength', 'tomeOfAgility', 'tomeOfWisdom']
    };
    return _this;
  }

  _createClass(ConsumableItems, [{
    key: 'handleInteractItem',
    value: function handleInteractItem(nextProps) {
      var num = nextProps.quickConsume.num,
          inv = nextProps.inventory,
          interactItem = Object.assign({}, nextProps.interactItem),
          m = consumableAbbrevMap;

      var name = '',
          item = null,
          props = null;

      for (props in m) {
        if (num == m[props].num) name = m[props].name;
      }

      item = inv[name];

      if (item && item.count > 0) {
        interactItem.count += 1;
        interactItem.type = 'use';
        interactItem.item = item;

        nextProps.updateGameClassState({ interactItem: interactItem });
      }
    }
  }, {
    key: 'updateConsumeCanvas',
    value: function updateConsumeCanvas(nextProps) {
      var interactItem = nextProps.interactItem,
          inventory = nextProps.inventory,
          item = interactItem.item,
          type = interactItem.type,
          m = consumableAbbrevMap;


      var update = false,
          props = null,
          dCtx = null,
          palette = null,
          loc = [];

      if (inventory[item.name].count === 1 && ['pickup', 'buySuccess'].includes(type) || inventory[item.name].count === 0 && ['use', 'sell'].includes(type)) {

        update = true;
      }

      if (update) {
        for (props in m) {
          if (item.name === m[props].name) dCtx = getById(props + '-canvas').getContext('2d');
        }

        palette = nextProps.itemPalettes[item.palette];
        loc = item.iconLoc;

        if (['use', 'sell'].includes(type)) dCtx.clearRect(0, 0, loc[2], loc[3]);else dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.quickConsume.count !== nextProps.quickConsume.count && nextProps.quickConsume.count) {

        this.handleInteractItem(nextProps);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count && ['pickup', 'use', 'buySuccess', 'sell'].includes(nextProps.interactItem.type) && nextProps.interactItem.item.type === 'consumable') {

        this.updateConsumeCanvas(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.quickConsume.count !== nextProps.quickConsume.count || this.props.interactItem.count !== nextProps.interactItem.count) {

        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var m = consumableAbbrevMap,
          itm = this.state.cItems,
          inv = this.props.inventory,
          ts = this.props.tileSize;

      var output = [],
          count = 0;

      output = itm.map(function (el) {
        count = 0;
        if (inv[m[el].name]) count = inv[m[el].name].count;
        return React.createElement(
          'div',
          { className: 'consumable-col', key: 'consumable-col' + m[el].num },
          React.createElement(
            'p',
            { className: 'consumable-col-num', key: 'consumable-col-num' + m[el].num },
            m[el].num
          ),
          React.createElement('canvas', {
            id: el + '-canvas',
            className: 'consumable-canvas',
            key: el + '-canvas',
            width: ts,
            height: ts }),
          React.createElement(
            'p',
            { className: 'consumable-col-abbrev', key: 'consumable-col-abbrev' + m[el].num },
            m[el].abbrev
          ),
          React.createElement(
            'p',
            { className: 'consumable-col-count', key: 'consumable-col-count' + m[el].num },
            'x' + count
          )
        );
      });

      return React.createElement(
        'div',
        { className: 'consumable-items' },
        output
      );
    }
  }]);

  return ConsumableItems;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: enemyDead, gameLevel

var CurrentObjective = function (_React$Component) {
  _inherits(CurrentObjective, _React$Component);

  function CurrentObjective(props) {
    _classCallCheck(this, CurrentObjective);

    var _this = _possibleConstructorReturn(this, (CurrentObjective.__proto__ || Object.getPrototypeOf(CurrentObjective)).call(this, props));

    _this.resetBossDead = _this.resetBossDead.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);

    _this.enemyDeadCount = 0;
    _this.objectives = {
      'false': 'Find and slay boss',
      'true': 'Travel through portal'
    };

    _this.state = {
      bossDead: false
    };
    return _this;
  }

  _createClass(CurrentObjective, [{
    key: 'resetBossDead',
    value: function resetBossDead() {
      this.setState({ bossDead: false });
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead;


      this.enemyDeadCount = enemyDead.count;

      if (enemyDead.source.boss) this.setState({ bossDead: true });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.resetBossDead();
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.state.bossDead !== nextState.bossDead) {

        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'current-objective' },
        React.createElement(
          'p',
          null,
          'Current Objective'
        ),
        React.createElement(
          'p',
          null,
          this.objectives[this.state.bossDead]
        )
      );
    }
  }]);

  return CurrentObjective;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//tileSize, floor, source, spawnIndex, spawnCoord, bgArr, playerArr, moveCount, enemyArr, enemyDisplayArr, updateEnemyDisplayArr, updateEnemyManager, displayCount,
//updateGameClassState, pollCount, incrementPollCount, enemyTurn, updateEnemyTurn, enemyDead, enemyPalettes, roundCount, roundEnemyArr, exchangeAttacks
var Enemy = function (_React$Component) {
  _inherits(Enemy, _React$Component);

  function Enemy(props) {
    _classCallCheck(this, Enemy);

    var _this = _possibleConstructorReturn(this, (Enemy.__proto__ || Object.getPrototypeOf(Enemy)).call(this, props));

    _this.initEnemy = _this.initEnemy.bind(_this);
    _this.chooseMove = _this.chooseMove.bind(_this);
    _this.attemptMove = _this.attemptMove.bind(_this);
    _this.completeMove = _this.completeMove.bind(_this);
    _this.stay = _this.stay.bind(_this);
    _this.attack = _this.attack.bind(_this);
    _this.die = _this.die.bind(_this);
    _this.takeDamage = _this.takeDamage.bind(_this);
    _this.startTurn = _this.startTurn.bind(_this);
    _this.updateEnemyDisplay = _this.updateEnemyDisplay.bind(_this);

    _this.attemptMoveCoefficient = 19;
    _this.positionsTaken = [0, 0, 0, 0];

    _this.state = {
      level: 0,
      maxHealth: 0,
      curHealth: 0,
      baseStats: {},
      position: [],
      icon: null
    };
    return _this;
  }

  _createClass(Enemy, [{
    key: 'initEnemy',
    value: function initEnemy() {
      var _props = this.props,
          source = _props.source,
          tileSize = _props.tileSize,
          enemyPalettes = _props.enemyPalettes,
          level = randInt(source.levelRange[0], source.levelRange[1]),
          bStats = source.baseStats,
          onLvl = source.onLevelUp,
          position = this.props.spawnCoord,
          convert = statConversion,
          smoothingEnabled = false;


      var icon = document.createElement('canvas'),
          baseStats = {},
          maxHealth = 0,
          curHealth = 0,
          stat = 0,
          el = null,
          ctx = null;

      icon.width = tileSize;
      icon.height = tileSize;
      ctx = icon.getContext('2d');
      ctx.imageSmoothingEnabled = smoothingEnabled;

      ctx.drawImage(enemyPalettes[source.palette[0]], source.iconLoc[0], source.iconLoc[1], tileSize, tileSize, 0, 0, tileSize, tileSize);

      for (el in bStats) {
        stat = bStats[el];
        if (onLvl[el]) stat += level * onLvl[el];
        baseStats[el] = stat;
      }

      maxHealth = baseStats.bHealth + convert.vitToHp * baseStats.bVitality + convert.durToHp * baseStats.bDurability;
      curHealth = maxHealth;

      this.updateEnemyDisplay(position, curHealth, maxHealth, level, icon);
      this.setState({ level: level, maxHealth: maxHealth, curHealth: curHealth, baseStats: baseStats, position: position, icon: icon });
    }
  }, {
    key: 'updateEnemyDisplay',
    value: function updateEnemyDisplay() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.position;
      var curHealth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.curHealth;
      var maxHealth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.maxHealth;
      var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.state.level;
      var icon = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.state.icon;
      var _props2 = this.props,
          source = _props2.source,
          spawnIndex = _props2.spawnIndex;


      var enemyDisplay = {
        position: position,
        curHealth: curHealth,
        maxHealth: maxHealth,
        level: level,
        icon: icon,
        name: source.name,
        type: source.type
      };

      this.props.updateEnemyDisplayArr(enemyDisplay, spawnIndex);
    }
  }, {
    key: 'chooseMove',
    value: function chooseMove(fromCoord, playerArr, roundEnemyArr, bgArr) {
      var floor = this.props.floor,
          h = 1.001,
          blocked = 1000,
          countMax = 100;


      var openStack = [],
          coord = [],
          path = [],
          openSet = {},
          closedSet = {},
          explored = {},
          parent = {},
          current = {},
          costToSpace = 0,
          costToGoal = 0,
          nextStep = 0,
          fCost = 0,
          index = 0,
          count = 0,
          row = 0,
          col = 0;

      //set structure: {'12,43': {coord: [], parent: {}, costToSpace, costToGoal, fCost}}

      costToGoal = h * (Math.abs(fromCoord[0] - playerArr[0]) + Math.abs(fromCoord[1] - playerArr[1]));
      fCost = costToGoal;
      explored['' + fromCoord] = { costToSpace: costToSpace, costToGoal: costToGoal, fCost: fCost, coord: fromCoord, parent: {} };
      openSet['' + fromCoord] = explored['' + fromCoord];
      openStack.push(openSet['' + fromCoord]);

      while (!(openStack[0].coord[0] === playerArr[0] && openStack[0].coord[1] === playerArr[1])) {
        current = openStack.shift();
        row = current.coord[0];
        col = current.coord[1];
        count++;

        delete openSet['' + current.coord];

        [[row - 1, col], [row + 1, col], [row, col + 1], [row, col - 1]].forEach(function (neighbor) {
          if (bgArr[neighbor[0]][neighbor[1]] > floor && !roundEnemyArr[neighbor[0]][neighbor[1]]) {
            nextStep = 1;
          } else {
            nextStep = blocked;
          }
          costToSpace = current.costToSpace + nextStep;

          if (openSet['' + neighbor] && costToSpace < openSet['' + neighbor].costToSpace) {
            index = openStack.findIndex(function (el) {
              return el[0] === neighbor[0] && el[1] === neighbor[1];
            });
            openStack.splice(index, 1);
            delete openSet['' + neighbor];
          }
          if (closedSet['' + neighbor] && costToSpace < closedSet['' + neighbor].costToSpace) {
            delete closedSet['' + neighbor];
          }
          if (!openSet['' + neighbor] && !closedSet['' + neighbor]) {
            costToGoal = h * (Math.abs(neighbor[0] - playerArr[0]) + Math.abs(neighbor[1] - playerArr[1]));
            fCost = costToSpace + costToGoal;
            parent = explored['' + current.coord];
            explored['' + neighbor] = { costToSpace: costToSpace, costToGoal: costToGoal, fCost: fCost, parent: parent, coord: neighbor };
            openSet['' + neighbor] = explored['' + neighbor];
            index = openStack.findIndex(function (el) {
              return fCost < el.fCost;
            });
            if (index > -1) openStack.splice(index, 0, openSet['' + neighbor]);else openStack.push(openSet['' + neighbor]);
          }
        });
        if (count > countMax) {
          console.log('MOVE LIMIT EXCEEDED');
          break;
        }
      }

      current = openStack[0];
      coord = current.coord;
      while (coord.length && !(coord[0] === fromCoord[0] && coord[1] === fromCoord[1])) {
        path.unshift(coord);
        current = current.parent;
        coord = current.coord;
      }

      return path[0];
    }
  }, {
    key: 'attemptMove',
    value: function attemptMove(nextProps) {
      var bgArr = nextProps.bgArr,
          roundEnemyArr = nextProps.roundEnemyArr,
          playerArr = nextProps.playerArr,
          source = nextProps.source,
          stats = this.state.baseStats,
          fromCoord = this.state.position,
          toCoord = [],
          turn = {};


      toCoord = this.chooseMove(fromCoord, playerArr, roundEnemyArr, bgArr);
      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        source: source,
        fromCoord: fromCoord,
        toCoord: toCoord,
        type: 'move',
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'completeMove',
    value: function completeMove(position) {
      this.updateEnemyDisplay(position);
      this.setState({ position: [].concat(_toConsumableArray(position)) });
    }
  }, {
    key: 'stay',
    value: function stay(nextProps) {
      var stats = this.state.baseStats,
          coord = this.state.position,
          turn = {};

      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        type: 'stay',
        source: nextProps.source,
        fromCoord: coord,
        toCoord: coord,
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'attack',
    value: function attack(nextProps) {
      var playerArr = nextProps.playerArr,
          source = nextProps.source,
          stats = this.state.baseStats,
          fromCoord = this.state.position,
          turn = {};


      stats.curHealth = this.state.curHealth;
      turn = {
        stats: stats,
        source: source,
        fromCoord: fromCoord,
        type: 'attack',
        toCoord: playerArr,
        status: false
      };

      this.props.updateEnemyTurn(turn, nextProps.spawnIndex);
      this.props.incrementPollCount();
    }
  }, {
    key: 'die',
    value: function die() {
      var _state = this.state,
          position = _state.position,
          level = _state.level,
          _props3 = this.props,
          spawnIndex = _props3.spawnIndex,
          source = _props3.source,
          enemyDead = Object.assign(this.props.enemyDead),
          conv = statConversion;


      var experience = 0,
          gold = 0,
          i = 0;

      for (; i < level; i++) {
        experience += randInt(conv.lvlToExpRange[0], conv.lvlToExpRange[1]);
        gold += randInt(conv.lvlToGoldRange[0], conv.lvlToGoldRange[1]);
      }

      if (this.props.source.boss) experience *= conv.bossMultiplier, gold *= conv.bossMultiplier;

      enemyDead.count++;
      enemyDead.spawnIndex = spawnIndex;
      enemyDead.coord = position;
      enemyDead.source = source, enemyDead.level = level;
      enemyDead.experience = ~~experience;
      enemyDead.gold = ~~gold;

      this.props.updateGameClassState({ enemyDead: enemyDead });
    }
  }, {
    key: 'takeDamage',
    value: function takeDamage(attacks) {
      var curHealth = this.state.curHealth,
          damage = 0;


      attacks.forEach(function (el) {
        if (el.from === 'hero') damage = el.damage;
      });

      curHealth = curHealth - damage > 0 ? curHealth - damage : 0;

      if (!curHealth) this.die();

      this.updateEnemyDisplay(this.state.position, curHealth);
      this.props.updateEnemyManager({ displayCount: this.props.displayCount + 1 });
      this.setState({ curHealth: curHealth });
    }
  }, {
    key: 'startTurn',
    value: function startTurn(nextProps) {
      var _state2 = this.state,
          position = _state2.position,
          curHealth = _state2.curHealth,
          playerArr = nextProps.playerArr,
          aggression = nextProps.source.aggression;


      if (curHealth < 1 || linearDistance(position, playerArr) > aggression) {
        this.stay(nextProps);
      } else if (playerArr[0] === position[0] && Math.pow(playerArr[1] - position[1], 2) === 1 || playerArr[1] === position[1] && Math.pow(playerArr[0] - position[0], 2) === 1) {
        this.attack(nextProps);
      } else if (aggression + 94 > randInt(1, 100)) {
        this.attemptMove(nextProps);
      } else {
        this.stay(nextProps);
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initEnemy();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.pollCount === 0 && this.props.moveCount !== nextProps.moveCount) {

        this.startTurn(nextProps);
      }
      if (this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count && nextProps.exchangeAttacks.spawnIndex === nextProps.spawnIndex) {

        this.takeDamage(nextProps.exchangeAttacks.attacks);
      }
      if (this.props.roundCount !== nextProps.roundCount && nextProps.enemyTurn[this.props.spawnIndex].type === 'move' && nextProps.enemyTurn[this.props.spawnIndex].status) {

        this.completeMove(nextProps.enemyTurn[nextProps.spawnIndex].toCoord);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {

      return React.createElement('div', null);
    }
  }]);

  return Enemy;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//gameLevel, bgArr, floorCoords, playerArr, enemyArr, enemyAttack, exchangeAttacks,
//moveCount, updateGameClassState, tileSize, floor, enemyPalettes, enemyDead, itemLevelProcessed
var EnemyManager = function (_React$Component) {
  _inherits(EnemyManager, _React$Component);

  function EnemyManager(props) {
    _classCallCheck(this, EnemyManager);

    var _this = _possibleConstructorReturn(this, (EnemyManager.__proto__ || Object.getPrototypeOf(EnemyManager)).call(this, props));

    _this.setLevelEnemies = _this.setLevelEnemies.bind(_this);
    _this.runEnemyRound = _this.runEnemyRound.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.updateEnemyManager = _this.updateEnemyManager.bind(_this);
    _this.incrementPollCount = _this.incrementPollCount.bind(_this);
    _this.updateEnemyTurn = _this.updateEnemyTurn.bind(_this);
    _this.updateEnemyDisplayArr = _this.updateEnemyDisplayArr.bind(_this);
    _this.setEnemyDisplay = _this.setEnemyDisplay.bind(_this);
    _this.drawEnemyIcon = _this.drawEnemyIcon.bind(_this);

    _this.pollCount = -1;
    _this.enemyDeadCount = 0;
    _this.enemyTurn = [];
    //enemyTurn: [{ type: '', source: {}, stats: {}, fromCoord: [], toCoord: [], status: bool },]
    //type: 'move', 'stay', 'attack', 'die'

    _this.enemyDisplayArr = [];
    //{name: '', type: '', icon: <memCanvas>, level: 0, curHealth: 0, maxHealth: 0, position: []}
    _this.enemyDisplay = {};

    _this.state = {
      roundCount: 0,
      displayCount: 0,
      levelProcessed: 0,
      enemiesRemaining: 0,
      currentIndex: 0,
      levelEnemies: [],
      roundEnemyArr: [],
      nextKey: 0

    };
    return _this;
  }

  _createClass(EnemyManager, [{
    key: 'incrementPollCount',
    value: function incrementPollCount() {
      this.pollCount++;

      if (this.pollCount === this.state.levelEnemies.length) {
        this.runEnemyRound(this.props);
      }
    }
  }, {
    key: 'updateEnemyTurn',
    value: function updateEnemyTurn(turn, index) {
      this.enemyTurn[index] = turn;
    }
  }, {
    key: 'updateEnemyDisplayArr',
    value: function updateEnemyDisplayArr(enemy, index) {
      this.enemyDisplayArr[index] = enemy;
    }
  }, {
    key: 'setLevelEnemies',
    value: function setLevelEnemies() {
      var _props = this.props,
          gameLevel = _props.gameLevel,
          itemLevelProcessed = _props.itemLevelProcessed,
          bgArr = _props.bgArr,
          len = bgArr.length,
          enemyList = [enemyAvian, enemyDemon, enemyElemental, enemyHumanoid, enemyReptile, enemyUndead],
          centerFloorSpace = 45;
      var floorCoords = [].concat(_toConsumableArray(this.props.floorCoords)),
          enemyArr = initZeroArray(len),
          nextKey = this.state.nextKey,
          levelEnemies = [],
          spawnCoord = [],
          curCoord = [0, 0],
          curIndex = 0,
          source = {},
          el = null,
          enemiesRemaining = 0,
          count = 0,
          i = 0;


      enemyList.forEach(function (obj) {
        for (el in obj) {
          source = obj[el];
          count = source.spawnQuant['' + gameLevel] ? source.spawnQuant['' + gameLevel] : 0;
          enemiesRemaining += count;
          i = 0;

          while (i < count) {
            if (source.type === 'merchant') {
              while (!(bgArr[curCoord[0]][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0] - 1][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0]][curCoord[1] + 1] === centerFloorSpace && bgArr[curCoord[0] + 1][curCoord[1]] === centerFloorSpace && bgArr[curCoord[0]][curCoord[1] - 1] === centerFloorSpace)) {
                curIndex = randInt(0, floorCoords.length - 1);
                curCoord = floorCoords[curIndex];
              }
              spawnCoord = floorCoords.splice(curIndex, 1)[0];
              console.log('Merchant at: ', spawnCoord);
            } else {
              spawnCoord = floorCoords.splice(randInt(0, floorCoords.length - 1), 1)[0];
            }

            enemyArr[spawnCoord[0]][spawnCoord[1]] = source;
            nextKey++;

            levelEnemies.push({ source: source, spawnCoord: spawnCoord, key: nextKey });
            i++;

            if (source.boss) console.log('Boss at: ', spawnCoord);
          }
        }
      });

      this.enemyTurn.length = enemiesRemaining;
      this.enemyDisplayArr.length = enemiesRemaining;

      this.props.updateGameClassState({ floorCoords: floorCoords, enemyArr: enemyArr });

      this.setState({
        levelEnemies: levelEnemies,
        enemiesRemaining: enemiesRemaining,
        nextKey: nextKey,
        levelProcessed: itemLevelProcessed,
        roundEnemyArr: enemyArr
      });
    }
  }, {
    key: 'runEnemyRound',
    value: function runEnemyRound(props) {
      var enemyAttack = props.enemyAttack;
      var enemyTurn = [].concat(_toConsumableArray(this.enemyTurn)),
          roundEnemyArr = [].concat(_toConsumableArray(this.state.roundEnemyArr)),
          _state = this.state,
          roundCount = _state.roundCount,
          currentIndex = _state.currentIndex,
          levelEnemies = _state.levelEnemies,
          count = enemyAttack.count,
          type = '',
          source = {},
          stats = {},
          toCoord = [],
          fromCoord = [],
          status = false,
          spawnIndex = 0;


      while (currentIndex < this.pollCount) {
        var _enemyTurn$currentInd = enemyTurn[currentIndex];
        type = _enemyTurn$currentInd.type;
        source = _enemyTurn$currentInd.source;
        stats = _enemyTurn$currentInd.stats;
        fromCoord = _enemyTurn$currentInd.fromCoord;
        toCoord = _enemyTurn$currentInd.toCoord;
        status = _enemyTurn$currentInd.status;


        if (type === 'stay') {
          enemyTurn[currentIndex].status = true;
        } else if (type === 'move') {
          status = roundEnemyArr[toCoord[0]][toCoord[1]] === 0 ? true : false;

          if (status) {
            roundEnemyArr[fromCoord[0]][fromCoord[1]] = 0;
            roundEnemyArr[toCoord[0]][toCoord[1]] = source;
          }
          enemyTurn[currentIndex].status = status;
        } else if (type === 'attack') {
          count++;
          spawnIndex = currentIndex;
          enemyTurn[currentIndex].status = true;

          props.updateGameClassState({ enemyAttack: { count: count, roundCount: roundCount, spawnIndex: spawnIndex, stats: stats, source: source } });
        }
        currentIndex++;
      }

      if (currentIndex === levelEnemies.length) {
        currentIndex = 0;
        this.pollCount = 0;
        roundCount++;

        props.updateGameClassState({ enemyArr: roundEnemyArr });
      }

      this.enemyTurn = [].concat(enemyTurn);
      this.setState({ roundEnemyArr: roundEnemyArr, currentIndex: currentIndex, roundCount: roundCount });
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead,
          coord = enemyDead.coord,
          count = enemyDead.count;
      var enemyArr = nextProps.enemyArr,
          roundEnemyArr = this.state.roundEnemyArr;


      roundEnemyArr[coord[0]][coord[1]] = 0;
      enemyArr = [].concat(_toConsumableArray(roundEnemyArr));
      this.enemyDeadCount = count;

      nextProps.updateGameClassState({ enemyArr: enemyArr });
      this.setState({ roundEnemyArr: roundEnemyArr });
    }
  }, {
    key: 'updateEnemyManager',
    value: function updateEnemyManager() {
      var updatedEls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setState(updatedEls);
    }
  }, {
    key: 'drawEnemyIcon',
    value: function drawEnemyIcon(icon) {
      var ts = this.props.tileSize;

      var ctx = getById('enemy-icon').getContext('2d');

      ctx.clearRect(0, 0, ts, ts);

      if (icon) ctx.drawImage(icon, 0, 0);
    }
  }, {
    key: 'setEnemyDisplay',
    value: function setEnemyDisplay(nextProps, nextState) {
      var playerArr = nextProps.playerArr,
          enemyDisplayArr = this.enemyDisplayArr;


      var displayRange = 5,
          displayChoice = {},
          position = [],
          icon = null,
          updateDisplayChoice = false,
          distance = 0,
          healthLost = 0,
          maxHealth = 0,
          curHealth = 0,
          index = 0;

      enemyDisplayArr.forEach(function (el, i) {
        if (el && el.curHealth) {
          updateDisplayChoice = false;
          position = enemyDisplayArr[i].position;
          distance = Math.abs(playerArr[0] - position[0]) + Math.abs(playerArr[1] - position[1]);

          if (position[0] === playerArr[0] || position[1] === playerArr[1]) {
            displayRange = 4;
          } else {
            displayRange = 5;
          }

          if (distance <= displayRange) {
            index = i;
            maxHealth = el.maxHealth;
            curHealth = el.curHealth;
            healthLost = maxHealth - curHealth;

            if (!displayChoice.maxHealth || distance < displayChoice.distance) {
              updateDisplayChoice = true;
            } else if (distance === displayChoice.distance) {
              if (healthLost > displayChoice.healthLost) {
                updateDisplayChoice = true;
              } else if (healthLost === displayChoice.healthLost) {
                if (maxHealth > displayChoice.maxHealth) updateDisplayChoice = true;
              }
            }

            if (updateDisplayChoice) {
              displayChoice = { position: position, distance: distance, index: index, maxHealth: maxHealth, curHealth: curHealth, healthLost: healthLost };
            }
          }
        }
      });

      if (!(displayChoice.index && enemyDisplayArr[displayChoice.index].curHealth === this.enemyDisplay.curHealth && enemyDisplayArr[displayChoice.index].name === this.enemyDisplay.name && enemyDisplayArr[displayChoice.index].level === this.enemyDisplay.level)) {

        this.enemyDisplay = displayChoice.curHealth ? enemyDisplayArr[displayChoice.index] : {};
        icon = this.enemyDisplay.icon ? this.enemyDisplay.icon : false;

        this.drawEnemyIcon(icon);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.pollCount === -1 && this.state.levelEnemies.length && this.props.moveCount !== nextProps.moveCount) {
        this.pollCount = 0;
      }
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.moveCount !== nextProps.moveCount || this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count || this.state.roundCount !== nextState.roundCount || this.state.displayCount !== nextState.displayCount || nextState.levelProcessed !== nextProps.itemLevelProcessed) {

        return true;
      }
      return false;
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.props.moveCount !== nextProps.moveCount || this.state.displayCount !== nextState.displayCount) {
        this.setEnemyDisplay(nextProps, nextState);
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.levelProcessed !== this.props.itemLevelProcessed && Object.keys(this.props.enemyPalettes).length) {

        this.setLevelEnemies();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var levelEnemies = this.state.levelEnemies,
          ts = this.props.tileSize,
          enemyDisplay = this.enemyDisplay,
          healthMaxWidth = 10;


      var enemies = [],
          spawnCoord = [],
          source = {},
          key = 0,
          containerHeader = null,
          displayName = null,
          displayType = null,
          displayLevel = null,
          displayHealth = null,
          healthTitleWidth = '',
          healthBorder = 'none',
          healthMaxWidthStyle = '',
          healthPercent = 0,
          healthWidth = '',
          healthColor = 'none';

      levelEnemies.forEach(function (obj) {
        source = obj.source;
        spawnCoord = obj.spawnCoord;
        key = obj.key;


        enemies.push(React.createElement(Enemy, {
          key: source.name + key,
          source: source,
          spawnIndex: enemies.length,
          spawnCoord: spawnCoord,
          floor: _this2.props.floor,
          tileSize: _this2.props.tileSize,
          bgArr: _this2.props.bgArr,
          playerArr: _this2.props.playerArr,
          moveCount: _this2.props.moveCount,
          displayCount: _this2.state.displayCount,
          enemyArr: _this2.props.enemyArr,
          roundEnemyArr: _this2.state.roundEnemyArr,
          enemyPalettes: _this2.props.enemyPalettes,
          enemyDead: _this2.props.enemyDead,
          pollCount: _this2.pollCount,
          incrementPollCount: _this2.incrementPollCount,
          roundCount: _this2.state.roundCount,
          enemyTurn: _this2.enemyTurn,
          enemyDisplayArr: _this2.enemyDisplayArr,
          updateEnemyTurn: _this2.updateEnemyTurn,
          updateEnemyDisplayArr: _this2.updateEnemyDisplayArr,
          exchangeAttacks: _this2.props.exchangeAttacks,
          updateEnemyManager: _this2.updateEnemyManager,
          updateGameClassState: _this2.props.updateGameClassState }));
      });

      if (enemyDisplay.name) {
        containerHeader = enemyDisplay.type === 'merchant' ? 'Merchant' : 'Enemy';
        displayName = enemyDisplay.name;
        displayType = enemyDisplay.type[0].toUpperCase() + enemyDisplay.type.slice(1);
        displayLevel = enemyDisplay.level;
        displayHealth = enemyDisplay.curHealth + '/' + enemyDisplay.maxHealth;
        healthTitleWidth = '6em';
        healthMaxWidthStyle = healthMaxWidth + 'em';
        healthBorder = '1px solid rgb(0, 0, 0)';
        healthPercent = ~~(enemyDisplay.curHealth / enemyDisplay.maxHealth * 100);
        healthWidth = healthPercent + '%';
        healthColor = healthPercent > 70 ? 'rgba(0,255,0,.8)' : healthPercent > 30 ? 'rgba(255,255,0,.8)' : 'rgba(255,0,0,.7)';
      }

      return React.createElement(
        'div',
        { className: 'enemy-manager' },
        React.createElement(
          'p',
          { className: 'enemy-manager-title' },
          containerHeader
        ),
        React.createElement('canvas', { id: 'enemy-icon', className: 'enemy-icon', width: ts, height: ts }),
        React.createElement(
          'div',
          { className: 'stat-col' },
          React.createElement(
            'p',
            null,
            React.createElement(
              'span',
              null,
              displayName ? 'Name: ' : null
            ),
            React.createElement(
              'span',
              null,
              displayName
            )
          ),
          React.createElement(
            'p',
            null,
            React.createElement(
              'span',
              null,
              displayType ? 'Type: ' : null
            ),
            React.createElement(
              'span',
              null,
              displayType
            )
          ),
          React.createElement(
            'p',
            null,
            React.createElement(
              'span',
              null,
              displayLevel ? 'Level: ' : null
            ),
            React.createElement(
              'span',
              null,
              displayLevel
            )
          ),
          React.createElement(
            'p',
            { className: 'enemy-health-row' },
            React.createElement(
              'span',
              {
                className: 'enemy-health-row-title',
                style: { width: healthTitleWidth }
              },
              React.createElement(
                'span',
                { className: 'health-text' },
                displayHealth ? 'Health: ' : null
              )
            ),
            React.createElement(
              'span',
              {
                id: 'enemy-health',
                className: 'enemy-health',
                style: { width: healthMaxWidthStyle, border: healthBorder }
              },
              React.createElement(
                'span',
                { className: 'enemy-health-number' },
                displayHealth
              ),
              React.createElement('span', {
                id: 'enemy-health-gauge',
                className: 'enemy-health-gauge',
                style: { width: healthWidth, background: healthColor }
              })
            )
          )
        ),
        enemies
      );
    }
  }]);

  return EnemyManager;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: gameLevel, levels

var GameLevel = function (_React$Component) {
  _inherits(GameLevel, _React$Component);

  function GameLevel(props) {
    _classCallCheck(this, GameLevel);

    var _this = _possibleConstructorReturn(this, (GameLevel.__proto__ || Object.getPrototypeOf(GameLevel)).call(this, props));

    _this.levelNames = {
      '1': 'The Threshold',
      '2': 'Forboding Cave',
      '3': 'Cave of Hopelessness',
      '4': 'Cave of Despair',
      '5': 'Abyss Cave',
      '6': 'Dungeon Entry',
      '7': 'Demon Palisades',
      '8': 'Feeding Dungeon',
      '9': "Death's Doorstep",
      '10': 'The Abyss'
    };
    return _this;
  }

  _createClass(GameLevel, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.gameLevel !== nextProps.gameLevel) return true;

      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var gameLevel = this.props.gameLevel,
          levelName = this.levelNames[gameLevel];


      return React.createElement(
        'div',
        { className: 'level' },
        React.createElement(
          'p',
          { className: 'level-header' },
          'Level ' + gameLevel
        ),
        React.createElement(
          'p',
          { className: 'level-name' },
          levelName
        )
      );
    }
  }]);

  return GameLevel;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: gameOver, gameLevel, gameMuted, levels, levelUpCount, interactItem, useStatPoint,
//exchangeAttacks, enemyDead, overlayMode

var GameSounds = function (_React$Component) {
  _inherits(GameSounds, _React$Component);

  function GameSounds(props) {
    _classCallCheck(this, GameSounds);

    var _this = _possibleConstructorReturn(this, (GameSounds.__proto__ || Object.getPrototypeOf(GameSounds)).call(this, props));

    _this.loadEffects = _this.loadEffects.bind(_this);
    _this.playBackgroundSong = _this.playBackgroundSong.bind(_this);
    _this.toggleMute = _this.toggleMute.bind(_this);
    _this.playEffect = _this.playEffect.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.handleOverlayToggle = _this.handleOverlayToggle.bind(_this);
    _this.handleAttackRound = _this.handleAttackRound.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);

    _this.soundKeys = {
      path: 'sounds/',
      effectKeys: {
        activatePortal: 'activate-portal',
        attackMiss: 'attack-miss',
        attackRound: 'attack-round',
        buySellItem: 'buy-sell-item',
        changeEquipment: 'change-eqipment',
        chooseNewGame: 'choose-new-game',
        closeOverlay: 'close-overlay',
        criticalHit: 'critical-hit',
        enemyDead: 'enemy-dead',
        heroDead: 'hero-dead',
        heroSelection: 'hero-selection',
        levelUp: 'level-up',
        notEnoughGold: 'not-enough-gold',
        openOverlay: 'open-overlay',
        pickupGold: 'pickup-gold',
        pickupItem: 'pickup-item',
        teleportThroughPortal: 'teleport-through-portal',
        usePotion: 'use-potion',
        useStatPoint: 'use-stat-point',
        useTome: 'use-tome'
      },
      effectPre: 'effect-',
      effectPost: '.wav',
      effectType: 'audio/wav',
      musicKeys: {
        'intro': '00-intro',
        'level': '-level',
        'gameOver': '11-game-over',
        'gameWin': '12-game-win'
      },
      musicPre: 'music-',
      musicPost: '.mp3',
      musicType: 'audio/mp3'
    };

    _this.musicOverlays = {
      'hero-selection-overlay': { overlay: 'hero-selection-overlay', pointerKey: 'intro' },
      'game-over-overlay': { overlay: 'game-over-overlay', pointerKey: 'gameOver' },
      'game-win-overlay': { overlay: 'game-win-overlay', pointerKey: 'gameWin' }
    };

    _this.effectOverlays = {
      'inv-overlay': { overlay: 'inv-overlay' },
      'help-overlay': { overlay: 'help-overlay' },
      'merchant-overlay': { overlay: 'merchant-overlay' }
    };

    _this.enemyDeadCount = 0;

    _this.state = {
      song: null,
      songPromise: null,
      effects: {}
    };
    return _this;
  }

  _createClass(GameSounds, [{
    key: 'loadEffects',
    value: function loadEffects() {
      var _soundKeys = this.soundKeys,
          path = _soundKeys.path,
          effectKeys = _soundKeys.effectKeys,
          effectPre = _soundKeys.effectPre,
          effectPost = _soundKeys.effectPost,
          effectType = _soundKeys.effectType;


      var effects = {},
          el = '';

      for (el in effectKeys) {
        effects[el] = new Audio();
        effects[el].src = path + effectPre + effectKeys[el] + effectPost;
        effects[el].type = effectType;
      }

      this.setState({ effects: effects });
    }
  }, {
    key: 'playBackgroundSong',
    value: function playBackgroundSong(gameLevel, overlayMode) {
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props;
      var _soundKeys2 = this.soundKeys,
          path = _soundKeys2.path,
          musicKeys = _soundKeys2.musicKeys,
          musicPre = _soundKeys2.musicPre,
          musicPost = _soundKeys2.musicPost,
          musicType = _soundKeys2.musicType,
          musicOverlays = this.musicOverlays;


      var lastSong = this.state.song,
          lastPromise = this.state.songPromise,
          song = null,
          songPromise = null,
          key = '',
          el = '';

      if (lastPromise) {
        lastPromise.then(function () {
          return lastSong.pause();
        });
      } else if (lastSong) {
        console.log('Stopped Song');
        lastSong.pause();
      }

      var playSong = function handlePlaySong() {
        songPromise;
        if (props.gameMuted) song.muted = true;
      };

      for (el in musicOverlays) {
        if (musicOverlays[el].overlay === overlayMode) {
          key = musicKeys[musicOverlays[el].pointerKey];
        }
      }

      if (!key) key = ('0' + gameLevel).slice(-2) + musicKeys.level;

      song = new Audio();
      song.src = path + musicPre + key + musicPost;
      song.type = musicType;
      song.loop = true;
      song.preload = true;
      songPromise = song.play();
      song.addEventListener('loadeddata', playSong);

      this.setState({ song: song, songPromise: songPromise });
    }
  }, {
    key: 'playEffect',
    value: function playEffect(key) {
      if (!this.props.gameMuted) {
        this.state.effects[key].play().catch(function (e) {
          //console.log('Audio effect play error: ', this.state.effects[key].src);
        });
      }
    }
  }, {
    key: 'toggleMute',
    value: function toggleMute(gameMuted) {
      this.state.song.muted = gameMuted;
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var _props$interactItem = props.interactItem,
          type = _props$interactItem.type,
          item = _props$interactItem.item;


      var key = '';

      if (type === 'buyFail') key = 'notEnoughGold';else if (['buySuccess', 'sell'].includes(type)) key = 'buySellItem';else if (['equip', 'unequip'].includes(type)) key = 'changeEquipment';else if (type === 'pickup') key = item.type === 'gold' ? 'pickupGold' : 'pickupItem';else if (type === 'use') key = item.name.slice(-6) === 'Potion' ? 'usePotion' : 'useTome';

      if (type !== 'buy') this.playEffect(key);
    }
  }, {
    key: 'handleAttackRound',
    value: function handleAttackRound() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var attacks = props.exchangeAttacks.attacks;


      var key = '';

      if (attacks.some(function (a) {
        return a.type === 'critical hit';
      })) key = 'criticalHit';else if (attacks.every(function (a) {
        return a.type === 'miss';
      })) key = 'attackMiss';else key = 'attackRound';

      this.playEffect(key);
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var _props$enemyDead = props.enemyDead,
          source = _props$enemyDead.source,
          count = _props$enemyDead.count,
          portalSoundDelay = 150;


      this.enemyDeadCount = count;

      this.playEffect('enemyDead');

      if (source.boss) setTimeout(function () {
        _this2.playEffect('activatePortal');
      }, portalSoundDelay);
    }
  }, {
    key: 'handleOverlayToggle',
    value: function handleOverlayToggle(nextOverlay) {
      var key = this.effectOverlays[nextOverlay] ? 'openOverlay' : 'closeOverlay';

      this.playEffect(key);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.loadEffects();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.playBackgroundSong(this.props.gameLevel, this.props.overlayMode);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.state.song.pause();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      if (this.props.gameLevel !== nextProps.gameLevel || (this.musicOverlays[this.props.overlayMode] || this.musicOverlays[nextProps.overlayMode]) && this.props.overlayMode !== nextProps.overlayMode) {

        if (nextProps.gameLevel === 1 && nextProps.overlayMode === 'off') {
          this.playEffect('heroSelection');
        }

        this.playBackgroundSong(nextProps.gameLevel, nextProps.overlayMode, nextProps);
      }
      if ((this.effectOverlays[this.props.overlayMode] || this.effectOverlays[nextProps.overlayMode]) && this.props.overlayMode !== nextProps.overlayMode) {

        this.handleOverlayToggle(nextProps.overlayMode);
      }
      if (this.props.gameMuted !== nextProps.gameMuted) {
        this.toggleMute(nextProps.gameMuted);
      }
      if (this.props.levelUpCount !== nextProps.levelUpCount) {
        setTimeout(function () {
          _this3.playEffect('levelUp');
        }, 100);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count) {
        this.handleInteractItem(nextProps);
      }
      if (this.props.useStatPoint.count !== nextProps.useStatPoint.count) {
        this.playEffect('useStatPoint');
      }
      if (this.props.exchangeAttacks.count !== nextProps.exchangeAttacks.count) {
        this.handleAttackRound(nextProps);
      }
      if (nextProps.enemyDead.count !== this.enemyDeadCount) {
        this.handleEnemyDead(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {

      return React.createElement('div', null);
    }
  }]);

  return GameSounds;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, tileSize, floor, gameLevel, levels, hero, playerArr, bgArr, floorCoords,
//updateFloorCoords, itemArr, itemPalettes, updateGameClassState, itemPaletteArrMap
//inventory, interactItem, heroFacing, enemyArr, enemyPalettes, enemyDead, bgLevelProcessed, playerPalettes, toggleMute
var GameStage = function (_React$Component) {
  _inherits(GameStage, _React$Component);

  function GameStage(props) {
    _classCallCheck(this, GameStage);

    var _this = _possibleConstructorReturn(this, (GameStage.__proto__ || Object.getPrototypeOf(GameStage)).call(this, props));

    _this.updateAccArr = _this.updateAccArr.bind(_this);

    _this.state = {
      stageSize: 480,
      accArr: []
    };
    return _this;
  }

  _createClass(GameStage, [{
    key: 'updateAccArr',
    value: function updateAccArr(accArr) {
      this.setState({ accArr: accArr });
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'stage' },
        React.createElement(LayerPlayer, {
          stageSize: this.state.stageSize,
          tileSize: this.props.tileSize,
          hero: this.props.hero,
          heroFacing: this.props.heroFacing,
          playerPalettes: this.props.playerPalettes,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          bgArr: this.props.bgArr,
          playerArr: this.props.playerArr,
          floorCoords: this.props.floorCoords,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(LayerBackground, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          bgArr: this.props.bgArr,
          playerArr: this.props.playerArr,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(LayerAccent, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          accArr: this.state.accArr,
          enemyDead: this.props.enemyDead,
          updateAccArr: this.updateAccArr }),
        React.createElement(LayerItem, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          bgLevelProcessed: this.props.bgLevelProcessed,
          levels: this.props.levels,
          playerArr: this.props.playerArr,
          bgArr: this.props.bgArr,
          floorCoords: this.props.floorCoords,
          itemArr: this.props.itemArr,
          itemPalettes: this.props.itemPalettes,
          itemPaletteArrMap: this.props.itemPaletteArrMap,
          enemyDead: this.props.enemyDead,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(LayerEnemy, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          enemyPalettes: this.props.enemyPalettes,
          updateGameClassState: this.props.updateGameClassState }),
        React.createElement(LayerDistanceFog, {
          stageSize: this.state.stageSize,
          tileSize: this.props.tileSize }),
        React.createElement(LayerExploreFog, {
          stageSize: this.state.stageSize,
          boardSize: this.props.boardSize,
          tileSize: this.props.tileSize,
          gameLevel: this.props.gameLevel,
          playerArr: this.props.playerArr }),
        React.createElement(LayerOverlays, {
          tileSize: this.props.tileSize,
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          playerPalettes: this.props.playerPalettes,
          overlayMode: this.props.overlayMode,
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState })
      );
    }
  }]);

  return GameStage;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameTips = function (_React$Component) {
  _inherits(GameTips, _React$Component);

  function GameTips() {
    _classCallCheck(this, GameTips);

    return _possibleConstructorReturn(this, (GameTips.__proto__ || Object.getPrototypeOf(GameTips)).apply(this, arguments));
  }

  _createClass(GameTips, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'tips' },
        React.createElement(
          'p',
          null,
          'Press \'H\' for help'
        ),
        React.createElement(
          'p',
          null,
          'Press \'Q\' for mute'
        )
      );
    }
  }]);

  return GameTips;
}(React.Component);
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: tileSize, hero, heroIcon, inventory, itemPalettes, interactItem, updateGameClassState
//useStatPoint, increasedStat, enemyAttack, exchangeAttacks, enemyDead, gameOver
var Hero = function (_React$Component) {
  _inherits(Hero, _React$Component);

  function Hero(props) {
    _classCallCheck(this, Hero);

    var _this = _possibleConstructorReturn(this, (Hero.__proto__ || Object.getPrototypeOf(Hero)).call(this, props));

    _this.initHero = _this.initHero.bind(_this);
    _this.changeStats = _this.changeStats.bind(_this);
    _this.handleLevelUp = _this.handleLevelUp.bind(_this);
    _this.paintHeroIcon = _this.paintHeroIcon.bind(_this);
    _this.attemptPurchase = _this.attemptPurchase.bind(_this);
    _this.sellItem = _this.sellItem.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.handleUseStatPoint = _this.handleUseStatPoint.bind(_this);
    _this.updateEquipCanvas = _this.updateEquipCanvas.bind(_this);
    _this.handleBattleRound = _this.handleBattleRound.bind(_this);
    _this.handleHeroDead = _this.handleHeroDead.bind(_this);

    _this.enemyDeadCount = 0;
    _this.heroDead = false;

    _this.state = {
      heroName: '',
      experience: 0,
      expToLevel: 0,
      charLevel: 0,
      gold: 0,
      curHealth: 0,
      bHealth: 0,
      bAttack: 0,
      bDefense: 0,
      bHit: 0,
      bCrit: 0,
      bDodge: 0,
      bVitality: 0,
      bDurability: 0,
      bStrength: 0,
      bAgility: 0,
      statPoints: 0,
      onLevelUp: {},
      head: null,
      weapon: null,
      amulet: null,
      armor: null,
      shield: null,
      glove: null,
      ring: null,
      foot: null,
      iHealth: 0,
      iAttack: 0,
      iDefense: 0,
      iHit: 0,
      iCrit: 0,
      iDodge: 0,
      iVitality: 0,
      iDurability: 0,
      iStrength: 0,
      iAgility: 0,
      bExpToLevel: 100,
      interactItemCount: 0,
      battleRound: 0,
      statIncMessages: []
    };
    return _this;
  }

  _createClass(Hero, [{
    key: "initHero",
    value: function initHero(hero) {
      var char = Object.assign({}, heroTypeStats[hero]),
          bHp = char.health,
          bVit = char.vitality,
          bDur = char.durability,
          conv = statConversion,
          statIncMessages = ["'V'", "'B'", "'N'", "'M'"];

      this.setState({
        statIncMessages: statIncMessages,
        heroName: char.heroName,
        charLevel: 1,
        expToLevel: this.state.bExpToLevel,
        curHealth: bHp + conv.vitToHp * bVit + conv.durToHp * bDur,
        bHealth: bHp,
        bAttack: char.attack,
        bDefense: char.defense,
        bHit: char.hit,
        bCrit: char.crit,
        bDodge: char.dodge,
        bVitality: bVit,
        bDurability: bDur,
        bStrength: char.strength,
        bAgility: char.agility,
        onLevelUp: char.onLevelUp
      });
    }
  }, {
    key: "paintHeroIcon",
    value: function paintHeroIcon(icon) {
      var ctx = document.getElementById('hero-icon').getContext('2d');

      ctx.drawImage(icon, 0, 0);
    }
  }, {
    key: "changeStats",
    value: function changeStats(stats) {
      var decStats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var attr = Object.assign({}, stats),
          decAttr = Object.assign({}, decStats);

      var newState = Object.assign({}, this.state),
          prop = null;

      for (prop in attr) {
        newState[prop] += attr[prop];
      }for (prop in decAttr) {
        newState[prop] -= decAttr[prop];
      }return newState;
    }
  }, {
    key: "handleLevelUp",
    value: function handleLevelUp(experience, gold) {
      var onLvl = this.state.onLevelUp,
          charLevel = this.state.charLevel + 1,
          bHealth = this.state.bHealth + onLvl.health,
          bVitality = this.state.bVitality + onLvl.vitality,
          bDurability = this.state.bDurability + onLvl.durability,
          bStrength = this.state.bStrength + onLvl.strength,
          bAgility = this.state.bAgility + onLvl.agility,
          bAttack = this.state.bAttack + onLvl.attack,
          bDefense = this.state.bDefense + onLvl.defense,
          iHealth = this.state.iHealth,
          iVitality = this.state.iVitality,
          iDurability = this.state.iDurability,
          conv = statConversion,
          maxHealth = bHealth + iHealth + conv.vitToHp * (bVitality + iVitality) + conv.durToHp * (bDurability + iDurability),
          statPoints = this.state.statPoints + conv.lvlUpSkillPoints;

      var expToLevel = this.state.expToLevel;


      experience -= expToLevel;
      expToLevel = ~~(expToLevel * conv.expLevelMult);

      this.props.updateGameClassState({ levelUpCount: charLevel });

      this.setState({
        gold: gold,
        charLevel: charLevel,
        experience: experience,
        expToLevel: expToLevel,
        bHealth: bHealth,
        bAttack: bAttack,
        bDefense: bDefense,
        bVitality: bVitality,
        bDurability: bDurability,
        bStrength: bStrength,
        bAgility: bAgility,
        statPoints: statPoints,
        curHealth: maxHealth
      });
    }
  }, {
    key: "attemptPurchase",
    value: function attemptPurchase(item, inventory, merchantInventory, interactItem) {
      var buySuccessType = 'buySuccess',
          buyFailType = 'buyFail';

      var gold = this.state.gold,
          nInteractItem = Object.assign({}, interactItem),
          nState = {};


      if (gold >= item.buy) {
        nInteractItem.type = buySuccessType;
        gold -= item.buy;
        merchantInventory[item.name].count -= 1;

        if (inventory[item.name]) {
          inventory[item.name].count += 1;
        } else {
          inventory[item.name] = Object.assign({}, item);
          inventory[item.name].count = 1;
        }
        nState = { inventory: inventory };
        this.setState({ gold: gold });
      } else {
        nInteractItem.type = buyFailType;
      }

      nInteractItem.count += 1;
      nState['interactItem'] = nInteractItem;

      this.props.updateGameClassState(nState);
    }
  }, {
    key: "sellItem",
    value: function sellItem(item, inventory, merchantInventory, interactItem) {
      var gold = this.state.gold,
          nState = { gold: gold + item.sell };


      if (item.equipped) {
        inventory[item.name].equipped = false;
        nState[item.type] = null;
      }

      inventory[item.name].count -= 1;

      if (merchantInventory[item.name]) {
        merchantInventory[item.name].count += 1;
      } else {
        merchantInventory[item.name] = Object.assign({}, item);
        merchantInventory[item.name].count = 1;
      }

      if (inventory[item.name].count === 0 && inventory[item.name].type !== 'consumable') {
        this.updateEquipCanvas(inventory[item.name]);
      }

      this.setState(nState);
      this.props.updateGameClassState({ inventory: inventory });
    }
  }, {
    key: "handleEnemyDead",
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead;
      var _state = this.state,
          experience = _state.experience,
          expToLevel = _state.expToLevel,
          gold = _state.gold;


      experience += enemyDead.experience;
      gold += enemyDead.gold;
      this.enemyDeadCount = enemyDead.count;

      if (experience >= expToLevel) this.handleLevelUp(experience, gold);else this.setState({ experience: experience, gold: gold });
    }
  }, {
    key: "handleInteractItem",
    value: function handleInteractItem(nextProps) {
      var interactItem = nextProps.interactItem,
          action = interactItem.type,
          itemName = interactItem.item.name,
          conv = statConversion;


      var inventory = Object.assign({}, nextProps.inventory),
          merchantInventory = interactItem.source.inventory,
          item = action === 'buy' ? merchantInventory[itemName] : inventory[itemName],
          stats = item.stats,
          iType = item.type,
          updateInventory = false,
          updateCanvas = false,
          curItem = null,
          nState = {},
          maxHp = 0,
          hp = 0,
          vit = 0,
          dur = 0;

      if (action === 'pickup' && item.type === 'gold') nState = this.changeStats(stats);else if (action === 'use') {
        updateInventory = true;
        item.count -= 1;

        nState = this.changeStats(stats);
      } else if (action === 'unequip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];
        inventory[curItem.name].equipped = false;

        nState = this.changeStats({}, curItem.stats);
        nState[iType] = null;
      } else if (action === 'equip') {
        updateInventory = true;
        updateCanvas = true;
        curItem = this.state[iType];

        if (curItem) {
          inventory[curItem.name].equipped = false;
          nState = this.changeStats(stats, curItem.stats);
        } else nState = this.changeStats(stats);

        item.equipped = true;
        nState[iType] = item;
      } else if (action === 'buy') {
        this.attemptPurchase(item, inventory, merchantInventory, interactItem);
      } else if (action === 'sell') {
        this.sellItem(item, inventory, merchantInventory, interactItem);
      }

      if (Object.keys(nState).length) {
        hp = nState.bHealth + nState.iHealth;
        vit = nState.iVitality + nState.bVitality;
        dur = nState.iDurability + nState.bDurability;
        maxHp = hp + conv.vitToHp * vit + conv.durToHp * dur;

        if (nState.curHealth > maxHp) nState.curHealth = maxHp;
        if (updateCanvas) this.updateEquipCanvas(item);
        if (updateInventory) this.props.updateGameClassState({ inventory: inventory });

        this.setState(nState);
      }
    }
  }, {
    key: "handleUseStatPoint",
    value: function handleUseStatPoint(nextProps) {
      var decStats = { statPoints: 1 };

      var increasedStat = Object.assign({}, nextProps.increasedStat),
          stats = {},
          nState = {};

      if (this.state.statPoints > 0) {
        stats[nextProps.useStatPoint.stat] = 1;
        nState = this.changeStats(stats, decStats);

        increasedStat.count++;
        increasedStat.type = 'Increased';
        increasedStat.stat = nextProps.useStatPoint.stat.slice(1);
        increasedStat.quant = 1;

        this.props.updateGameClassState({ increasedStat: increasedStat });
        this.setState(nState);
      }
    }
  }, {
    key: "updateEquipCanvas",
    value: function updateEquipCanvas(item) {
      var palette = this.props.itemPalettes[item.palette],
          loc = item.iconLoc;

      var dCtx = getById(item.type + '-canvas').getContext('2d');

      dCtx.clearRect(0, 0, loc[2], loc[3]);

      if (item.equipped) {
        dCtx.drawImage(palette, loc[0], loc[1], loc[2], loc[3], 0, 0, loc[2], loc[3]);
      }
    }
  }, {
    key: "handleBattleRound",
    value: function handleBattleRound(nextProps) {
      var enemyAttack = nextProps.enemyAttack,
          eStats = enemyAttack.stats,
          roundCount = enemyAttack.roundCount,
          conv = statConversion,
          hDur = this.state.bDurability + this.state.iDurability,
          hStr = this.state.bStrength + this.state.iStrength,
          hAgi = this.state.bAgility + this.state.iAgility,
          hAtk = this.state.bAttack + this.state.iAttack + conv.strToAtk * hStr,
          hDef = this.state.bDefense + this.state.iDefense + conv.durToDef * hDur + conv.strToDef * hStr,
          hHit = this.state.bHit + this.state.iHit + conv.strToHit * hStr + conv.agiToHit * hAgi,
          hCrit = this.state.bCrit + this.state.iCrit + conv.agiToCrit * hAgi,
          hDodge = this.state.bDodge + this.state.iDodge + conv.durToDodge * hDur + conv.agiToDodge * hAgi,
          eDur = eStats.bDurability,
          eStr = eStats.bStrength,
          eAgi = eStats.bAgility,
          eAtk = eStats.bAttack + conv.strToAtk * eStr,
          eDef = eStats.bDefense + conv.durToDef * eDur + conv.strToDef * eStr,
          eHit = eStats.bHit + conv.strToHit * eStr + conv.agiToHit * eAgi,
          eCrit = eStats.bCrit + conv.agiToCrit * eAgi,
          eDodge = eStats.bDodge + conv.durToDodge * eDur + conv.agiToDodge * eAgi;
      var exchangeAttacks = Object.assign({}, nextProps.exchangeAttacks),
          _state2 = this.state,
          curHealth = _state2.curHealth,
          battleRound = _state2.battleRound,
          spawnIndex = enemyAttack.spawnIndex,
          enemyHealth = eStats.curHealth,
          attacks = [],
          turn = {},
          enemyFirst = false,
          type = '',
          attack = 0,
          defense = 0,
          damage = 0,
          i = 0;


      if (roundCount !== battleRound) {
        if (randInt(0, 100) < hHit - eDodge) {
          for (i = 0; i < hAtk; i++) {
            attack += randInt(conv.atkToHpRange[0], conv.atkToHpRange[1]);
          }for (i = 0; i < eDef; i++) {
            defense += randInt(conv.defToHpRange[0], conv.defToHpRange[1]);
          }damage = attack - defense > 0 ? attack - defense : 0;

          if (randInt(0, 100) < hCrit) type = 'critical hit', damage *= 2;else type = 'hit';

          turn = { type: type, damage: damage, from: 'hero', to: enemyAttack.source.name };
        } else {
          spawnIndex = -1;
          turn = { from: 'hero', to: enemyAttack.source.name, type: 'miss', damage: 0 };
        }
        attacks.push(turn);
      }

      if (!(attacks.length && eAgi <= hAgi && attacks[0].damage >= enemyHealth)) {
        if (randInt(0, 100) < eHit - hDodge) {
          attack = 0, defense = 0;

          for (i = 0; i < eAtk; i++) {
            attack += randInt(conv.atkToHpRange[0], conv.atkToHpRange[1]);
          }for (i = 0; i < hDef; i++) {
            defense += randInt(conv.defToHpRange[0], conv.defToHpRange[1]);
          }damage = attack - defense > 0 ? attack - defense : 0;

          if (randInt(0, 100) < eCrit) type = 'critical hit', damage *= 2;else type = 'hit';

          turn = { type: type, damage: damage, from: enemyAttack.source.name, to: 'hero' };
        } else {
          damage = 0;
          turn = { damage: damage, from: enemyAttack.source.name, to: 'hero', type: 'miss' };
        }
        curHealth -= turn.damage;

        if (eAgi <= hAgi) attacks.push(turn);else enemyFirst = true, attacks.unshift(turn);
      }

      if (enemyFirst && curHealth <= 0 && attacks.length === 2) {
        attacks.length = 1;
        spawnIndex = -1;
      }

      if (battleRound < roundCount) battleRound = roundCount;
      exchangeAttacks.count++;
      exchangeAttacks.spawnIndex = spawnIndex;
      exchangeAttacks.attacks = attacks;

      this.setState({ curHealth: curHealth, battleRound: battleRound });
      nextProps.updateGameClassState({ exchangeAttacks: exchangeAttacks });
    }
  }, {
    key: "handleHeroDead",
    value: function handleHeroDead() {
      this.heroDead = true;
      this.props.updateGameClassState({ gameOver: true, overlayMode: 'game-over-overlay' });
      console.log('GAME OVER');
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (this.state.heroName === '' && nextProps.hero) {
        this.initHero(nextProps.hero);
      }
      if (this.props.interactItem.count !== nextProps.interactItem.count && nextProps.interactItem.count) {

        this.handleInteractItem(nextProps);
      }
      if (this.props.enemyAttack.count !== nextProps.enemyAttack.count) {
        this.handleBattleRound(nextProps);
      }
      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
      if (this.props.useStatPoint.count !== nextProps.useStatPoint.count) {
        this.handleUseStatPoint(nextProps);
      }
    }
  }, {
    key: "componentWillUpdate",
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.props.heroIcon !== nextProps.heroIcon && nextProps.heroIcon) {
        this.paintHeroIcon(nextProps.heroIcon);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.state.curHealth <= 0 && !this.heroDead && this.state.heroName) {
        this.handleHeroDead();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var ts = this.props.tileSize,
          none = 'None',
          statIncMessages = this.state.statIncMessages,
          conv = statConversion,
          lvl = this.state.charLevel,
          curHp = this.state.curHealth,
          gold = this.state.gold,
          stat = this.state.statPoints,
          exp = this.state.experience,
          expToLvl = this.state.expToLevel,
          vit = this.state.bVitality + this.state.iVitality,
          dur = this.state.bDurability + this.state.iDurability,
          str = this.state.bStrength + this.state.iStrength,
          agi = this.state.bAgility + this.state.iAgility,
          atk = this.state.bAttack + this.state.iAttack + conv.strToAtk * str,
          def = this.state.bDefense + this.state.iDefense + conv.durToDef * dur + conv.strToDef * str,
          maxHp = this.state.bHealth + this.state.iHealth + conv.vitToHp * vit + conv.durToHp * dur,
          statIcon = stat ? 'stat-icon icon-plus-squared' : '',
          hed = this.state.head ? this.state.head.name : none,
          wep = this.state.weapon ? this.state.weapon.name : none,
          amu = this.state.amulet ? this.state.amulet.name : none,
          bod = this.state.armor ? this.state.armor.name : none,
          shd = this.state.shield ? this.state.shield.name : none,
          glv = this.state.glove ? this.state.glove.name : none,
          rng = this.state.ring ? this.state.ring.name : none,
          ft = this.state.foot ? this.state.foot.name : none,
          healthMaxWidth = 9,
          expMaxWidth = 11.2;

      var healthMaxWidthStyle = '',
          gaugeBorder = 'none',
          hPercent = 0,
          healthWidthStyle = '',
          healthColor = 'none',
          expMaxWidthStyle = '',
          ePercent = 0,
          expWidthStyle = '',
          expColor = 'none';

      if (maxHp) {
        healthMaxWidthStyle = healthMaxWidth + 'em';
        gaugeBorder = '1px solid #000';
        hPercent = ~~(curHp / maxHp * 100), healthWidthStyle = hPercent + '%';
        healthColor = hPercent > 70 ? 'rgba(0,255,0,.8)' : hPercent > 30 ? 'rgba(255,255,0,.8)' : 'rgba(255,0,0,.7)';
        expMaxWidthStyle = expMaxWidth + 'em';
        ePercent = ~~(exp / expToLvl * 100);
        expWidthStyle = ePercent + '%';
        expColor = 'rgba(0,164,255,.6)';
      }

      return React.createElement(
        "div",
        { className: "hero" },
        React.createElement(
          "p",
          { className: "hero-heading" },
          "Character Info"
        ),
        React.createElement(
          "div",
          { className: "hero-type" },
          React.createElement("canvas", { id: "hero-icon", className: "hero-icon", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Name: ",
              this.state.heroName
            ),
            React.createElement(
              "p",
              null,
              "Type: ",
              this.props.hero
            )
          )
        ),
        React.createElement(
          "div",
          { className: "stat-container" },
          React.createElement(
            "p",
            { className: "stat-row" },
            "Level: ",
            lvl
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Health: ",
            React.createElement(
              "span",
              {
                className: "hero-health",
                style: { width: healthMaxWidthStyle, border: gaugeBorder }
              },
              React.createElement("span", {
                className: "hero-health-gauge",
                style: { width: healthWidthStyle, background: healthColor }
              }),
              React.createElement(
                "span",
                {
                  className: "hero-health-number"
                },
                curHp,
                "/",
                maxHp
              )
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Exp: ",
            React.createElement(
              "span",
              {
                className: "hero-experience",
                style: { width: expMaxWidthStyle, border: gaugeBorder }
              },
              React.createElement("span", {
                className: "hero-experience-gauge",
                style: { width: expWidthStyle, background: expColor }
              }),
              React.createElement(
                "span",
                {
                  className: "hero-experience-number"
                },
                exp,
                "/",
                expToLvl
              )
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Gold: ",
            gold
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Stat: ",
            stat
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Atk: ",
            atk
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Def: ",
            def
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Vit: ",
            React.createElement(
              "span",
              { className: "changeable-stat" },
              vit
            ),
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[0] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Dur: ",
            React.createElement(
              "span",
              { className: "changeable-stat" },
              dur
            ),
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[1] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Str: ",
            React.createElement(
              "span",
              { className: "changeable-stat" },
              str
            ),
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[2] : null
            )
          ),
          React.createElement(
            "p",
            { className: "stat-row" },
            "Agi: ",
            React.createElement(
              "span",
              { className: "changeable-stat" },
              agi
            ),
            React.createElement("i", { className: statIcon }),
            React.createElement(
              "span",
              { className: "stat-note" },
              stat ? statIncMessages[3] : null
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "head-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Head"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              hed
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "weapon-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Weapon"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              wep
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "amulet-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Amulet"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              amu
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "armor-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Armor"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              bod
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "shield-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Shield"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              shd
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "glove-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Glove"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              glv
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "ring-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Ring"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              rng
            )
          )
        ),
        React.createElement(
          "div",
          { className: "equip-row" },
          React.createElement("canvas", { id: "foot-canvas", className: "equip-canv", width: ts, height: ts }),
          React.createElement(
            "div",
            { className: "stat-col" },
            React.createElement(
              "p",
              null,
              "Foot"
            ),
            React.createElement(
              "p",
              { className: "equip-name" },
              ft
            )
          )
        )
      );
    }
  }]);

  return Hero;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//stageSize, boardSize, tileSize, gameLevel, playerArr, bgArr, accArr, updateAccArr, enemyDead, bgLevelProcessed
var LayerAccent = function (_React$Component) {
  _inherits(LayerAccent, _React$Component);

  function LayerAccent(props) {
    _classCallCheck(this, LayerAccent);

    var _this = _possibleConstructorReturn(this, (LayerAccent.__proto__ || Object.getPrototypeOf(LayerAccent)).call(this, props));

    _this.initAccArr = _this.initAccArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getAccImages = _this.getAccImages.bind(_this);
    _this.initAccPalettes = _this.initAccPalettes.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setLevelPalettes = _this.setLevelPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setAccArr = _this.setAccArr.bind(_this);
    _this.handleEnemyDead = _this.handleEnemyDead.bind(_this);
    _this.drawAccents = _this.drawAccents.bind(_this);

    _this.enemyDeadCount = 0;
    _this.lastRenderFrame = 0;
    _this.lastPlayerArr = [];

    _this.state = {
      srcTileSize: 16,
      wallAcc: 20,
      flrAcc: 40,
      decor0: null,
      decor1: null,
      ground0: null,
      ground1: null,
      ore0: null,
      ore1: null,
      dec0Canv: null,
      dec1Canv: null,
      grnd0Canv: null,
      grnd1Canv: null,
      ore0CanvPalette: null,
      ore1CanvPalette: null,
      ore0Canv: null,
      ore1Canv: null,
      decorMap: {},
      groundMap: {},
      oreMap: {},
      corpseMap: '',
      paletteArrMap: {},
      tempCanv: null,
      renderArr: []
    };
    return _this;
  }

  _createClass(LayerAccent, [{
    key: 'initAccArr',
    value: function initAccArr() {
      var len = this.props.boardSize,
          accArr = initZeroArray(len);

      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'getAccImages',
    value: function getAccImages() {
      var decor0 = new Image(),
          decor1 = new Image(),
          ground0 = new Image(),
          ground1 = new Image(),
          ore0 = new Image(),
          ore1 = new Image(),
          that = this;

      var i = 0;

      var handleAccLoad = function handleAccImageLoad() {
        i++;
        if (i === 6) {
          that.setState({ decor0: decor0, decor1: decor1, ground0: ground0, ground1: ground1, ore0: ore0, ore1: ore1 });
          that.initAccPalettes(decor0, decor1, ground0, ground1, ore0, ore1);
        }
      };

      decor0.src = 'img/accents/Decor0.png';
      decor1.src = 'img/accents/Decor1.png';
      ground0.src = 'img/accents/Ground0.png';
      ground1.src = 'img/accents/Ground1.png';
      ore0.src = 'img/accents/Ore0.png';
      ore1.src = 'img/accents/Ore1.png';

      decor0.addEventListener('load', handleAccLoad);
      decor1.addEventListener('load', handleAccLoad);
      ground0.addEventListener('load', handleAccLoad);
      ground1.addEventListener('load', handleAccLoad);
      ore0.addEventListener('load', handleAccLoad);
      ore1.addEventListener('load', handleAccLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          rLen = stageSize / tileSize,
          smoothRender = false,
          tempCanv = initMemCanvas(stageSize, stageSize, smoothRender);


      var renderArr = initZeroArray(rLen);

      this.setState({ tempCanv: tempCanv, renderArr: renderArr });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var decorMap = {},
          groundMap = {},
          oreMap = {},
          corpseMap = '',
          w = 0,
          h = 0,
          i = 0,
          j = 0;

      //init decorMap
      w = 8;
      h = 19;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          decorMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init groundMap
      w = 8;
      h = 7;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          groundMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init oreMap
      w = 3;
      h = 2;
      for (i = 0; i < h; i++) {
        for (j = 0; j < w; j++) {
          oreMap['' + (w * i + j)] = [ts * j, ts * i];
        }
      }

      //init corpseMap
      corpseMap = '51';

      this.setPaletteArrMap(this.props.gameLevel, decorMap, groundMap, oreMap);
      this.setState({ decorMap: decorMap, groundMap: groundMap, oreMap: oreMap, corpseMap: corpseMap });
    }
  }, {
    key: 'initAccPalettes',
    value: function initAccPalettes(decor0, decor1, ground0, ground1, ore0, ore1) {
      var gmTS = this.props.tileSize,
          srcTS = this.state.srcTileSize,
          scale = gmTS / srcTS,
          dH = 19 * gmTS,
          dW = 8 * gmTS,
          gH = 7 * gmTS,
          gW = 8 * gmTS,
          oPalH = 6 * gmTS,
          oPalW = 10 * gmTS,
          oH = 2 * gmTS,
          oW = 3 * gmTS;

      var dec0Canv = document.createElement('canvas'),
          dec0Ctx = dec0Canv.getContext('2d'),
          dec1Canv = document.createElement('canvas'),
          dec1Ctx = dec1Canv.getContext('2d'),
          grnd0Canv = document.createElement('canvas'),
          grnd0Ctx = grnd0Canv.getContext('2d'),
          grnd1Canv = document.createElement('canvas'),
          grnd1Ctx = grnd1Canv.getContext('2d'),
          ore0CanvPalette = document.createElement('canvas'),
          ore0PaletteCtx = ore0CanvPalette.getContext('2d'),
          ore1CanvPalette = document.createElement('canvas'),
          ore1PaletteCtx = ore1CanvPalette.getContext('2d'),
          ore0Canv = document.createElement('canvas'),
          ore0Ctx = ore0Canv.getContext('2d'),
          ore1Canv = document.createElement('canvas'),
          ore1Ctx = ore1Canv.getContext('2d'),
          srcX = 0,
          srcY = 0;

      //set decor
      srcY = 2 * srcTS;
      dec0Canv.width = dW;
      dec0Canv.height = dH;
      dec1Canv.width = dW;
      dec1Canv.height = dH;
      dec0Ctx.imageSmoothingEnabled = false;
      dec1Ctx.imageSmoothingEnabled = false;
      dec0Ctx.drawImage(decor0, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);
      dec1Ctx.drawImage(decor1, 0, srcY, dW / scale, dH / scale, 0, 0, dW, dH);

      //set ground
      srcY = 0;
      grnd0Canv.width = gW;
      grnd0Canv.height = gH;
      grnd1Canv.width = gW;
      grnd1Canv.height = gH;
      grnd0Ctx.imageSmoothingEnabled = false;
      grnd1Ctx.imageSmoothingEnabled = false;
      grnd0Ctx.drawImage(ground0, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);
      grnd1Ctx.drawImage(ground1, 0, srcY, gW / scale, gH / scale, 0, 0, gW, gH);

      //set ore
      srcY = srcTS;
      ore0CanvPalette.width = oPalW;
      ore0CanvPalette.height = oPalH;
      ore1CanvPalette.width = oPalW;
      ore1CanvPalette.height = oPalH;
      ore0CanvPalette.imageSmoothingEnabled = false;
      ore1CanvPalette.imageSmoothingEnabled = false;
      ore0PaletteCtx.drawImage(ore0, srcX, srcY, oPalW / scale, oPalH / scale, 0, 0, oPalW, oPalH);
      ore1PaletteCtx.drawImage(ore1, srcX, srcY, oPalW / scale, oPalH / scale, 0, 0, oPalW, oPalH);

      srcX = 0;
      srcY = 4 * gmTS;
      ore0Canv.width = oW;
      ore0Canv.height = oH;
      ore1Canv.width = oW;
      ore1Canv.height = oH;
      ore0Ctx.imageSmoothingEnabled = false;
      ore1Ctx.imageSmoothingEnabled = false;
      ore0Ctx.drawImage(ore0CanvPalette, srcX, srcY, oW, oH, 0, 0, oW, oH);
      ore1Ctx.drawImage(ore1CanvPalette, srcX, srcY, oW, oH, 0, 0, oW, oH);

      this.setState({
        dec0Canv: dec0Canv,
        dec1Canv: dec1Canv,
        grnd0Canv: grnd0Canv,
        grnd1Canv: grnd1Canv,
        ore0CanvPalette: ore0CanvPalette,
        ore1CanvPalette: ore1CanvPalette,
        ore0Canv: ore0Canv,
        ore1Canv: ore1Canv
      });
    }
  }, {
    key: 'setLevelPalettes',
    value: function setLevelPalettes() {
      var gameLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.gameLevel;
      var _state = this.state,
          ore0CanvPalette = _state.ore0CanvPalette,
          ore1CanvPalette = _state.ore1CanvPalette,
          ore0Canv = _state.ore0Canv,
          ore1Canv = _state.ore1Canv,
          tileSize = this.props.tileSize,
          oreW = ore0Canv.width,
          oreH = ore0Canv.height,
          srcX = gameLevel === 10 ? 5 * tileSize : 0,
          srcY = gameLevel === 1 ? 4 * tileSize : gameLevel === 2 ? 2 * tileSize : gameLevel === 3 ? tileSize : 0;


      var ore0Ctx = ore0Canv.getContext('2d'),
          ore1Ctx = ore1Canv.getContext('2d');

      ore0Ctx.drawImage(ore0CanvPalette, srcX, srcY, oreW, oreH, 0, 0, oreW, oreH);
      ore1Ctx.drawImage(ore1CanvPalette, srcX, srcY, oreW, oreH, 0, 0, oreW, oreH);

      this.setState({ ore0Canv: ore0Canv, ore1Canv: ore1Canv });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap(lvl, decorMap, groundMap, oreMap) {
      decorMap = decorMap || this.state.decorMap;
      groundMap = groundMap || this.state.groundMap;
      oreMap = oreMap || this.state.oreMap;

      var paletteArrMap = {};

      if (lvl && lvl < 5) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['4'], 'decor'],
          '22': [oreMap['0'], 'ore'],
          '23': [oreMap['3'], 'ore'],
          //rWall
          '24': [decorMap['7'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [oreMap['2'], 'ore'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['5'], 'decor'],
          '42': [decorMap['14'], 'decor'],
          '43': [decorMap['15'], 'decor'],
          '44': [groundMap['0'], 'ground'],
          '45': [decorMap['80'], 'decor'],
          '46': [decorMap['81'], 'decor'],
          '47': [decorMap['88'], 'decor'],
          '48': [decorMap['89'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl < 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['48'], 'decor'],
          '23': [decorMap['49'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [decorMap['2'], 'decor'],
          '26': [decorMap['7'], 'decor'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [decorMap['3'], 'decor'],
          '29': [decorMap['3'], 'decor'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['72'], 'decor'],
          '43': [decorMap['74'], 'decor'],
          '44': [decorMap['76'], 'decor'],
          '45': [decorMap['82'], 'decor'],
          '46': [decorMap['83'], 'decor'],
          '47': [decorMap['90'], 'decor'],
          '48': [decorMap['91'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      } else if (lvl === 10) {
        paletteArrMap = {
          //tWall
          '21': [decorMap['0'], 'decor'],
          '22': [decorMap['53'], 'decor'],
          '23': [decorMap['55'], 'decor'],
          //rWall
          '24': [decorMap['2'], 'decor'],
          '25': [oreMap['1'], 'ore'],
          '26': [oreMap['4'], 'ore'],
          //lWall
          '27': [decorMap['3'], 'decor'],
          '28': [oreMap['2'], 'ore'],
          '29': [oreMap['5'], 'ore'],
          //ground
          '41': [decorMap['1'], 'decor'],
          '42': [decorMap['70'], 'decor'],
          '43': [decorMap['71'], 'decor'],
          '44': [decorMap['72'], 'decor'],
          '45': [decorMap['84'], 'decor'],
          '46': [decorMap['85'], 'decor'],
          '47': [decorMap['92'], 'decor'],
          '48': [decorMap['93'], 'decor'],
          '49': [groundMap['40'], 'ground'],
          '51': [groundMap['48'], 'ground']
        };
      }
      this.setState({ paletteArrMap: paletteArrMap });
    }
  }, {
    key: 'setAccArr',
    value: function setAccArr(nextProps) {
      var bgArr = nextProps.bgArr,
          flr = this.state.flrAcc,
          wall = this.state.wallAcc,
          len = bgArr.length;

      var accArr = [].concat(_toConsumableArray(nextProps.accArr)),
          nArr = [0, 0, 0, 0, 0, 0, 0, 0],
          el = 0,
          n = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          n = bgArr[i][j];
          el = 0;

          if (n > wall) {
            nArr[0] = bgArr[i - 1][j - 1];
            nArr[1] = bgArr[i - 1][j];
            nArr[2] = bgArr[i - 1][j + 1];
            nArr[3] = bgArr[i][j - 1];
            nArr[4] = bgArr[i][j + 1];
            nArr[5] = bgArr[i + 1][j - 1];
            nArr[6] = bgArr[i + 1][j];
            nArr[7] = bgArr[i + 1][j + 1];

            if ([22, 25, 27, 35].includes(n) && nArr[6] > flr) {
              //tWall accents
              if (randInt(1, 12) === 5) el = randInt(21, 23);
            }
            if ([21, 24, 25, 32].includes(n) && nArr[3] > flr) {
              //rWall accents
              if (randInt(1, 15) === 5) el = randInt(24, 26);
            }
            if ([23, 24, 27, 34].includes(n) && nArr[4] > flr) {
              //lWall accents
              if (randInt(1, 15) === 5) el = randInt(27, 29);
            }
            if (n > flr) {
              //ground accents
              if (randInt(1, 50) === 7) el = randInt(41, 49);
            }
          }
          accArr[i][j] = el;
          j++;
        }
        j = 0;
        i++;
      }
      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'handleEnemyDead',
    value: function handleEnemyDead(nextProps) {
      var enemyDead = nextProps.enemyDead,
          corpseMap = this.state.corpseMap,
          coord = enemyDead.coord;


      var accArr = [].concat(_toConsumableArray(nextProps.accArr));

      accArr[coord[0]][coord[1]] = corpseMap;
      this.enemyDeadCount = enemyDead.count;

      this.props.updateAccArr(accArr);
    }
  }, {
    key: 'drawAccents',
    value: function drawAccents(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var playerArr = this.props.playerArr,
          frame = (timestamp - timeRef) % 1000 * .06 > 29 ? 1 : 0;


      var lastArr = this.lastPlayerArr,
          lastFrame = this.lastRenderFrame;

      if (playerArr[0] !== lastArr[0] || playerArr[1] !== lastArr[1] || lastFrame !== frame) {
        this.lastPlayerArr = playerArr.slice(0);
        this.lastRenderFrame = frame;

        var _props2 = this.props,
            tileSize = _props2.tileSize,
            stageSize = _props2.stageSize,
            accArr = _props2.accArr,
            paletteArrMap = this.state.paletteArrMap,
            _state2 = this.state,
            dec0Canv = _state2.dec0Canv,
            dec1Canv = _state2.dec1Canv,
            grnd0Canv = _state2.grnd0Canv,
            grnd1Canv = _state2.grnd1Canv,
            ore0Canv = _state2.ore0Canv,
            ore1Canv = _state2.ore1Canv,
            rLen = stageSize / tileSize,
            accLen = accArr.length;
        var renderArr = this.state.renderArr,
            dCtx = document.getElementById('acc-layer').getContext('2d'),
            tempCanv = this.state.tempCanv,
            tempCtx = tempCanv.getContext('2d'),
            img = null,
            m = undefined,
            srcX = 0,
            srcY = 0,
            dX = 0,
            dY = 0,
            el = 0,
            i = 0,
            j = 0;

        var _calcRenderPadding = calcRenderPadding(playerArr, accLen, rLen, tileSize),
            startRow = _calcRenderPadding.startRow,
            startCol = _calcRenderPadding.startCol,
            renderArrHeight = _calcRenderPadding.renderArrHeight,
            renderArrWidth = _calcRenderPadding.renderArrWidth,
            sX = _calcRenderPadding.sX,
            sY = _calcRenderPadding.sY;

        while (i < renderArrHeight) {
          while (j < renderArrWidth) {
            renderArr[i][j] = accArr[startRow + i][startCol + j], j++;
          }
          j = 0, i++;
        }

        tempCtx.clearRect(0, 0, stageSize, stageSize);

        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            el = renderArr[i][j];
            if (el) {
              m = paletteArrMap['' + el];

              if (frame === 1) {
                if (m[1] === 'decor') img = dec0Canv;else if (m[1] === 'ore') img = ore0Canv;else img = grnd0Canv;
              } else {
                if (m[1] === 'decor') img = dec1Canv;else if (m[1] === 'ore') img = ore1Canv;else img = grnd1Canv;
              }

              srcX = m[0][0];
              srcY = m[0][1];
              dX = sX + j * tileSize;
              dY = sY + i * tileSize;

              tempCtx.drawImage(img, srcX, srcY, tileSize, tileSize, dX, dY, tileSize, tileSize);
            }
          }
        }

        dCtx.clearRect(0, 0, stageSize, stageSize);
        dCtx.drawImage(tempCanv, 0, 0, stageSize, stageSize);
      }
      window.requestAnimationFrame(this.drawAccents);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getAccImages();
      this.initAccArr();
      this.initTempCanvas();
      this.initPaletteMaps();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.setPaletteArrMap(nextProps.gameLevel);
        if (this.state.decor0) {
          this.setLevelPalettes(nextProps.gameLevel);
        }
      }
      if (this.props.bgLevelProcessed !== nextProps.bgLevelProcessed) {
        this.setAccArr(nextProps);
      }

      if (this.enemyDeadCount !== nextProps.enemyDead.count) {
        this.handleEnemyDead(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!this.state.dec0Canv && nextState.dec0Canv) return true;else return false;
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevState.dec0Canv !== this.state.dec0Canv) {
        window.requestAnimationFrame(this.drawAccents);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawAccents);
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'acc-layer',
        className: 'acc-layer',
        width: size,
        height: size });
    }
  }]);

  return LayerAccent;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, boardSize, tileSize, gameLevel, bgArr, playerArr,
//bgLevelProcessed, updateGameClassState
var LayerBackground = function (_React$Component) {
  _inherits(LayerBackground, _React$Component);

  function LayerBackground(props) {
    _classCallCheck(this, LayerBackground);

    var _this = _possibleConstructorReturn(this, (LayerBackground.__proto__ || Object.getPrototypeOf(LayerBackground)).call(this, props));

    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getBgImages = _this.getBgImages.bind(_this);
    _this.initPaletteMaps = _this.initPaletteMaps.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.drawBackground = _this.drawBackground.bind(_this);

    _this.lastPlayerArr = [];

    _this.state = {
      srcTileSize: 16,
      floorImg: null,
      wallImg: null,
      floorPalette: {},
      wallPalette: {},
      floorPaletteMap: {},
      wallPaletteMap: {},
      tempCanv: null,
      renderArr: [],
      playerLoc: []
    };
    return _this;
  }

  _createClass(LayerBackground, [{
    key: 'getBgImages',
    value: function getBgImages() {
      var floorImg = new Image(),
          wallImg = new Image(),
          that = this;

      var i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 2) {
          that.setState({ floorImg: floorImg, wallImg: wallImg });

          that.setPalettes(floorImg, wallImg, that.props.gameLevel);
        }
      };

      floorImg.src = 'img/terrain/Floor.png';
      wallImg.src = 'img/terrain/Wall.png';
      floorImg.addEventListener('load', handleLoad);
      wallImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          rLen = stageSize / tileSize,
          smoothRender = false,
          tempCanv = initMemCanvas(stageSize, stageSize, smoothRender);


      var renderArr = [],
          i = 0;

      renderArr.length = rLen;

      while (i < rLen) {
        renderArr[i] = initZeroArray(rLen), i++;
      }this.setState({ tempCanv: tempCanv, renderArr: renderArr });
    }
  }, {
    key: 'initPaletteMaps',
    value: function initPaletteMaps() {
      var ts = this.props.tileSize;

      var floorPaletteMap = {
        '41': [0, 0],
        '42': [ts, 0],
        '43': [2 * ts, 0],
        '44': [0, ts],
        '45': [ts, ts],
        '46': [2 * ts, ts],
        '47': [0, 2 * ts],
        '48': [ts, 2 * ts],
        '49': [2 * ts, 2 * ts],
        '51': [3 * ts, 0],
        '52': [3 * ts, ts],
        '53': [3 * ts, 2 * ts],
        '54': [4 * ts, ts],
        '55': [5 * ts, ts],
        '56': [6 * ts, ts],
        '57': [5 * ts, 0]
      };

      var wallPaletteMap = {
        '21': [0, 0],
        '22': [ts, 0],
        '23': [2 * ts, 0],
        '24': [0, ts],
        '25': [0, 2 * ts],
        '26': [ts, ts],
        '27': [2 * ts, 2 * ts],
        '31': [4 * ts, 0],
        '32': [3 * ts, ts],
        '33': [4 * ts, ts],
        '34': [5 * ts, ts],
        '35': [4 * ts, 2 * ts],
        '36': [3 * ts, 0]
      };

      this.setState({ floorPaletteMap: floorPaletteMap, wallPaletteMap: wallPaletteMap });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(floorImg, wallImg, gameLevel) {
      var lvl = gameLevel,
          gmTileSize = this.props.tileSize,
          srcTileSize = this.state.srcTileSize,
          scale = gmTileSize / srcTileSize,
          h = 3 * gmTileSize,
          fw = 7 * gmTileSize,
          ww = 6 * gmTileSize;

      var fCanvas = document.createElement('canvas'),
          fCtx = fCanvas.getContext('2d'),
          wCanvas = document.createElement('canvas'),
          wCtx = wCanvas.getContext('2d'),
          srcY = 3 * srcTileSize;

      srcY *= lvl === 1 ? 5 : lvl === 2 ? 6 : lvl === 3 ? 7 : lvl === 4 ? 8 : lvl === 5 ? 1 : lvl < 8 ? 2 : lvl < 10 ? 3 : lvl === 10 ? 4 : 1;

      fCanvas.width = fw;
      fCanvas.height = h;
      fCtx.imageSmoothingEnabled = false;
      fCtx.drawImage(floorImg, 0, srcY, fw / scale, h / scale, 0, 0, fw, h);

      wCanvas.width = ww;
      wCanvas.height = h;
      wCtx.imageSmoothingEnabled = false;
      wCtx.drawImage(wallImg, 0, srcY, ww / scale, h / scale, 0, 0, ww, h);

      this.setState({
        floorPalette: { canvas: fCanvas, ctx: fCtx },
        wallPalette: { canvas: wCanvas, ctx: wCtx }
      });

      //Delete after start screen created
      //(this.props.playerArr !== [0,0] && this.drawBackground(this.props, this.state));
    }
  }, {
    key: 'drawBackground',
    value: function drawBackground(timestamp) {
      var playerArr = this.props.playerArr;

      var lastArr = this.lastPlayerArr;

      if (playerArr[0] !== lastArr[0] || playerArr[1] !== lastArr[1]) {
        this.lastPlayerArr = playerArr.slice(0);

        var bgArr = this.props.bgArr,
            flrImg = this.state.floorPalette.canvas,
            wallImg = this.state.wallPalette.canvas,
            flrImgMap = this.state.floorPaletteMap,
            wallImgMap = this.state.wallPaletteMap,
            ts = this.props.tileSize,
            px = this.props.stageSize,
            bgLen = bgArr.length,
            rLen = px / ts,
            air = 10,
            flr = 40;
        var _state = this.state,
            renderArr = _state.renderArr,
            tempCanv = _state.tempCanv,
            dCtx = document.getElementById('bg-layer').getContext('2d'),
            tempCtx = tempCanv.getContext('2d'),
            img = null,
            map = null,
            el = 0,
            srcX = 0,
            srcY = 0,
            i = 0,
            j = 0;

        var _calcRenderPadding = calcRenderPadding(playerArr, bgLen, rLen, ts),
            startRow = _calcRenderPadding.startRow,
            startCol = _calcRenderPadding.startCol,
            renderArrHeight = _calcRenderPadding.renderArrHeight,
            renderArrWidth = _calcRenderPadding.renderArrWidth,
            sX = _calcRenderPadding.sX,
            sY = _calcRenderPadding.sY;

        while (i < renderArrHeight) {
          while (j < renderArrWidth) {
            renderArr[i][j] = bgArr[startRow + i][startCol + j], j++;
          }j = 0, i++;
        }

        tempCtx.fillRect(0, 0, px, px);

        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            el = renderArr[i][j];
            if (el > air) {
              img = el < flr ? wallImg : flrImg;
              map = el < flr ? wallImgMap : flrImgMap;
              srcX = map['' + el][0];
              srcY = map['' + el][1];

              tempCtx.drawImage(img, srcX, srcY, ts, ts, sX + j * ts, sY + i * ts, ts, ts);
            }
          }
        }

        dCtx.drawImage(tempCanv, 0, 0, px, px);
      }

      window.requestAnimationFrame(this.drawBackground);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getBgImages();
      this.initTempCanvas();
      this.initPaletteMaps();

      var _backgroundArray = backgroundArray(this.props.boardSize),
          bgArr = _backgroundArray.bgArr,
          floorCoords = _backgroundArray.floorCoords;

      var bgLevelProcessed = this.props.gameLevel;

      this.props.updateGameClassState({ bgArr: bgArr, bgLevelProcessed: bgLevelProcessed, floorCoords: floorCoords });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel && nextProps.gameLevel || nextProps.bgLevelProcessed === 0) {
        var _backgroundArray2 = backgroundArray(this.props.boardSize),
            bgArr = _backgroundArray2.bgArr,
            floorCoords = _backgroundArray2.floorCoords;

        var bgLevelProcessed = nextProps.gameLevel;

        this.props.updateGameClassState({ bgArr: bgArr, bgLevelProcessed: bgLevelProcessed, floorCoords: floorCoords });

        if (this.state.floorImg) {
          this.setPalettes(this.state.floorImg, this.state.wallImg, nextProps.gameLevel);
        }
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!this.state.floorImg && nextState.floorImg) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      window.requestAnimationFrame(this.drawBackground);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawBackground);
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'bg-layer',
        className: 'bg-layer',
        width: size,
        height: size });
    }
  }]);

  return LayerBackground;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, tileSize,

var LayerDistanceFog = function (_React$Component) {
  _inherits(LayerDistanceFog, _React$Component);

  function LayerDistanceFog(props) {
    _classCallCheck(this, LayerDistanceFog);

    var _this = _possibleConstructorReturn(this, (LayerDistanceFog.__proto__ || Object.getPrototypeOf(LayerDistanceFog)).call(this, props));

    _this.drawDistanceFog = _this.drawDistanceFog.bind(_this);

    _this.renderPadArr = [3, 2, 1, 0, 0, 0, 1, 2, 3];
    _this.renderInset = 3;
    _this.fogColor = 'rgba(0,0,0,0.4)';
    _this.smoothingEnabled = false;
    return _this;
  }

  _createClass(LayerDistanceFog, [{
    key: 'drawDistanceFog',
    value: function drawDistanceFog() {
      var _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          renderInset = this.renderInset,
          renderPadArr = this.renderPadArr,
          rLen = renderPadArr.length;


      var dCtx = getById('layer-distance-fog').getContext('2d'),
          i = 0,
          j = 0;

      dCtx.fillStyle = this.fogColor;
      dCtx.imageSmoothingEnabled = this.smoothingEnabled;
      dCtx.fillRect(0, 0, stageSize, stageSize);

      for (i = 0; i < rLen; i++) {
        for (j = 0; j < rLen; j++) {
          if (j >= renderPadArr[i] && j < rLen - renderPadArr[i]) {
            dCtx.clearRect(tileSize * (renderInset + j), tileSize * (renderInset + i), tileSize, tileSize);
          }
        }
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.drawDistanceFog();
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var stageSize = this.props.stageSize;

      return React.createElement('canvas', {
        id: 'layer-distance-fog',
        className: 'layer-distance-fog',
        width: stageSize,
        height: stageSize });
    }
  }]);

  return LayerDistanceFog;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//stageSize, boardSize, tileSize, playerArr, enemyArr, enemyPalettes, updateGameClassState
//
var LayerEnemy = function (_React$Component) {
  _inherits(LayerEnemy, _React$Component);

  function LayerEnemy(props) {
    _classCallCheck(this, LayerEnemy);

    var _this = _possibleConstructorReturn(this, (LayerEnemy.__proto__ || Object.getPrototypeOf(LayerEnemy)).call(this, props));

    _this.initEnemyArr = _this.initEnemyArr.bind(_this);
    _this.getEnemyImages = _this.getEnemyImages.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.drawEnemies = _this.drawEnemies.bind(_this);

    _this.lastRenderFrame = 0;
    _this.lastPlayerArr = [];

    _this.state = {
      srcTileSize: 16,
      images: {},
      tempCanv: null,
      renderArr: [],
      renderPadArr: [3, 2, 1, 0, 0, 0, 1, 2, 3],
      renderInset: 3,
      renderLenBase: 0,
      minPadPx: 0
    };
    return _this;
  }

  _createClass(LayerEnemy, [{
    key: 'initEnemyArr',
    value: function initEnemyArr() {
      var boardSize = this.props.boardSize,
          enemyArr = initZeroArray(boardSize);


      this.props.updateGameClassState({ enemyArr: enemyArr });
    }
  }, {
    key: 'getEnemyImages',
    value: function getEnemyImages() {
      var path = 'img/characters/',
          type = '.png',
          that = this;

      var avian0Img = void 0,
          avian1Img = void 0,
          demon0Img = void 0,
          demon1Img = void 0,
          elemental0Img = void 0,
          elemental1Img = void 0,
          humanoid0Img = void 0,
          humanoid1Img = void 0,
          reptile0Img = void 0,
          reptile1Img = void 0,
          undead0Img = void 0,
          undead1Img = void 0,
          images = {
        avian0Img: avian0Img,
        avian1Img: avian1Img,
        demon0Img: demon0Img,
        demon1Img: demon1Img,
        elemental0Img: elemental0Img,
        elemental1Img: elemental1Img,
        humanoid0Img: humanoid0Img,
        humanoid1Img: humanoid1Img,
        reptile0Img: reptile0Img,
        reptile1Img: reptile1Img,
        undead0Img: undead0Img,
        undead1Img: undead1Img
      },
          el = void 0,
          eLen = 0,
          i = 0;

      var handleItemLoad = function handleEnemyImageLoad() {
        i++;
        if (i === eLen) {
          that.setState({ images: images });
          that.setPalettes(images);
        }
      };

      for (el in images) {
        images[el] = new Image();
        images[el].src = path + el[0].toUpperCase() + el.slice(1, -3) + type;
        images[el].addEventListener('load', handleItemLoad);
        eLen++;
      }
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          renderInset = this.state.renderInset,
          renderLenBase = stageSize / tileSize - 2 * renderInset,
          minPadPx = renderInset * tileSize,
          smoothRender = false,
          maxRenderSize = renderLenBase * tileSize,
          tempCanv = initMemCanvas(maxRenderSize, maxRenderSize, smoothRender);


      var renderArr = [],
          i = 0;

      renderArr.length = renderLenBase;

      while (i < renderLenBase) {
        renderArr[i] = initZeroArray(renderLenBase), i++;
      }this.setState({ tempCanv: tempCanv, renderArr: renderArr, renderLenBase: renderLenBase, minPadPx: minPadPx, maxRenderSize: maxRenderSize });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var ts = this.props.tileSize,
          srcTs = this.state.srcTileSize,
          scale = ts / srcTs,
          renderSmoothing = false,
          imgPixDataName = 'imgPixData';

      var enemyPalettes = {},
          p = null,
          el = null,
          ctx = null,
          img = null,
          name = '',
          w = 0,
          h = 0;

      for (el in images) {
        img = images[el];
        name = el.slice(0, -3) + 'Palette';
        w = img.width;
        h = img.height;
        p = enemyPalettes;
        p[name] = document.createElement('canvas');
        p[name].width = scale * w;
        p[name].height = scale * h;
        ctx = p[name].getContext('2d');
        ctx.imageSmoothingEnabled = renderSmoothing;
        ctx.drawImage(img, 0, 0, w, h, 0, 0, p[name].width, p[name].height);
        p[name][imgPixDataName] = ctx.getImageData(0, 0, p[name].width, p[name].height).data;
      }

      this.props.updateGameClassState({ enemyPalettes: enemyPalettes });
    }
  }, {
    key: 'drawEnemies',
    value: function drawEnemies(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var playerArr = this.props.playerArr,
          frame = (timestamp - timeRef) % 1000 * .06 > 29 ? 1 : 0;


      var lastArr = this.lastPlayerArr,
          lastFrame = this.lastRenderFrame;

      if (playerArr[0] !== lastArr[0] || playerArr[1] !== lastArr[1] || lastFrame !== frame) {
        this.lastPlayerArr = playerArr.slice(0);
        this.lastRenderFrame = frame;

        var _props2 = this.props,
            tileSize = _props2.tileSize,
            enemyArr = _props2.enemyArr,
            enemyPalettes = _props2.enemyPalettes,
            _state = this.state,
            renderPadArr = _state.renderPadArr,
            renderLenBase = _state.renderLenBase,
            maxRenderSize = _state.maxRenderSize,
            minPadPx = _state.minPadPx,
            enemyArrLen = enemyArr.length;
        var renderArr = this.state.renderArr,
            dCtx = getById('enemy-layer').getContext('2d'),
            tempCanv = this.state.tempCanv,
            tempCtx = tempCanv.getContext('2d'),
            canvas = null,
            startRow = 0,
            startCol = 0,
            padRow = 0,
            padCol = 0,
            renderArrHeight = 0,
            renderArrWidth = 0,
            renderPadX = 0,
            renderPadY = 0,
            el = 0,
            srcX = 0,
            srcY = 0,
            dX = 0,
            dY = 0,
            i = 0,
            j = 0;


        if (playerArr[0] < ~~(renderLenBase / 2)) {
          startRow = 0;
          padRow = ~~(renderLenBase / 2) - playerArr[0];
        } else if (playerArr[0] + ~~(renderLenBase / 2) + 1 > enemyArrLen) {
          padRow = playerArr[0] + ~~(renderLenBase / 2) + 1 - enemyArrLen;
          startRow = enemyArrLen - renderLenBase + padRow;
        } else {
          startRow = playerArr[0] - ~~(renderLenBase / 2);
          padRow = 0;
        }

        if (playerArr[1] < ~~(renderLenBase / 2)) {
          startCol = 0;
          padCol = ~~(renderLenBase / 2) - playerArr[1];
        } else if (playerArr[1] + ~~(renderLenBase / 2) + 1 > enemyArrLen) {
          padCol = playerArr[1] + ~~(renderLenBase / 2) + 1 - enemyArrLen;
          startCol = enemyArrLen - renderLenBase + padCol;
        } else {
          startCol = playerArr[1] - ~~(renderLenBase / 2);
          padCol = 0;
        }

        renderArrHeight = renderLenBase - padRow;
        renderArrWidth = renderLenBase - padCol;

        while (i < renderArrHeight) {
          while (j < renderArrWidth) {
            if (j >= renderPadArr[startRow ? i : i + padRow] && j < renderArrHeight - renderPadArr[startCol ? i : i + padCol]) {

              renderArr[i][j] = enemyArr[startRow + i][startCol + j];
            } else {
              renderArr[i][j] = 0;
            }
            j++;
          }
          j = 0, i++;
        }

        renderPadX = !startCol && padCol ? padCol * tileSize : 0;
        renderPadY = !startRow && padRow ? padRow * tileSize : 0;

        tempCtx.clearRect(0, 0, maxRenderSize, maxRenderSize);

        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            el = renderArr[i][j];

            if (el) {
              canvas = enemyPalettes[el.palette[frame]];
              srcX = el.iconLoc[0];
              srcY = el.iconLoc[1];
              dX = renderPadX + j * tileSize;
              dY = renderPadY + i * tileSize;

              tempCtx.drawImage(canvas, srcX, srcY, tileSize, tileSize, dX, dY, tileSize, tileSize);
            }
          }
        }

        dCtx.clearRect(minPadPx, minPadPx, maxRenderSize, maxRenderSize);
        dCtx.drawImage(tempCanv, renderPadX, renderPadY, renderArrWidth * tileSize, renderArrHeight * tileSize, minPadPx + renderPadX, minPadPx + renderPadY, renderArrWidth * tileSize, renderArrHeight * tileSize);
      }

      window.requestAnimationFrame(this.drawEnemies);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getEnemyImages();
      this.initEnemyArr();
      this.initTempCanvas();
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!Object.keys(this.props.enemyPalettes).length && Object.keys(nextProps.enemyPalettes).length) {

        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      window.requestAnimationFrame(this.drawEnemies);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawEnemies);
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'enemy-layer',
        className: 'enemy-layer',
        width: size,
        height: size });
    }
  }]);

  return LayerEnemy;
}(React.Component);
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, tileSize, boardSize, playerArr, gameLevel

var LayerExploreFog = function (_React$Component) {
  _inherits(LayerExploreFog, _React$Component);

  function LayerExploreFog(props) {
    _classCallCheck(this, LayerExploreFog);

    var _this = _possibleConstructorReturn(this, (LayerExploreFog.__proto__ || Object.getPrototypeOf(LayerExploreFog)).call(this, props));

    _this.initfogState = _this.initFogState.bind(_this);
    _this.resetFogArr = _this.resetFogArr.bind(_this);
    _this.clearExploreFog = _this.clearExploreFog.bind(_this);
    _this.drawExploreFog = _this.drawExploreFog.bind(_this);

    _this.lastPlayerArr = [];
    _this.smoothingEnabled = false;
    _this.fogVal = 1;
    _this.sightRadius = 4;
    _this.sightDecrement = 1;

    _this.state = {
      fogArr: [],
      renderArr: [],
      fogSquareCanvas: null,
      tempCanvas: null
    };
    return _this;
  }

  _createClass(LayerExploreFog, [{
    key: 'initFogState',
    value: function initFogState() {
      var _state = this.state,
          fogArr = _state.fogArr,
          renderArr = _state.renderArr,
          _props = this.props,
          stageSize = _props.stageSize,
          boardSize = _props.boardSize,
          tileSize = _props.tileSize,
          fogVal = this.fogVal,
          fogSquareCanvas = initMemCanvas(tileSize, tileSize, this.smoothingEnabled),
          tempCanvas = initMemCanvas(stageSize, stageSize, this.smoothingEnabled),
          fogCtx = fogSquareCanvas.getContext('2d'),
          rLen = stageSize / tileSize,
          i = 0,
          j = 0;


      fogCtx.fillRect(0, 0, tileSize, tileSize);
      renderArr = initZeroArray(rLen);
      fogArr.length = boardSize;

      while (i < boardSize) {
        fogArr[i] = [];
        fogArr[i].length = boardSize;

        while (j < boardSize) {
          fogArr[i][j] = fogVal, j++;
        }j = 0, i++;
      }

      this.setState({ fogArr: fogArr, renderArr: renderArr, fogSquareCanvas: fogSquareCanvas, tempCanvas: tempCanvas });
    }
  }, {
    key: 'clearExploreFog',
    value: function clearExploreFog(fogArr, playerArr, boardSize) {
      var sightRadius = this.sightRadius,
          sightDecrement = this.sightDecrement,
          _playerArr = _slicedToArray(playerArr, 2),
          row = _playerArr[0],
          col = _playerArr[1];


      var rowRadius = 0,
          i = 0,
          j = 0;

      for (i = 0; i <= sightRadius; i++) {
        rowRadius = i < 2 ? sightRadius : sightRadius - sightDecrement * i + 1;

        for (j = 0; j <= rowRadius; j++) {
          if (row + i < boardSize && col + j < boardSize) fogArr[row + i][col + j] = 0;
          if (i && row - i >= 0 && col + j < boardSize) fogArr[row - i][col + j] = 0;
          if (j && row + i < boardSize && col - j >= 0) fogArr[row + i][col - j] = 0;
          if (i && j && row - i >= 0 && col - j >= 0) fogArr[row - i][col - j] = 0;
        }
      }
      return fogArr;
    }
  }, {
    key: 'resetFogArr',
    value: function resetFogArr() {
      var fogArr = this.state.fogArr,
          boardSize = this.props.boardSize,
          fogVal = this.fogVal,
          i = 0,
          j = 0;


      fogArr.length = boardSize;

      while (i < boardSize) {
        fogArr[i] = [];
        fogArr[i].length = boardSize;

        while (j < boardSize) {
          fogArr[i][j] = fogVal, j++;
        }j = 0, i++;
      }
      this.setState({ fogArr: fogArr });
    }
  }, {
    key: 'drawExploreFog',
    value: function drawExploreFog(timestamp) {
      var playerArr = this.props.playerArr;

      var lastArr = this.lastPlayerArr;

      if (playerArr[0] !== lastArr[0] || playerArr[1] !== lastArr[1]) {
        this.lastPlayerArr = playerArr.slice(0);

        var fogSquareCanvas = this.state.fogSquareCanvas,
            _props2 = this.props,
            stageSize = _props2.stageSize,
            boardSize = _props2.boardSize,
            tileSize = _props2.tileSize,
            rLen = stageSize / tileSize;
        var _state2 = this.state,
            fogArr = _state2.fogArr,
            renderArr = _state2.renderArr,
            tempCanvas = _state2.tempCanvas,
            dCtx = document.getElementById('layer-explore-fog').getContext('2d'),
            tempCtx = tempCanvas.getContext('2d'),
            dX = 0,
            dY = 0,
            i = 0,
            j = 0;

        var _calcRenderPadding = calcRenderPadding(playerArr, boardSize, rLen, tileSize),
            startRow = _calcRenderPadding.startRow,
            startCol = _calcRenderPadding.startCol,
            renderArrHeight = _calcRenderPadding.renderArrHeight,
            renderArrWidth = _calcRenderPadding.renderArrWidth,
            sX = _calcRenderPadding.sX,
            sY = _calcRenderPadding.sY;

        fogArr = this.clearExploreFog(fogArr, playerArr, boardSize);

        //set renderArr
        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            renderArr[i][j] = fogArr[startRow + i][startCol + j];
          }
        }

        tempCtx.clearRect(0, 0, stageSize, stageSize);

        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            if (renderArr[i][j]) {
              dX = sX + j * tileSize;
              dY = sY + i * tileSize;

              tempCtx.drawImage(fogSquareCanvas, dX, dY, tileSize, tileSize);
            }
          }
        }

        dCtx.clearRect(0, 0, stageSize, stageSize);
        dCtx.drawImage(tempCanvas, 0, 0, stageSize, stageSize);

        this.setState({ fogArr: fogArr });
      }

      window.requestAnimationFrame(this.drawExploreFog);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.initFogState();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.gameLevel !== nextProps.gameLevel) {
        this.resetFogArr();
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!this.state.tempCanvas && nextState.tempCanvas) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      window.requestAnimationFrame(this.drawExploreFog);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawExploreFog);
    }
  }, {
    key: 'render',
    value: function render() {
      var stageSize = this.props.stageSize;

      return React.createElement('canvas', {
        id: 'layer-explore-fog',
        className: 'layer-explore-fog',
        width: stageSize,
        height: stageSize });
    }
  }]);

  return LayerExploreFog;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: boardSize, stageSize, tileSize, gameLevel, levels, bgArr, itemArr, updateGameClassState
//playerArr, itemPalettes, floorCoords, itemPaletteArrMap, enemyDead, bgLevelProcessed
var LayerItem = function (_React$Component) {
  _inherits(LayerItem, _React$Component);

  function LayerItem(props) {
    _classCallCheck(this, LayerItem);

    var _this = _possibleConstructorReturn(this, (LayerItem.__proto__ || Object.getPrototypeOf(LayerItem)).call(this, props));

    _this.initItemArr = _this.initItemArr.bind(_this);
    _this.initTempCanvas = _this.initTempCanvas.bind(_this);
    _this.getItemImages = _this.getItemImages.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setPaletteArrMap = _this.setPaletteArrMap.bind(_this);
    _this.setSpawnQuants = _this.setSpawnQuants.bind(_this);
    _this.setItemArr = _this.setItemArr.bind(_this);
    _this.activatePortal = _this.activatePortal.bind(_this);
    _this.drawItems = _this.drawItems.bind(_this);

    _this.enemyDeadCount = 0;
    _this.levelProcessed = 0;
    _this.lastRenderFrame = 0;
    _this.lastPlayerArr = [];

    _this.state = {
      srcTileSize: 16,
      itemTypes: [],
      images: {},
      spawnQuants: [],
      tempCanv: null,
      renderArr: [],
      portalCoord: [],
      displayedItems: ['consumable', 'gold', 'openChest', 'door']
    };
    return _this;
  }

  _createClass(LayerItem, [{
    key: 'initItemArr',
    value: function initItemArr() {
      var len = this.props.boardSize,
          itemArr = initZeroArray(len);

      this.props.updateGameClassState({ itemArr: itemArr });
    }
  }, {
    key: 'getItemImages',
    value: function getItemImages() {
      var path = 'img/items/',
          type = '.png',
          that = this;

      var amuletImg = void 0,
          armorImg = void 0,
          bookImg = void 0,
          bootImg = void 0,
          chest0Img = void 0,
          chest1Img = void 0,
          door0Img = void 0,
          door1Img = void 0,
          gloveImg = void 0,
          hatImg = void 0,
          longWepImg = void 0,
          medWepImg = void 0,
          moneyImg = void 0,
          potionImg = void 0,
          ringImg = void 0,
          shieldImg = void 0,
          shortWepImg = void 0,
          wandImg = void 0,
          images = {
        amuletImg: amuletImg,
        armorImg: armorImg,
        bookImg: bookImg,
        bootImg: bootImg,
        chest0Img: chest0Img,
        chest1Img: chest1Img,
        door0Img: door0Img,
        door1Img: door1Img,
        gloveImg: gloveImg,
        hatImg: hatImg,
        longWepImg: longWepImg,
        medWepImg: medWepImg,
        moneyImg: moneyImg,
        potionImg: potionImg,
        ringImg: ringImg,
        shieldImg: shieldImg,
        shortWepImg: shortWepImg,
        wandImg: wandImg
      },
          el = void 0,
          iLen = 0,
          i = 0;

      var handleItemLoad = function handleItemImageLoad() {
        i++;
        if (i === iLen) {
          that.setState({ images: images });
          that.setPalettes(images);
        }
      };

      for (el in images) {
        images[el] = new Image();
        images[el].src = path + el[0].toUpperCase() + el.slice(1, -3) + type;
        images[el].addEventListener('load', handleItemLoad);
        iLen++;
      }
    }
  }, {
    key: 'initTempCanvas',
    value: function initTempCanvas() {
      var _props = this.props,
          stageSize = _props.stageSize,
          tileSize = _props.tileSize,
          rLen = stageSize / tileSize,
          smoothRender = false,
          tempCanv = initMemCanvas(stageSize, stageSize, smoothRender),
          renderArr = initZeroArray(rLen);


      this.setState({ tempCanv: tempCanv, renderArr: renderArr });
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var ts = this.props.tileSize,
          srcTs = this.state.srcTileSize,
          scale = ts / srcTs,
          renderSmoothing = false,
          imgPixDataName = 'imgPixData';

      var itemPalettes = {},
          p = null,
          el = null,
          ctx = null,
          img = null,
          name = '',
          w = 0,
          h = 0;

      for (el in images) {
        img = images[el];
        name = el.slice(0, -3) + 'Palette';
        w = img.width;
        h = img.height;
        p = itemPalettes;
        p[name] = document.createElement('canvas');
        p[name].width = scale * w;
        p[name].height = scale * h;
        ctx = p[name].getContext('2d');
        ctx.imageSmoothingEnabled = renderSmoothing;
        ctx.drawImage(img, 0, 0, w, h, 0, 0, p[name].width, p[name].height);
        p[name][imgPixDataName] = ctx.getImageData(0, 0, p[name].width, p[name].height).data;
      }

      this.props.updateGameClassState({ itemPalettes: itemPalettes });
    }
  }, {
    key: 'setPaletteArrMap',
    value: function setPaletteArrMap() {
      var itemTypes = [itemAmulets, itemArmors, itemFeet, itemGloves, itemHelmets, itemRings, itemShields, itemWeapons, itemConsumables, chestConsumables, interactivePortals];

      var itemPaletteArrMap = {},
          i = 101,
          props = null;

      itemTypes.forEach(function (el) {
        for (props in el) {
          el[props]['itemArrVal'] = i;
          itemPaletteArrMap['' + i] = el[props];
          i++;
        }
      });

      this.setSpawnQuants(itemTypes);
      this.setState({ itemTypes: itemTypes });
      this.props.updateGameClassState({ itemPaletteArrMap: itemPaletteArrMap });
    }
  }, {
    key: 'setSpawnQuants',
    value: function setSpawnQuants(itemTypes) {
      var levels = this.props.levels,
          valKey = 'itemArrVal';

      var spawnQuants = [],
          item = [],
          spawnObj = {},
          props = null,
          lvl = 0,
          val = 0,
          i = 0;

      spawnQuants.length = levels;
      while (i < levels) {
        spawnQuants[i] = [], i++;
      }itemTypes.forEach(function (el) {
        for (props in el) {
          spawnObj = el[props];
          val = spawnObj[valKey];
          for (lvl in spawnObj.spawnQuant) {
            item = [val, spawnObj.spawnQuant[lvl]];
            spawnQuants[lvl * 1 - 1].push(item);
          }
        }
      });

      this.setState({ spawnQuants: spawnQuants });
    }
  }, {
    key: 'setItemArr',
    value: function setItemArr(nextProps, nextState) {
      var spawnQuants = nextState.spawnQuants,
          gameLevel = nextProps.gameLevel,
          bgArr = nextProps.bgArr,
          topCenterFloorVal = 42;


      var itemArr = [].concat(_toConsumableArray(nextProps.itemArr)),
          floorCoords = [].concat(_toConsumableArray(nextProps.floorCoords)),
          len = itemArr.length,
          fLen = floorCoords.length,
          coord = [],
          index = 0,
          cur = 0,
          i = 0,
          j = 0;

      while (i < len) {
        while (j < len) {
          itemArr[i][j] = 0, j++;
        }j = 0, i++;
      }

      spawnQuants[gameLevel - 1].forEach(function (el) {
        for (i = 0; i < el[1]; i++) {
          index = randInt(0, fLen);
          coord = floorCoords[index];
          itemArr[coord[0]][coord[1]] = el[0];
          floorCoords.splice(index, 1);
          fLen--;
        }
      });

      while (cur !== topCenterFloorVal) {
        index = randInt(0, fLen - 1);
        coord = floorCoords[index];
        cur = bgArr[coord[0]][coord[1]];
      }

      coord[0]--;
      itemArr[coord[0]][coord[1]] = interactivePortals['inactivePortal'].itemArrVal;

      this.setState({ portalCoord: coord });
      this.props.updateGameClassState({ floorCoords: floorCoords, itemArr: itemArr, itemLevelProcessed: gameLevel });
    }
  }, {
    key: 'activatePortal',
    value: function activatePortal() {
      var portalCoord = this.state.portalCoord,
          activePortal = interactivePortals['activePortal'];


      var itemArr = [].concat(_toConsumableArray(this.props.itemArr));

      itemArr[portalCoord[0]][portalCoord[1]] = activePortal.itemArrVal;

      this.props.updateGameClassState({ itemArr: itemArr });
    }
  }, {
    key: 'drawItems',
    value: function drawItems(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var playerArr = this.props.playerArr,
          frame = (timestamp - timeRef) % 1000 * .06 > 29 ? 1 : 0;


      var lastArr = this.lastPlayerArr,
          lastFrame = this.lastRenderFrame;

      if (playerArr[0] !== lastArr[0] || playerArr[1] !== lastArr[1] || lastFrame !== frame) {
        this.lastPlayerArr = playerArr.slice(0);
        this.lastRenderFrame = frame;

        var _props2 = this.props,
            tileSize = _props2.tileSize,
            stageSize = _props2.stageSize,
            itemArr = _props2.itemArr,
            itemPaletteArrMap = _props2.itemPaletteArrMap,
            itemPalettes = _props2.itemPalettes,
            displayedItems = this.state.displayedItems,
            iLen = itemArr.length,
            rLen = stageSize / tileSize;
        var _state = this.state,
            renderArr = _state.renderArr,
            tempCanv = _state.tempCanv,
            dCtx = document.getElementById('item-layer').getContext('2d'),
            tempCtx = tempCanv.getContext('2d'),
            palette = '',
            img = null,
            item = undefined,
            el = 0,
            srcX = 0,
            srcY = 0,
            dX = 0,
            dY = 0,
            i = 0,
            j = 0;

        var _calcRenderPadding = calcRenderPadding(playerArr, iLen, rLen, tileSize),
            startRow = _calcRenderPadding.startRow,
            startCol = _calcRenderPadding.startCol,
            renderArrHeight = _calcRenderPadding.renderArrHeight,
            renderArrWidth = _calcRenderPadding.renderArrWidth,
            sX = _calcRenderPadding.sX,
            sY = _calcRenderPadding.sY;

        while (i < renderArrHeight) {
          while (j < renderArrWidth) {
            renderArr[i][j] = itemArr[startRow + i][startCol + j], j++;
          }
          j = 0, i++;
        }

        tempCtx.clearRect(0, 0, stageSize, stageSize);

        for (i = 0; i < renderArrHeight; i++) {
          for (j = 0; j < renderArrWidth; j++) {
            el = renderArr[i][j];
            if (el) {
              item = displayedItems.includes(itemPaletteArrMap['' + el].type) ? itemPaletteArrMap['' + el] : chestConsumables.closedChest;
              palette = item.type === 'door' ? item.palette[frame] : item.palette;
              img = itemPalettes[palette];

              srcX = item.iconLoc[0];
              srcY = item.iconLoc[1];
              dX = sX + j * tileSize;
              dY = sY + i * tileSize;

              tempCtx.drawImage(img, srcX, srcY, tileSize, tileSize, dX, dY, tileSize, tileSize);
            }
          }
        }

        dCtx.clearRect(0, 0, stageSize, stageSize);
        dCtx.drawImage(tempCanv, 0, 0, stageSize, stageSize);
      }

      window.requestAnimationFrame(this.drawItems);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getItemImages();
      this.initItemArr();
      this.initTempCanvas();
      this.setPaletteArrMap();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.levelProcessed !== nextProps.bgLevelProcessed && (this.props.playerArr[0] !== nextProps.playerArr[0] || this.props.playerArr[1] !== nextProps.playerArr[1])) {

        this.levelProcessed = nextProps.bgLevelProcessed;
        this.setItemArr(nextProps, nextState);
      }

      if (nextProps.enemyDead.count !== this.enemyDeadCount) {
        this.enemyDeadCount = nextProps.enemyDead.count;
        if (nextProps.enemyDead.source.boss) this.activatePortal();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      if (Object.keys(prevProps.itemPalettes).length !== Object.keys(this.props.itemPalettes).length && Object.keys(this.props.itemPalettes).length) {

        window.requestAnimationFrame(this.drawItems);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawItems);
    }
  }, {
    key: 'render',
    value: function render() {
      var size = this.props.stageSize;
      return React.createElement('canvas', {
        id: 'item-layer',
        className: 'item-layer',
        width: size,
        height: size });
    }
  }]);

  return LayerItem;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: playerArr, enemyArr, inventory, interactItem, overlayMode, updateGameClassState,
//playerPalettes, tileSize, toggleMute
var LayerOverlays = function (_React$Component) {
  _inherits(LayerOverlays, _React$Component);

  function LayerOverlays() {
    _classCallCheck(this, LayerOverlays);

    return _possibleConstructorReturn(this, (LayerOverlays.__proto__ || Object.getPrototypeOf(LayerOverlays)).apply(this, arguments));
  }

  _createClass(LayerOverlays, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.props.overlayMode !== nextProps.overlayMode || this.props.overlayMode !== 'off') {

        return true;
      }
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var mode = this.props.overlayMode;

      var content = null;

      if (mode === 'inv-overlay') {
        content = React.createElement(OverlayInventory, {
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'help-overlay') {
        content = React.createElement(OverlayHelp, {
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'merchant-overlay') {
        content = React.createElement(OverlayMerchant, {
          playerArr: this.props.playerArr,
          enemyArr: this.props.enemyArr,
          inventory: this.props.inventory,
          interactItem: this.props.interactItem,
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'game-over-overlay') {
        content = React.createElement(OverlayGameOver, {
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'game-win-overlay') {
        content = React.createElement(OverlayGameWin, {
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      } else if (mode === 'hero-selection-overlay') {
        content = React.createElement(OverlayHeroSelection, {
          tileSize: this.props.tileSize,
          playerPalettes: this.props.playerPalettes,
          toggleMute: this.props.toggleMute,
          updateGameClassState: this.props.updateGameClassState });
      }

      return React.createElement(
        'div',
        null,
        content
      );
    }
  }]);

  return LayerOverlays;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: stageSize, tileSize, hero, heroFacing, gameLevel, bgArr, playerArr, updateGameClassState,
//floorCoords, bgLevelProcessed, playerPalettes
var LayerPlayer = function (_React$Component) {
  _inherits(LayerPlayer, _React$Component);

  function LayerPlayer(props) {
    _classCallCheck(this, LayerPlayer);

    var _this = _possibleConstructorReturn(this, (LayerPlayer.__proto__ || Object.getPrototypeOf(LayerPlayer)).call(this, props));

    _this.getPlayerImages = _this.getPlayerImages.bind(_this);
    _this.setPalettes = _this.setPalettes.bind(_this);
    _this.setHeroIcon = _this.setHeroIcon.bind(_this);
    _this.pickPlayerStart = _this.pickPlayerStart.bind(_this);
    _this.drawPlayer = _this.drawPlayer.bind(_this);

    _this.drawingStart = false;
    _this.startHeroIcon = false;

    _this.state = {
      srcTileSize: 16,
      mageImg: null,
      rogueImg: null,
      paladinImg: null,
      warriorImg: null,
      images: {}
    };
    return _this;
  }

  _createClass(LayerPlayer, [{
    key: 'getPlayerImages',
    value: function getPlayerImages() {
      var mageImg = new Image(),
          rogueImg = new Image(),
          paladinImg = new Image(),
          warriorImg = new Image(),
          that = this;

      var images = {},
          i = 0;

      var handleLoad = function handleImageLoad() {
        i++;
        if (i === 4) {
          images = { mageImg: mageImg, rogueImg: rogueImg, paladinImg: paladinImg, warriorImg: warriorImg };
          that.setState(images, that.setPalettes(images));
        }
      };

      mageImg.src = 'img/heroes/Mage.png';
      rogueImg.src = 'img/heroes/Rogue.png';
      paladinImg.src = 'img/heroes/Paladin.png';
      warriorImg.src = 'img/heroes/Warrior.png';
      mageImg.addEventListener('load', handleLoad);
      rogueImg.addEventListener('load', handleLoad);
      paladinImg.addEventListener('load', handleLoad);
      warriorImg.addEventListener('load', handleLoad);
    }
  }, {
    key: 'setPalettes',
    value: function setPalettes(images) {
      var srcTS = this.state.srcTileSize,
          gmTS = this.props.tileSize,
          scale = gmTS / srcTS,
          w = 4 * gmTS,
          h = 4 * gmTS;

      var playerPalettes = {},
          canvas = null,
          ctx = null,
          img = null;

      for (img in images) {
        canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;

        ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(images[img], 0, 0, w / scale, h / scale, 0, 0, w, h);

        playerPalettes[img] = canvas;
      }

      this.props.updateGameClassState({ playerPalettes: playerPalettes });
    }
  }, {
    key: 'setHeroIcon',
    value: function setHeroIcon() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var playerPalettes = props.playerPalettes,
          heroImageKey = props.hero.toLowerCase() + 'Img',
          w = props.tileSize,
          h = w;


      var heroIcon = document.createElement('canvas'),
          hCtx = null;

      heroIcon.width = w;
      heroIcon.height = h;
      hCtx = heroIcon.getContext('2d');
      hCtx.imageSmoothingEnabled = false;
      hCtx.drawImage(playerPalettes[heroImageKey], 0, 0, w, h, 0, 0, w, h);
      props.updateGameClassState({ heroIcon: heroIcon });
    }
  }, {
    key: 'pickPlayerStart',
    value: function pickPlayerStart(nextProps) {
      var floorCoords = nextProps.floorCoords;


      var index = randInt(0, nextProps.floorCoords.length - 1),
          playerArr = floorCoords[index],
          filterDistance = 8;

      floorCoords = floorCoords.filter(function (a) {
        return Math.abs(a[0] - playerArr[0]) + Math.abs(a[1] - playerArr[1]) > filterDistance;
      });

      this.props.updateGameClassState({ playerArr: playerArr, floorCoords: floorCoords });
    }
  }, {
    key: 'drawPlayer',
    value: function drawPlayer(timestamp) {
      if (!timeRef) timeRef = timestamp;

      var img = this.props.playerPalettes[this.props.hero.toLowerCase() + 'Img'],
          imgD = this.props.tileSize,
          dir = this.props.heroFacing,
          dx = (this.props.stageSize - imgD) / 2,
          dy = dx,
          srcY = dir === 'down' ? 0 : dir === 'left' ? 1 : dir === 'right' ? 2 : 3,
          frameStep = Math.floor((timestamp - timeRef) % 1000 * .06 / 15);

      var canvas = document.getElementById('player-layer'),
          ctx = canvas.getContext('2d');

      ctx.clearRect(dx, dy, imgD, imgD);
      ctx.drawImage(img, frameStep * imgD, srcY * imgD, imgD, imgD, dx, dy, imgD, imgD);
      window.requestAnimationFrame(this.drawPlayer);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.getPlayerImages();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.props.bgLevelProcessed !== nextProps.bgLevelProcessed) {
        this.pickPlayerStart(nextProps);
      }
      if (!nextProps.heroIcon && !this.startHeroIcon && nextProps.hero && nextProps.playerPalettes[nextProps.hero.toLowerCase() + 'Img']) {

        this.startHeroIcon = true;
        this.setHeroIcon(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (!this.drawingStart && nextProps.hero && nextProps.playerPalettes[this.props.hero.toLowerCase() + 'Img']) {

        this.drawingStart = true;
        return true;
      }
      return false;
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      window.requestAnimationFrame(this.drawPlayer);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.cancelAnimationFrame(this.drawPlayer);
    }
  }, {
    key: 'render',
    value: function render() {
      var stageSize = this.props.stageSize;


      return React.createElement('canvas', {
        id: 'player-layer',
        className: 'player-layer',
        width: stageSize,
        height: stageSize });
    }
  }]);

  return LayerPlayer;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: updateGameClassState, toggleMute

var OverlayGameOver = function (_React$Component) {
  _inherits(OverlayGameOver, _React$Component);

  function OverlayGameOver(props) {
    _classCallCheck(this, OverlayGameOver);

    var _this = _possibleConstructorReturn(this, (OverlayGameOver.__proto__ || Object.getPrototypeOf(OverlayGameOver)).call(this, props));

    _this.initOverlay = _this.initOverlay.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.focus = _this.focus.bind(_this);

    _this.state = {
      gameOverMessage: '',
      focusClass: 'optFocus'
    };
    return _this;
  }

  _createClass(OverlayGameOver, [{
    key: 'initOverlay',
    value: function initOverlay() {
      var gameOverMessage = 'You have failed. ' + 'Your village was overrun by the evil horde. ' + 'There were no survivors.';

      this.setState({ gameOverMessage: gameOverMessage });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code;

      if (el === 'Space' || el === 'Enter' || el === 'Escape') {
        this.props.updateGameClassState({ overlayMode: 'hero-selection-overlay' });
      } else if (el === 'KeyQ' || el === 'KeyP') {
        this.props.toggleMute();
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initOverlay();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          gameOverMessage = _state.gameOverMessage,
          focusClass = _state.focusClass;


      return React.createElement(
        'div',
        { id: 'game-over-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'game-over-header' },
          'GAME OVER'
        ),
        React.createElement(
          'div',
          { className: 'game-over-message' },
          gameOverMessage
        ),
        React.createElement(
          'div',
          { className: 'game-over-row ' + focusClass },
          'Try Again?'
        )
      );
    }
  }]);

  return OverlayGameOver;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: updateGameClassState, toggleMute

var OverlayGameWin = function (_React$Component) {
  _inherits(OverlayGameWin, _React$Component);

  function OverlayGameWin(props) {
    _classCallCheck(this, OverlayGameWin);

    var _this = _possibleConstructorReturn(this, (OverlayGameWin.__proto__ || Object.getPrototypeOf(OverlayGameWin)).call(this, props));

    _this.initOverlay = _this.initOverlay.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.focus = _this.focus.bind(_this);

    _this.state = {
      gameOverMessage: '',
      focusClass: 'optFocus'
    };
    return _this;
  }

  _createClass(OverlayGameWin, [{
    key: 'initOverlay',
    value: function initOverlay() {
      var gameOverMessage = 'The Evil Lords have been crushed. ' + 'The minions that remain cower from your fury. The evil hordes scatter. ' + 'Your village will surely rejoice upon your return.';

      this.setState({ gameOverMessage: gameOverMessage });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code;

      if (el === 'Space' || el === 'Enter' || el === 'Escape') {
        this.props.updateGameClassState({ overlayMode: 'hero-selection-overlay' });
      } else if (el === 'KeyQ' || el === 'KeyP') {
        this.props.toggleMute();
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initOverlay();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          gameOverMessage = _state.gameOverMessage,
          focusClass = _state.focusClass;


      return React.createElement(
        'div',
        { id: 'game-over-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'game-over-header' },
          'YOU ARE VICTORIOUS'
        ),
        React.createElement(
          'div',
          { className: 'game-over-message' },
          gameOverMessage
        ),
        React.createElement(
          'div',
          { className: 'game-over-row ' + focusClass },
          'Play Again?'
        )
      );
    }
  }]);

  return OverlayGameWin;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: updateGameClassState, toggleMute

var OverlayHelp = function (_React$Component) {
  _inherits(OverlayHelp, _React$Component);

  function OverlayHelp(props) {
    _classCallCheck(this, OverlayHelp);

    var _this = _possibleConstructorReturn(this, (OverlayHelp.__proto__ || Object.getPrototypeOf(OverlayHelp)).call(this, props));

    _this.initOverlay = _this.initOverlay.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.maintainFocus = _this.maintainFocus.bind(_this);
    _this.endFocus = _this.endFocus.bind(_this);

    _this.state = {
      helpMessage: ''
    };
    return _this;
  }

  _createClass(OverlayHelp, [{
    key: 'initOverlay',
    value: function initOverlay() {
      var helpMessage = "Items enclosed in quotes ('') denote key mappings.";

      this.setState({ helpMessage: helpMessage });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code;

      if (el === 'KeyH' || el === 'Space' || el === 'Enter' || el === 'Escape') {
        this.props.updateGameClassState({ overlayMode: 'off' });
      } else if (el === 'KeyQ' || el === 'KeyP') {
        this.props.toggleMute();
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'maintainFocus',
    value: function maintainFocus() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'endFocus',
    value: function endFocus() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initOverlay();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.maintainFocus();
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      return false;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.endFocus();
    }
  }, {
    key: 'render',
    value: function render() {
      var helpMessage = this.state.helpMessage;


      return React.createElement(
        'div',
        { id: 'help-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'game-over-header' },
          'HELP'
        ),
        React.createElement(
          'div',
          { className: 'game-over-message' },
          helpMessage
        ),
        React.createElement(
          'div',
          { className: 'help-details' },
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'ACTION'
            ),
            React.createElement(
              'span',
              null,
              'KEY MAP'
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Move Up:'
            ),
            React.createElement(
              'span',
              null,
              '\'W\' or \'ArrowUp\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Move Down:'
            ),
            React.createElement(
              'span',
              null,
              '\'S\' or \'ArrowDown\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Move Left:'
            ),
            React.createElement(
              'span',
              null,
              '\'A\' or \'ArrowLeft\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Move Right:'
            ),
            React.createElement(
              'span',
              null,
              '\'D\' or \'ArrowRight\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Enter:'
            ),
            React.createElement(
              'span',
              null,
              '\'Enter\' or \'SpaceBar\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Use Stat Point:'
            ),
            React.createElement(
              'span',
              null,
              '\'V\', \'B\', \'N\', \'M\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'QuickConsume Items:'
            ),
            React.createElement(
              'span',
              null,
              'Numbers \'1\' through \'8\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Toggle Inventory:'
            ),
            React.createElement(
              'span',
              null,
              '\'I\' or \'E\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Toggle Help:'
            ),
            React.createElement(
              'span',
              null,
              '\'H\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Toggle Mute:'
            ),
            React.createElement(
              'span',
              null,
              '\'Q\' or \'P\''
            )
          ),
          React.createElement(
            'p',
            { className: 'help-row' },
            React.createElement(
              'span',
              { className: 'help-action' },
              'Toggle Buy/Sell:'
            ),
            React.createElement(
              'span',
              null,
              '\'Y\'/\'U\' (In Merch Screen)'
            )
          )
        )
      );
    }
  }]);

  return OverlayHelp;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: updateGameClassState, playerPalettes, tileSize, toggleMute

var OverlayHeroSelection = function (_React$Component) {
  _inherits(OverlayHeroSelection, _React$Component);

  function OverlayHeroSelection(props) {
    _classCallCheck(this, OverlayHeroSelection);

    var _this = _possibleConstructorReturn(this, (OverlayHeroSelection.__proto__ || Object.getPrototypeOf(OverlayHeroSelection)).call(this, props));

    _this.initOverlay = _this.initOverlay.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.focus = _this.focus.bind(_this);

    _this.state = {
      heroTypes: [],
      heroSelectionMessage: '',
      currentSelection: ''
    };
    return _this;
  }

  _createClass(OverlayHeroSelection, [{
    key: 'initOverlay',
    value: function initOverlay() {
      var heroSelectionMessage = 'It was a stroke of luck to have intercepted their plot. ' + 'The evil horde is gathering strength to sweep across your homeland. ' + 'Your only hope is a preemptive strike at their very heart. ' + 'Choose your hero wisely';

      var heroTypes = [],
          heroType = '',
          currentSelection = '';

      for (heroType in heroTypeStats) {
        heroTypes.push(heroType);
      }currentSelection = heroTypes[0];

      this.setState({ heroTypes: heroTypes, heroSelectionMessage: heroSelectionMessage, currentSelection: currentSelection });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var heroTypes = this.state.heroTypes,
          el = e.nativeEvent.code;
      var currentSelection = this.state.currentSelection,
          index = heroTypes.indexOf(currentSelection);


      if (el === 'ArrowUp' && index > 0 || el === 'ArrowDown' && index < heroTypes.length - 1) {
        index = el === 'ArrowUp' ? index - 1 : index + 1;
        currentSelection = heroTypes[index];

        this.setState({ currentSelection: currentSelection });
      } else if (el === 'Space' || el === 'Enter' || el === 'NumpadEnter') {
        this.props.updateGameClassState({ hero: currentSelection });
      } else if (el === 'KeyQ' || el === 'KeyP') {
        this.props.toggleMute();
      } else {
        console.log(el);
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.initOverlay();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.state.currentSelection !== nextState.currentSelection || !Object.keys(this.props.playerPalettes).length && Object.keys(nextProps.playerPalettes).length) {
        return true;
      }

      return false;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _state = this.state,
          heroTypes = _state.heroTypes,
          heroSelectionMessage = _state.heroSelectionMessage,
          currentSelection = _state.currentSelection,
          playerPalettes = this.props.playerPalettes[currentSelection.toLowerCase() + 'Img'] ? this.props.playerPalettes : null;


      var heroSelectionRows = heroTypes.map(function (type, i) {
        return React.createElement(OverlayHeroSelectionRow, {
          key: type + i,
          position: i,
          heroType: type,
          currentSelection: currentSelection,
          playerPalettes: playerPalettes,
          tileSize: _this3.props.tileSize });
      });

      return React.createElement(
        'div',
        {
          id: 'hero-selection-overlay',
          className: 'stage-overlay',
          tabIndex: '1',
          onKeyDown: this.optKeyDown
        },
        React.createElement(
          'h4',
          { className: 'hero-selection-header' },
          'CHOOSE YOUR FATE'
        ),
        React.createElement(
          'div',
          { className: 'hero-selection-message' },
          heroSelectionMessage
        ),
        heroSelectionRows
      );
    }
  }]);

  return OverlayHeroSelection;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: position, heroType, currentSelection, playerPalettes, tileSize

var OverlayHeroSelectionRow = function (_React$Component) {
  _inherits(OverlayHeroSelectionRow, _React$Component);

  function OverlayHeroSelectionRow(props) {
    _classCallCheck(this, OverlayHeroSelectionRow);

    var _this = _possibleConstructorReturn(this, (OverlayHeroSelectionRow.__proto__ || Object.getPrototypeOf(OverlayHeroSelectionRow)).call(this, props));

    _this.drawIcon = _this.drawIcon.bind(_this);

    _this.canvasId = 'hero-icon';
    _this.iconDrawn = false;

    _this.state = {};
    return _this;
  }

  _createClass(OverlayHeroSelectionRow, [{
    key: 'drawIcon',
    value: function drawIcon() {
      var curProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      this.iconDrawn = true;

      var position = curProps.position,
          heroType = curProps.heroType,
          playerPalettes = curProps.playerPalettes,
          tileSize = curProps.tileSize,
          heroCanvas = playerPalettes[heroType.toLowerCase() + 'Img'];


      var ctx = getById(this.canvasId + position).getContext('2d');

      ctx.drawImage(heroCanvas, 0, 0, tileSize, tileSize, 0, 0, tileSize, tileSize);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.playerPalettes != null && this.props.playerPalettes[this.props.heroType.toLowerCase() + 'Img']) {

        this.drawIcon();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!this.iconDrawn && nextProps.playerPalettes != null && nextProps.playerPalettes[nextProps.heroType.toLowerCase() + 'Img']) {

        this.drawIcon(nextProps);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.propscurrentSelection !== nextProps.currentSelection) {
        return true;
      }

      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          position = _props.position,
          heroType = _props.heroType,
          currentSelection = _props.currentSelection,
          tileSize = _props.tileSize,
          hero = heroTypeStats[heroType],
          rowClasses = heroType === currentSelection ? 'hero-selection-row hero-selection-focus' : 'hero-selection-row';


      return React.createElement(
        'div',
        { className: rowClasses },
        React.createElement('canvas', {
          id: this.canvasId + position,
          className: 'hero-selection-canvas',
          width: tileSize,
          height: tileSize }),
        React.createElement(
          'div',
          { className: 'hero-description' },
          React.createElement(
            'div',
            { className: 'label-col' },
            React.createElement(
              'p',
              null,
              'Name:'
            ),
            React.createElement(
              'p',
              null,
              'Type:'
            ),
            React.createElement(
              'p',
              null,
              'Desc:'
            )
          ),
          React.createElement(
            'div',
            { className: 'info-col' },
            React.createElement(
              'p',
              null,
              hero.heroName
            ),
            React.createElement(
              'p',
              null,
              heroType
            ),
            React.createElement(
              'p',
              null,
              hero.description
            )
          )
        )
      );
    }
  }]);

  return OverlayHeroSelectionRow;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: inventory, interactItem, updateGameClassState, toggleMute
var OverlayInventory = function (_React$Component) {
  _inherits(OverlayInventory, _React$Component);

  function OverlayInventory(props) {
    _classCallCheck(this, OverlayInventory);

    var _this = _possibleConstructorReturn(this, (OverlayInventory.__proto__ || Object.getPrototypeOf(OverlayInventory)).call(this, props));

    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.updateOptFocus = _this.updateOptFocus.bind(_this);
    _this.setList = _this.setList.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);

    _this.state = {
      invCategories: ['Head', 'Amulet', 'Weapon', 'Armor', 'Shield', 'Glove', 'Ring', 'Foot', 'Consumable'],
      bRowId: 'item-row',
      bColId: 'item-col',
      focusClass: 'optFocus',
      row: 0,
      col: 0
    };
    return _this;
  }

  _createClass(OverlayInventory, [{
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code,
          cats = this.state.invCategories,
          len = cats.length;

      var _state = this.state,
          row = _state.row,
          col = _state.col,
          delta = [];


      if ((el === 'ArrowUp' || el === 'KeyW') && row > 0) delta = [-1, 0];else if ((el === 'ArrowRight' || el === 'KeyD') && col < len - 1) delta = [0, 1];else if (el === 'ArrowDown' || el === 'KeyS') delta = [1, 0];else if ((el === 'ArrowLeft' || el === 'KeyA') && col > 0) delta = [0, -1];else if (el === 'KeyI' || el === 'KeyE' || el === 'Escape') this.props.updateGameClassState({ overlayMode: 'off' });else if ((el === 'Space' || el === 'Enter' || el == 'Numpad Enter') && getById(this.state.bRowId + this.state.row)) {
        var name = getById(this.state.bRowId + row).querySelectorAll('span')[1].innerText,
            type = this.state.invCategories[this.state.col].toLowerCase();

        this.handleInteractItem(name);
      } else if (el === 'KeyQ' || el === 'KeyP') this.props.toggleMute();

      if (delta.length > 0) this.updateOptFocus([row, col], delta);
    }
  }, {
    key: 'updateOptFocus',
    value: function updateOptFocus(coordsArr) {
      var deltaArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var bIds = [this.state.bRowId, this.state.bColId];

      var update = false,
          nextVal = '',
          nState = {};

      if (deltaArr[1] !== 0) {
        nState['row'] = 0;
        nextVal = coordsArr[1] + deltaArr[1];

        if (getById(bIds[1] + nextVal)) nState['col'] = nextVal;
      } else {
        nextVal = coordsArr[0] + deltaArr[0];

        if (getById(bIds[0] + nextVal)) nState['row'] = nextVal;
      }

      if (nState.hasOwnProperty('row')) {
        update = true;
        this.setState(nState);
      }

      return update;
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'setList',
    value: function setList(inv, header) {
      var conv = statConvertWordMap;

      var list = [],
          props = null,
          p = null,
          el = null,
          equipped = '',
          stats = '';

      for (props in inv) {
        if (inv[props].type === header && inv[props].count > 0) {
          el = inv[props];
          stats = '';

          for (p in el.stats) {
            stats += '' + conv[p] + el.stats[p] + ' ';
          }if (el.type === 'consumable') list.push([el.count, el.name, stats, el.buy]);else equipped = el.equipped ? 'E' : ' ', list.push([equipped, el.name, stats, el.buy]);
        }
      }

      list.sort(function (a, b) {
        return a[3] !== b[3] ? b[3] - a[3] : a[1] < b[1] ? -1 : 1;
      });

      return list;
    }
  }, {
    key: 'setItems',
    value: function setItems(list, colNames, bRowId) {
      var _this2 = this;

      var row = this.state.row;

      var classes = '';

      return [].concat(_toConsumableArray(Array(list.length))).map(function (x, i) {
        classes = i === row ? bRowId + ' ' + _this2.state.focusClass : bRowId;
        return React.createElement(
          'div',
          { id: bRowId + i, className: classes, key: list[i][1] },
          React.createElement(
            'span',
            { className: colNames[0].toLowerCase() + '-col', key: list[i][0] },
            list[i][0]
          ),
          React.createElement(
            'span',
            { className: colNames[1].toLowerCase() + '-col', key: list[i][1] + '-col' },
            list[i][1]
          ),
          React.createElement(
            'span',
            { className: colNames[2].toLowerCase() + '-col', key: list[i][2] },
            list[i][2]
          )
        );
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(name) {
      var item = this.props.inventory[name],
          cats = this.state.invCategories;

      var interactItem = Object.assign({}, this.props.interactItem),
          action = '';

      action = item.type === cats[cats.length - 1].toLowerCase() ? 'use' : item.equipped ? 'unequip' : 'equip';

      interactItem.count += 1;
      interactItem.type = action;
      interactItem.item = item;

      this.props.updateGameClassState({ interactItem: interactItem });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this3.focus();
      }, 250);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var cats = [].concat(_toConsumableArray(this.state.invCategories)),
          _state2 = this.state,
          row = _state2.row,
          col = _state2.col,
          bRowId = _state2.bRowId,
          bColId = _state2.bColId,
          focusClass = _state2.focusClass,
          header = cats[col].toLowerCase(),
          inv = this.props.inventory,
          abbrev = equipAbbrevMap;


      var colHeaders = null,
          iHeaders = null,
          items = null,
          classes = '';

      var colNames = header === 'consumable' ? ['Quantity', 'Name', 'Stats'] : ['Equipped', 'Name', 'Stats'];

      var list = this.setList(inv, header);

      colHeaders = cats.map(function (x, i) {
        classes = i === col ? bColId + ' ' + focusClass : bColId;
        return React.createElement(
          'span',
          { id: bColId + i, className: classes, key: x },
          abbrev[x]
        );
      });

      iHeaders = [].concat(_toConsumableArray(Array(colNames.length))).map(function (x, i) {
        return React.createElement(
          'span',
          { className: 'item-header item-header-' + i, key: colNames[i] },
          colNames[i]
        );
      });

      items = this.setItems(list, colNames, bRowId);

      return React.createElement(
        'div',
        { id: 'inv-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'inv-header' },
          'Inventory'
        ),
        React.createElement(
          'div',
          { className: 'inv-categories' },
          colHeaders
        ),
        React.createElement(
          'div',
          { className: 'item-list' },
          React.createElement(
            'div',
            { className: 'iheader-row' },
            iHeaders
          ),
          items
        )
      );
    }
  }]);

  return OverlayInventory;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//props: playerArr, enemyArr, inventory, interactItem, updateGameClassState, toggleMute


var OverlayMerchant = function (_React$Component) {
  _inherits(OverlayMerchant, _React$Component);

  function OverlayMerchant(props) {
    _classCallCheck(this, OverlayMerchant);

    var _this = _possibleConstructorReturn(this, (OverlayMerchant.__proto__ || Object.getPrototypeOf(OverlayMerchant)).call(this, props));

    _this.setSource = _this.setSource.bind(_this);
    _this.optKeyDown = _this.optKeyDown.bind(_this);
    _this.updateOptFocus = _this.updateOptFocus.bind(_this);
    _this.setList = _this.setList.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.handleInteractItem = _this.handleInteractItem.bind(_this);

    _this.state = {
      source: {},
      interactCategories: ['Buy', 'Sell'],
      invCategories: ['Head', 'Amulet', 'Weapon', 'Armor', 'Shield', 'Glove', 'Ring', 'Foot', 'Consumable'],
      colNames: ['Quant/Buy/Sell', 'Name', 'Stats'],
      bInteractId: 'interact-type',
      bRowId: 'item-row',
      bColId: 'item-col',
      focusClass: 'optFocus',
      interactCategory: 'Buy',
      row: 0,
      col: 0
    };
    return _this;
  }

  _createClass(OverlayMerchant, [{
    key: 'setSource',
    value: function setSource() {
      var _props = this.props,
          playerArr = _props.playerArr,
          enemyArr = _props.enemyArr;


      var curEnemy = {},
          source = {};

      [[playerArr[0] - 1, playerArr[1]], [playerArr[0], playerArr[1] + 1], [playerArr[0] + 1, playerArr[1]], [playerArr[0], playerArr[1] - 1]].forEach(function (coord) {
        curEnemy = enemyArr[coord[0]][coord[1]];
        if (curEnemy && curEnemy.type === 'merchant') {
          source = curEnemy;
        }
      });
      this.setState({ source: source });
    }
  }, {
    key: 'optKeyDown',
    value: function optKeyDown(e) {
      var el = e.nativeEvent.code,
          cats = this.state.invCategories,
          len = cats.length;

      var _state = this.state,
          row = _state.row,
          col = _state.col,
          interactCategories = _state.interactCategories,
          interactCategory = _state.interactCategory,
          delta = [];


      if ((el === 'ArrowUp' || el === 'KeyW') && row > 0) delta = [-1, 0];else if ((el === 'ArrowRight' || el === 'KeyD') && col < len - 1) delta = [0, 1];else if (el === 'ArrowDown' || el === 'KeyS') delta = [1, 0];else if ((el === 'ArrowLeft' || el === 'KeyA') && col > 0) delta = [0, -1];else if (el === 'KeyY' && interactCategory !== interactCategories[0]) {
        this.setState({ row: 0, interactCategory: interactCategories[0] });
      } else if (el === 'KeyU' && interactCategory !== interactCategories[1]) {
        this.setState({ row: 0, interactCategory: interactCategories[1] });
      } else if (el === 'KeyI' || el === 'KeyE' || el === 'Escape') this.props.updateGameClassState({ overlayMode: 'off' });else if ((el === 'Space' || el === 'Enter' || el === 'NumpadEnter') && getById(this.state.bRowId + this.state.row)) {
        var name = getById(this.state.bRowId + row).querySelectorAll('span')[1].id,
            type = this.state.invCategories[this.state.col].toLowerCase();

        this.handleInteractItem(name);
      } else if (el === 'KeyQ' || el === 'KeyP') this.props.toggleMute();

      if (delta.length > 0) this.updateOptFocus([row, col], delta);
    }
  }, {
    key: 'updateOptFocus',
    value: function updateOptFocus(coordsArr) {
      var deltaArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var bIds = [this.state.bRowId, this.state.bColId];

      var update = false,
          nextVal = '',
          nState = {};

      if (deltaArr[1] !== 0) {
        nState['row'] = 0;
        nextVal = coordsArr[1] + deltaArr[1];

        if (getById(bIds[1] + nextVal)) nState['col'] = nextVal;
      } else {
        nextVal = coordsArr[0] + deltaArr[0];

        if (getById(bIds[0] + nextVal)) nState['row'] = nextVal;
      }

      if (nState.hasOwnProperty('row')) {
        update = true;
        this.setState(nState);
      }

      return update;
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'setList',
    value: function setList(inv, header) {
      var conv = statConvertWordMap;

      var list = [],
          props = null,
          p = null,
          el = null,
          stats = '',
          quantBuySell = '',
          buyA = 0,
          buyB = 0;

      for (props in inv) {
        if (inv[props].type === header && inv[props].count > 0) {
          el = inv[props];
          quantBuySell = el.count + '/' + el.buy + '/' + el.sell;
          stats = '';

          for (p in el.stats) {
            stats += '' + conv[p] + el.stats[p] + ' ';
          }list.push([quantBuySell, el.name, stats, props]);
        }
      }

      return list.sort(function (a, b) {
        buyA = a[0].split('/')[1] * 1;
        buyB = b[0].split('/')[1] * 1;
        return buyA !== buyB ? buyB - buyA : a[1] < b[1] ? -1 : 1;
      });
    }
  }, {
    key: 'setItems',
    value: function setItems(list, colNames, bRowId) {
      var _this2 = this;

      var row = this.state.row;

      var classes = '';

      return [].concat(_toConsumableArray(Array(list.length))).map(function (x, i) {
        classes = i === row ? bRowId + ' ' + _this2.state.focusClass : bRowId;
        return React.createElement(
          'div',
          { id: bRowId + i, className: classes, key: list[i][1] },
          React.createElement(
            'span',
            {
              className: colNames[0].toLowerCase().replace(/\//g, '-') + '-col',
              key: list[i][0] + i },
            list[i][0]
          ),
          React.createElement(
            'span',
            {
              id: list[i][3],
              className: colNames[1].toLowerCase() + '-col',
              key: list[i][1] + '-col' },
            list[i][1]
          ),
          React.createElement(
            'span',
            { className: colNames[2].toLowerCase() + '-col', key: list[i][2] + i },
            list[i][2]
          )
        );
      });
    }
  }, {
    key: 'handleInteractItem',
    value: function handleInteractItem(name) {
      var _state2 = this.state,
          interactCategories = _state2.interactCategories,
          interactCategory = _state2.interactCategory,
          source = _state2.source;


      var interactItem = Object.assign({}, this.props.interactItem),
          item = {},
          action = '';

      if (interactCategory === interactCategories[0]) {
        action = interactCategories[0].toLowerCase();
        item = source.inventory[name];
      } else {
        action = interactCategories[1].toLowerCase();
        item = this.props.inventory[name];
      }

      interactItem.count += 1;
      interactItem.type = action;
      interactItem.item = item;
      interactItem.source = source;

      this.props.updateGameClassState({ interactItem: interactItem });
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.setSource();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this3.focus();
      }, 250);
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      if (this.state.interactCategory !== nextState.interactCategory || this.state.row !== nextState.row || this.state.col !== nextState.col || this.props.interactItem.count !== nextProps.interactItem.count) {

        return true;
      }
      return false;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'render',
    value: function render() {
      var cats = [].concat(_toConsumableArray(this.state.invCategories)),
          _state3 = this.state,
          row = _state3.row,
          col = _state3.col,
          bInteractId = _state3.bInteractId,
          bRowId = _state3.bRowId,
          bColId = _state3.bColId,
          focusClass = _state3.focusClass,
          interactCategories = _state3.interactCategories,
          interactCategory = _state3.interactCategory,
          colNames = _state3.colNames,
          source = _state3.source,
          header = cats[col].toLowerCase(),
          inv = interactCategory === interactCategories[0] ? source.inventory : this.props.inventory,
          abbrev = equipAbbrevMap;


      var interactHeaders = null,
          colHeaders = null,
          iHeaders = null,
          items = null,
          classes = '';

      var list = this.setList(inv, header);

      interactHeaders = interactCategories.map(function (x, i) {
        classes = x === interactCategory ? bInteractId + ' ' + focusClass : bInteractId;
        return React.createElement(
          'span',
          { className: classes, key: x + i },
          x
        );
      });

      colHeaders = cats.map(function (x, i) {
        classes = i === col ? bColId + ' ' + focusClass : bColId;
        return React.createElement(
          'span',
          { id: bColId + i, className: classes, key: x },
          abbrev[x]
        );
      });

      iHeaders = [].concat(_toConsumableArray(Array(colNames.length))).map(function (x, i) {
        return React.createElement(
          'span',
          { className: 'item-header item-header-' + i, key: colNames[i] },
          colNames[i]
        );
      });

      items = this.setItems(list, colNames, bRowId);

      return React.createElement(
        'div',
        { id: 'merchant-overlay', className: 'stage-overlay', tabIndex: '1', onKeyDown: this.optKeyDown },
        React.createElement(
          'h4',
          { className: 'merchant-header' },
          interactHeaders
        ),
        React.createElement(
          'div',
          { className: 'inv-categories' },
          colHeaders
        ),
        React.createElement(
          'div',
          { className: 'item-list' },
          React.createElement(
            'div',
            { className: 'iheader-row' },
            iHeaders
          ),
          items
        )
      );
    }
  }]);

  return OverlayMerchant;
}(React.Component);
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
  * React Components
  */

var Game = function (_React$Component) {
  _inherits(Game, _React$Component);

  function Game(props) {
    _classCallCheck(this, Game);

    var _this = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this, props));

    _this.resetGame = _this.resetGame.bind(_this);
    _this.toggleMute = _this.toggleMute.bind(_this);
    _this.handleKeyDown = _this.handleKeyDown.bind(_this);
    _this.updateGameClassState = _this.updateGameClassState.bind(_this);
    _this.pickupItem = _this.pickupItem.bind(_this);
    _this.focus = _this.focus.bind(_this);
    _this.maintainFocus = _this.maintainFocus.bind(_this);
    _this.endFocus = _this.endFocus.bind(_this);

    _this.directionKeys = {
      ArrowUp: 'up',
      KeyW: 'up',
      ArrowRight: 'right',
      KeyD: 'right',
      ArrowDown: 'down',
      KeyS: 'down',
      ArrowLeft: 'left',
      KeyA: 'left'
    };
    _this.statIncreaseKeys = {
      KeyV: 'bVitality',
      KeyB: 'bDurability',
      KeyN: 'bStrength',
      KeyM: 'bAgility'
    };
    _this.consumeDigits = ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8'];

    _this.state = {
      boardSize: 120,
      tileSize: 32,
      wall: 20,
      floor: 40,
      gameLevel: 1,
      bgLevelProcessed: 0,
      itemLevelProcessed: 0,
      levels: 10,
      hero: '',
      heroIcon: null,
      heroFacing: '',
      playerPalettes: {},
      moveCount: 0,
      levelUpCount: 1,
      gameOver: false,
      gameMuted: false,
      inventory: {
        Potion: {
          name: 'Potion',
          type: 'consumable',
          count: 10,
          equipped: false,
          itemArrVal: 200,
          palette: 'potionPalette',
          iconLoc: [0, 0, 32, 32],
          buy: 20,
          sell: 10,
          stats: { curHealth: 50 },
          spawnQuant: { '1': 2, '2': 3, '3': 3, '4': 2, '5': 1 }
        },
        'Hi Potion': {
          name: 'Hi Potion',
          type: 'consumable',
          count: 15,
          equipped: false,
          itemArrVal: 201,
          palette: 'potionPalette',
          iconLoc: [64, 0, 32, 32],
          buy: 50,
          sell: 25,
          stats: { curHealth: 150 },
          spawnQuant: { '4': 1, '5': 1, '6': 2, '7': 3, '8': 2, '9': 2, '10': 2 }
        },
        'Rough Club': {
          name: 'Rough Club',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [32, 64, 32, 32],
          buy: 10,
          sell: 5,
          stats: { iAttack: 4, iStrength: 1 },
          spawnQuant: { '1': 1 }
        },
        'Practice Sword': {
          name: 'Practice Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [128, 0, 32, 32],
          buy: 20,
          sell: 10,
          stats: { iAttack: 12, iStrength: 2 },
          spawnQuant: { '2': 1 }
        },
        'Short Sword': {
          name: 'Short Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [160, 0, 32, 32],
          buy: 40,
          sell: 20,
          stats: { iAttack: 20, iStrength: 4 },
          spawnQuant: { '4': 1 }
        },
        'Bronze Sword': {
          name: 'Bronze Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [64, 0, 32, 32],
          buy: 60,
          sell: 30,
          stats: { iAttack: 32, iStrength: 5, iAgility: 1 },
          spawnQuant: { '5': 1 }
        },
        'Rune Sword': {
          name: 'Rune Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [96, 0, 32, 32],
          buy: 80,
          sell: 40,
          stats: { iAttack: 44, iStrength: 7, iAgility: 2 },
          spawnQuant: { '7': 1 }
        },
        'Coral Sword': {
          name: 'Coral Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [0, 0, 32, 32],
          buy: 110,
          sell: 55,
          stats: { iAttack: 60, iStrength: 9, iAgility: 2 },
          spawnQuant: { '9': 1 }
        },
        'Dark Sword': {
          name: 'Dark Sword',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'medWepPalette',
          iconLoc: [32, 0, 32, 32],
          buy: 140,
          sell: 70,
          stats: { iAttack: 80, iStrength: 11, iAgility: 3 },
          spawnQuant: { '10': 1 }
        },
        // Polearms
        'Long Pole': {
          name: 'Long Pole',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [64, 128, 32, 32],
          buy: 10,
          sell: 5,
          stats: { iAttack: 4, iDurability: 1 },
          spawnQuant: { '1': 1 }
        },
        'Big Spade': {
          name: 'Big Spade',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [128, 128, 32, 32],
          buy: 20,
          sell: 10,
          stats: { iAttack: 8, iVitality: 1, iDurability: 1 },
          spawnQuant: { '2': 1 }
        },
        'Trident': {
          name: 'Trident',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [192, 0, 32, 32],
          buy: 40,
          sell: 20,
          stats: { iAttack: 16, iVitality: 2, iDurability: 1, iStrength: 1 },
          spawnQuant: { '4': 1 }
        },
        'Narrow Spear': {
          name: 'Narrow Spear',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [160, 0, 32, 32],
          buy: 60,
          sell: 30,
          stats: { iAttack: 24, iVitality: 3, iDurability: 2, iStrength: 2 },
          spawnQuant: { '5': 1 }
        },
        'Rune Voulge': {
          name: 'Rune Voulge',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [128, 64, 32, 32],
          buy: 80,
          sell: 40,
          stats: { iAttack: 36, iVitality: 4, iDurability: 2, iStrength: 4 },
          spawnQuant: { '7': 1 }
        },
        'Coral Bardiche': {
          name: 'Coral Bardiche',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [32, 128, 32, 32],
          buy: 110,
          sell: 55,
          stats: { iAttack: 48, iVitality: 4, iDurability: 4, iStrength: 5 },
          spawnQuant: { '9': 1 }
        },
        'Royal Poleaxe': {
          name: 'Royal Poleaxe',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'longWepPalette',
          iconLoc: [128, 0, 32, 32],
          buy: 140,
          sell: 70,
          stats: { iAttack: 72, iVitality: 5, iDurability: 5, iStrength: 5 },
          spawnQuant: { '10': 1 }
        },
        'Bent Stick': {
          name: 'Bent Stick',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [96, 160, 32, 32],
          buy: 10,
          sell: 5,
          stats: { iAttack: 8 },
          spawnQuant: { '1': 1 }
        },
        'Summoning Fork': {
          name: 'Summoning Fork',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [0, 96, 32, 32],
          buy: 20,
          sell: 10,
          stats: { iAttack: 20 },
          spawnQuant: { '2': 1 }
        },
        'Scavenged Wand': {
          name: 'Scavenged Wand',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [32, 0, 32, 32],
          buy: 40,
          sell: 20,
          stats: { iAttack: 28, iVitality: 1, iStrength: 1 },
          spawnQuant: { '4': 1 }
        },
        'Oak Rod': {
          name: 'Oak Rod',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [96, 128, 32, 32],
          buy: 60,
          sell: 30,
          stats: { iAttack: 52, iVitality: 1, iStrength: 2 },
          spawnQuant: { '5': 1 }
        },
        'Rune Wand': {
          name: 'Rune Wand',
          type: 'weapon',
          palette: 'wandPalette',
          iconLoc: [224, 0, 32, 32],
          buy: 80,
          sell: 40,
          stats: { iAttack: 72, iVitality: 2, iStrength: 2 },
          spawnQuant: { '6': 1 }
        },
        'Blazing Wand': {
          name: 'Blazing Wand',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [32, 128, 32, 32],
          buy: 110,
          sell: 55,
          stats: { iAttack: 88, iVitality: 2, iStrength: 2, iAgility: 2 },
          spawnQuant: { '9': 1 }
        },
        'Divining Rod': {
          name: 'Divining Rod',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'wandPalette',
          iconLoc: [0, 192, 32, 32],
          buy: 140,
          sell: 70,
          stats: { iAttack: 112, iVitality: 4, iStrength: 2, iAgility: 2 },
          spawnQuant: { '10': 1 }
        },
        //Short Weapons
        'Arrow Head': {
          name: 'Arrow Head',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [96, 32, 32, 32],
          buy: 10,
          sell: 5,
          stats: { iAttack: 4, iAgility: 1 },
          spawnQuant: { '1': 1 }
        },
        'Bone Knife': {
          name: 'Bone Knife',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [64, 32, 32, 32],
          buy: 20,
          sell: 10,
          stats: { iAttack: 12, iAgility: 2 },
          spawnQuant: { '2': 1 }
        },
        'Fishing Knife': {
          name: 'Fishing Knife',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [160, 0, 32, 32],
          buy: 40,
          sell: 20,
          stats: { iAttack: 20, iAgility: 4 },
          spawnQuant: { '4': 1 }
        },
        'Jagged Dagger': {
          name: 'Jagged Dagger',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [224, 0, 32, 32],
          buy: 60,
          sell: 30,
          stats: { iAttack: 32, iStrength: 1, iAgility: 5 },
          spawnQuant: { '5': 1 }
        },
        'Rune Dagger': {
          name: 'Rune Dagger',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [0, 32, 32, 32],
          buy: 80,
          sell: 40,
          stats: { iAttack: 48, iStrength: 2, iAgility: 6 },
          spawnQuant: { '7': 1 }
        },
        'Coral Dagger': {
          name: 'Coral Dagger',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [0, 0, 32, 32],
          buy: 110,
          sell: 55,
          stats: { iAttack: 68, iStrength: 2, iAgility: 7 },
          spawnQuant: { '9': 1 }
        },
        'Divining Dagger': {
          name: 'Divining Dagger',
          type: 'weapon',
          count: 1,
          equipped: false,
          itemArrVal: 186,
          palette: 'shortWepPalette',
          iconLoc: [96, 0, 32, 32],
          buy: 140,
          sell: 70,
          stats: { iAttack: 92, iStrength: 3, iAgility: 9 },
          spawnQuant: { '10': 1 }
        }
      },
      playerArr: [],
      bgArr: [],
      itemArr: [],
      floorCoords: [],
      itemPalettes: {},
      itemPaletteArrMap: {},
      interactItem: { count: 0, type: '', item: {}, source: {} },
      //type: pickup, use, equip, unequip, buy, buySuccess, buyFail, sell
      useStatPoint: { count: 0, type: '', item: {}, source: {} },
      increasedStat: { count: 0, type: '', stat: '', quant: 0 },
      quickConsume: { count: 0, num: 0 },
      enemyArr: [],
      enemyPalettes: {},
      enemyAttack: { count: 0, roundCount: 0, spawnIndex: 0, stats: {}, source: {} },
      exchangeAttacks: { count: 0, spawnIndex: 0, attacks: [] },
      enemyDead: {
        count: 0,
        spawnIndex: 0,
        coord: [],
        source: {},
        level: 0,
        experience: 0,
        gold: 0
      },
      overlayMode: 'hero-selection-overlay'
      //off, inv-overlay, help-overlay, merchant-overlay, game-over-overlay, game-win-overlay, hero-selection-overlay
    };
    return _this;
  }

  _createClass(Game, [{
    key: 'resetGame',
    value: function resetGame() {
      this.setState({
        gameLevel: 1,
        bgLevelProcessed: 0,
        hero: '',
        heroIcon: null,
        heroFacing: '',
        playerPalettes: {},
        moveCount: 0,
        levelUpCount: 1,
        gameOver: false,
        inventory: {},
        playerArr: [],
        bgArr: [],
        itemArr: [],
        floorCoords: [],
        itemPalettes: {},
        itemPaletteArrMap: {},
        interactItem: { count: 0, type: '', item: {}, source: {} },
        useStatPoint: { count: 0, type: '', item: {}, source: {} },
        increasedStat: { count: 0, type: '', stat: '', quant: 0 },
        quickConsume: { count: 0, num: 0 },
        enemyArr: [],
        enemyPalettes: {},
        enemyAttack: { count: 0, roundCount: 0, spawnIndex: 0, stats: {}, source: {} },
        exchangeAttacks: { count: 0, spawnIndex: 0, attacks: [] },
        enemyDead: {
          count: 0,
          spawnIndex: 0,
          coord: [],
          source: {},
          level: 0,
          experience: 0,
          gold: 0
        }
      });
    }
  }, {
    key: 'toggleMute',
    value: function toggleMute() {
      this.setState({ gameMuted: !this.state.gameMuted });
    }
  }, {
    key: 'updateGameClassState',
    value: function updateGameClassState() {
      var updatedEls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.setState(updatedEls);
    }
  }, {
    key: 'pickupItem',
    value: function pickupItem(coord, val, moveCount) {
      var item = Object.assign({}, this.state.itemPaletteArrMap['' + val]),
          inventory = Object.assign({}, this.state.inventory),
          itemArr = [].concat(_toConsumableArray(this.state.itemArr)),
          pArr = this.state.playerArr;

      var nState = {},
          interactItem = Object.assign({}, this.state.interactItem),
          dir = '';

      if (item.type !== 'openChest') {
        if (inventory[item.name]) inventory[item.name].count += 1;else item.count = 1, item.equipped = false, inventory[item.name] = item;

        if (['consumable', 'gold'].includes(item.type)) itemArr[coord[0]][coord[1]] = 0;else itemArr[coord[0]][coord[1]] = chestConsumables.openChest.itemArrVal;

        interactItem.count += 1;
        interactItem.type = 'pickup';
        interactItem.item = item;
        nState = { itemArr: itemArr, inventory: inventory, interactItem: interactItem, moveCount: moveCount };
      }

      dir = coord[0] < pArr[0] ? 'up' : coord[0] > pArr[0] ? 'down' : coord[1] < pArr[1] ? 'left' : 'right';

      if (this.state.heroFacing !== dir) nState.heroFacing = dir;

      nState.playerArr = coord;
      this.setState(nState);
    }
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(e) {
      if (this.state.overlayMode === 'off' && !e.nativeEvent.repeat) {
        var el = e.nativeEvent.code,
            _state = this.state,
            boardSize = _state.boardSize,
            floor = _state.floor,
            levels = _state.levels,
            playerArr = _state.playerArr,
            bgArr = _state.bgArr,
            itemArr = _state.itemArr,
            itemPaletteArrMap = _state.itemPaletteArrMap,
            enemyArr = _state.enemyArr,
            heroFacing = _state.heroFacing;
        var _state2 = this.state,
            gameLevel = _state2.gameLevel,
            moveCount = _state2.moveCount,
            nState = {},
            direction = '',
            row = 0,
            col = 0;


        if (this.directionKeys[el]) {
          moveCount++;
          direction = this.directionKeys[el];

          row = direction === 'up' ? playerArr[0] - 1 : direction === 'down' ? playerArr[0] + 1 : playerArr[0];

          col = direction === 'right' ? playerArr[1] + 1 : direction === 'left' ? playerArr[1] - 1 : playerArr[1];

          if (row >= 0 && row < boardSize && col >= 0 && col < boardSize && bgArr[row][col] > floor && !enemyArr[row][col]) {

            if (itemArr[row][col]) {
              this.pickupItem([row, col], itemArr[row][col], moveCount);
            } else {
              nState.playerArr = [row, col];
              nState.moveCount = moveCount;
              if (heroFacing !== direction) nState.heroFacing = direction;
              this.setState(nState);
            }
          } else if (itemArr[row][col] && itemPaletteArrMap['' + itemArr[row][col]].name === 'Active Portal') {

            if (gameLevel < levels) {
              this.setState({ gameLevel: gameLevel + 1 });
            } else {
              console.log('VICTORY!!!');
              this.setState({ gameOver: true, overlayMode: 'game-win-overlay' });
            }
          } else if (enemyArr[row][col] && enemyArr[row][col].type === 'merchant') {

            this.setState({ overlayMode: 'merchant-overlay' });
          } else {
            nState.moveCount = moveCount;
            if (heroFacing !== direction) nState.heroFacing = direction;
            this.setState(nState);
          }
        } else if (el === 'KeyI' || el === 'KeyE') {
          this.setState({ overlayMode: 'inv-overlay' });
        } else if (el === 'KeyH') {
          this.setState({ overlayMode: 'help-overlay' });
        } else if (this.consumeDigits.includes(el)) {
          this.setState({ quickConsume: { count: this.state.quickConsume.count + 1, num: el.slice(-1) } });
        } else if (this.statIncreaseKeys[el]) {
          this.setState({ useStatPoint: { count: this.state.useStatPoint.count + 1, stat: this.statIncreaseKeys[el] } });
        } else if (el === 'KeyQ' || el === 'KeyP') {
          this.toggleMute();
        }
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      ReactDOM.findDOMNode(this).focus();
    }
  }, {
    key: 'maintainFocus',
    value: function maintainFocus() {
      var _this2 = this;

      this.focus();
      this.focusID = setInterval(function () {
        return _this2.focus();
      }, 250);
    }
  }, {
    key: 'endFocus',
    value: function endFocus() {
      clearInterval(this.focusID);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.state.overlayMode === 'off') this.maintainFocus();
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (this.state.overlayMode !== nextState.overlayMode) {
        if (nextState.overlayMode === 'off') this.maintainFocus();else this.endFocus();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var _this3 = this;

      if (this.state.gameOver) {
        this.resetGame();
      }
      if (this.state.hero && this.state.heroIcon && this.state.overlayMode === 'hero-selection-overlay') {

        setTimeout(function () {
          _this3.setState({ overlayMode: 'off' });
        }, 1000);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var gameOver = this.state.gameOver;


      return React.createElement(
        'div',
        { className: 'game', tabIndex: '0', onKeyDown: this.handleKeyDown },
        gameOver ? null : React.createElement(GameSounds, {
          gameOver: this.state.gameOver,
          gameLevel: this.state.gameLevel,
          gameMuted: this.state.gameMuted,
          levels: this.state.levels,
          levelUpCount: this.state.levelUpCount,
          interactItem: this.state.interactItem,
          useStatPoint: this.state.useStatPoint,
          exchangeAttacks: this.state.exchangeAttacks,
          enemyDead: this.state.enemyDead,
          overlayMode: this.state.overlayMode }),
        React.createElement(
          'div',
          { className: 'game-display' },
          React.createElement(
            'div',
            { className: 'col-lft' },
            gameOver ? null : React.createElement(GameLevel, {
              gameLevel: this.state.gameLevel }),
            gameOver ? null : React.createElement(Hero, {
              tileSize: this.state.tileSize,
              hero: this.state.hero,
              heroIcon: this.state.heroIcon,
              inventory: this.state.inventory,
              itemPalettes: this.state.itemPalettes,
              interactItem: this.state.interactItem,
              useStatPoint: this.state.useStatPoint,
              increasedStat: this.state.increasedStat,
              enemyAttack: this.state.enemyAttack,
              exchangeAttacks: this.state.exchangeAttacks,
              enemyDead: this.state.enemyDead,
              gameOver: this.state.gameOver,
              updateGameClassState: this.updateGameClassState })
          ),
          React.createElement(
            'div',
            { className: 'col-mid' },
            React.createElement(
              'div',
              { className: 'title' },
              React.createElement('img', { src: 'img/CrimsonQuestTitle.png' })
            ),
            gameOver ? null : React.createElement(GameStage, {
              boardSize: this.state.boardSize,
              tileSize: this.state.tileSize,
              floor: this.state.floor,
              gameLevel: this.state.gameLevel,
              bgLevelProcessed: this.state.bgLevelProcessed,
              levels: this.state.levels,
              hero: this.state.hero,
              playerPalettes: this.state.playerPalettes,
              playerArr: this.state.playerArr,
              heroFacing: this.state.heroFacing,
              bgArr: this.state.bgArr,
              floorCoords: this.state.floorCoords,
              itemArr: this.state.itemArr,
              itemPalettes: this.state.itemPalettes,
              itemPaletteArrMap: this.state.itemPaletteArrMap,
              inventory: this.state.inventory,
              interactItem: this.state.interactItem,
              overlayMode: this.state.overlayMode,
              enemyArr: this.state.enemyArr,
              enemyPalettes: this.state.enemyPalettes,
              enemyDead: this.state.enemyDead,
              toggleMute: this.toggleMute,
              updateGameClassState: this.updateGameClassState }),
            gameOver ? null : React.createElement(ConsumableItems, {
              tileSize: this.state.tileSize,
              inventory: this.state.inventory,
              itemPalettes: this.state.itemPalettes,
              interactItem: this.state.interactItem,
              quickConsume: this.state.quickConsume,
              updateGameClassState: this.updateGameClassState })
          ),
          React.createElement(
            'div',
            { className: 'col-rgt' },
            gameOver ? null : React.createElement(CurrentObjective, {
              gameLevel: this.state.gameLevel,
              enemyDead: this.state.enemyDead }),
            gameOver ? null : React.createElement(EnemyManager, {
              tileSize: this.state.tileSize,
              floor: this.state.floor,
              gameLevel: this.state.gameLevel,
              itemLevelProcessed: this.state.itemLevelProcessed,
              playerArr: this.state.playerArr,
              moveCount: this.state.moveCount,
              bgArr: this.state.bgArr,
              floorCoords: this.state.floorCoords,
              enemyArr: this.state.enemyArr,
              enemyPalettes: this.state.enemyPalettes,
              enemyAttack: this.state.enemyAttack,
              exchangeAttacks: this.state.exchangeAttacks,
              enemyDead: this.state.enemyDead,
              updateGameClassState: this.updateGameClassState }),
            gameOver ? null : React.createElement(ActivityLog, {
              gameLevel: this.state.gameLevel,
              levelUpCount: this.state.levelUpCount,
              interactItem: this.state.interactItem,
              useStatPoint: this.state.useStatPoint,
              increasedStat: this.state.increasedStat,
              exchangeAttacks: this.state.exchangeAttacks,
              enemyDead: this.state.enemyDead }),
            gameOver ? null : React.createElement(GameTips, null)
          )
        )
      );
    }
  }]);

  return Game;
}(React.Component);

/**
	*		Static Page Components
	*/

/**
	*		@desc React Class renders page header
	*		@returns {HTML} page header
	*/


var PageHeader = function (_React$Component2) {
  _inherits(PageHeader, _React$Component2);

  function PageHeader() {
    _classCallCheck(this, PageHeader);

    return _possibleConstructorReturn(this, (PageHeader.__proto__ || Object.getPrototypeOf(PageHeader)).apply(this, arguments));
  }

  _createClass(PageHeader, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-header' },
        React.createElement(
          'h1',
          null,
          'CrimsonQuest'
        )
      );
    }
  }]);

  return PageHeader;
}(React.Component);

/**
	*		@desc React Class renders page footer
	*		@returns {HTML} page header
	*/


var PageFooter = function (_React$Component3) {
  _inherits(PageFooter, _React$Component3);

  function PageFooter() {
    _classCallCheck(this, PageFooter);

    return _possibleConstructorReturn(this, (PageFooter.__proto__ || Object.getPrototypeOf(PageFooter)).apply(this, arguments));
  }

  _createClass(PageFooter, [{
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg-footer' },
        React.createElement(
          'span',
          null,
          '\xA9 2017 Isaac Burbank.'
        ),
        React.createElement(
          'span',
          null,
          'Tiles By\xA0',
          React.createElement(
            'a',
            { href: 'http://opengameart.org/content/dawnlike-16x16-universal-rogue-like-tileset-v181', target: '_blank' },
            'DragonDePlatino'
          )
        )
      );
    }
  }]);

  return PageFooter;
}(React.Component);

/**
	*		Full App Class
	*/

/**
	*		@desc React Class renders full page
	*		@returns {HTML} full app
	*/


var App = function (_React$Component4) {
  _inherits(App, _React$Component4);

  function App() {
    _classCallCheck(this, App);

    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  _createClass(App, [{
    key: 'render',
    value: function render() {
      return React.createElement(
        'div',
        { className: 'pg' },
        React.createElement(
          'div',
          { className: 'pg-content' },
          React.createElement(Game, null)
        ),
        React.createElement(PageFooter, null)
      );
    }
  }]);

  return App;
}(React.Component);

/**
	*		Render App to DOM
	*/

/**
	*		@desc ReactDOM renders app to HTML root node
	*		@returns {DOM} full page
	*/


ReactDOM.render(React.createElement(App, null), document.getElementById('root'));